
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Addresses
 * 
 */
export type Addresses = $Result.DefaultSelection<Prisma.$AddressesPayload>
/**
 * Model Cohorts
 * 
 */
export type Cohorts = $Result.DefaultSelection<Prisma.$CohortsPayload>
/**
 * Model ProviderCohorts
 * 
 */
export type ProviderCohorts = $Result.DefaultSelection<Prisma.$ProviderCohortsPayload>
/**
 * Model Contacts
 * 
 */
export type Contacts = $Result.DefaultSelection<Prisma.$ContactsPayload>
/**
 * Model InstituteForms
 * 
 */
export type InstituteForms = $Result.DefaultSelection<Prisma.$InstituteFormsPayload>
/**
 * Model Institutes
 * 
 */
export type Institutes = $Result.DefaultSelection<Prisma.$InstitutesPayload>
/**
 * Model Logs
 * 
 */
export type Logs = $Result.DefaultSelection<Prisma.$LogsPayload>
/**
 * Model PlacementListings
 * 
 */
export type PlacementListings = $Result.DefaultSelection<Prisma.$PlacementListingsPayload>
/**
 * Model Placements
 * 
 */
export type Placements = $Result.DefaultSelection<Prisma.$PlacementsPayload>
/**
 * Model Providers
 * 
 */
export type Providers = $Result.DefaultSelection<Prisma.$ProvidersPayload>
/**
 * Model InstituteStudentUserGroups
 * 
 */
export type InstituteStudentUserGroups = $Result.DefaultSelection<Prisma.$InstituteStudentUserGroupsPayload>
/**
 * Model InstituteStaffUserGroups
 * 
 */
export type InstituteStaffUserGroups = $Result.DefaultSelection<Prisma.$InstituteStaffUserGroupsPayload>
/**
 * Model ProviderUserGroups
 * 
 */
export type ProviderUserGroups = $Result.DefaultSelection<Prisma.$ProviderUserGroupsPayload>
/**
 * Model StudentUsers
 * 
 */
export type StudentUsers = $Result.DefaultSelection<Prisma.$StudentUsersPayload>
/**
 * Model InstituteStaff
 * 
 */
export type InstituteStaff = $Result.DefaultSelection<Prisma.$InstituteStaffPayload>
/**
 * Model InstituteStudents
 * 
 */
export type InstituteStudents = $Result.DefaultSelection<Prisma.$InstituteStudentsPayload>
/**
 * Model ProviderStaff
 * 
 */
export type ProviderStaff = $Result.DefaultSelection<Prisma.$ProviderStaffPayload>
/**
 * Model Potentialproviders
 * 
 */
export type Potentialproviders = $Result.DefaultSelection<Prisma.$PotentialprovidersPayload>
/**
 * Model pointOfOrigin
 * 
 */
export type pointOfOrigin = $Result.DefaultSelection<Prisma.$pointOfOriginPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Addresses
 * const addresses = await prisma.addresses.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Addresses
   * const addresses = await prisma.addresses.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.addresses`: Exposes CRUD operations for the **Addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.addresses.findMany()
    * ```
    */
  get addresses(): Prisma.AddressesDelegate<ExtArgs>;

  /**
   * `prisma.cohorts`: Exposes CRUD operations for the **Cohorts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cohorts
    * const cohorts = await prisma.cohorts.findMany()
    * ```
    */
  get cohorts(): Prisma.CohortsDelegate<ExtArgs>;

  /**
   * `prisma.providerCohorts`: Exposes CRUD operations for the **ProviderCohorts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderCohorts
    * const providerCohorts = await prisma.providerCohorts.findMany()
    * ```
    */
  get providerCohorts(): Prisma.ProviderCohortsDelegate<ExtArgs>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **Contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.ContactsDelegate<ExtArgs>;

  /**
   * `prisma.instituteForms`: Exposes CRUD operations for the **InstituteForms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstituteForms
    * const instituteForms = await prisma.instituteForms.findMany()
    * ```
    */
  get instituteForms(): Prisma.InstituteFormsDelegate<ExtArgs>;

  /**
   * `prisma.institutes`: Exposes CRUD operations for the **Institutes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutes
    * const institutes = await prisma.institutes.findMany()
    * ```
    */
  get institutes(): Prisma.InstitutesDelegate<ExtArgs>;

  /**
   * `prisma.logs`: Exposes CRUD operations for the **Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.LogsDelegate<ExtArgs>;

  /**
   * `prisma.placementListings`: Exposes CRUD operations for the **PlacementListings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlacementListings
    * const placementListings = await prisma.placementListings.findMany()
    * ```
    */
  get placementListings(): Prisma.PlacementListingsDelegate<ExtArgs>;

  /**
   * `prisma.placements`: Exposes CRUD operations for the **Placements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Placements
    * const placements = await prisma.placements.findMany()
    * ```
    */
  get placements(): Prisma.PlacementsDelegate<ExtArgs>;

  /**
   * `prisma.providers`: Exposes CRUD operations for the **Providers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.providers.findMany()
    * ```
    */
  get providers(): Prisma.ProvidersDelegate<ExtArgs>;

  /**
   * `prisma.instituteStudentUserGroups`: Exposes CRUD operations for the **InstituteStudentUserGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstituteStudentUserGroups
    * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.findMany()
    * ```
    */
  get instituteStudentUserGroups(): Prisma.InstituteStudentUserGroupsDelegate<ExtArgs>;

  /**
   * `prisma.instituteStaffUserGroups`: Exposes CRUD operations for the **InstituteStaffUserGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstituteStaffUserGroups
    * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.findMany()
    * ```
    */
  get instituteStaffUserGroups(): Prisma.InstituteStaffUserGroupsDelegate<ExtArgs>;

  /**
   * `prisma.providerUserGroups`: Exposes CRUD operations for the **ProviderUserGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderUserGroups
    * const providerUserGroups = await prisma.providerUserGroups.findMany()
    * ```
    */
  get providerUserGroups(): Prisma.ProviderUserGroupsDelegate<ExtArgs>;

  /**
   * `prisma.studentUsers`: Exposes CRUD operations for the **StudentUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentUsers
    * const studentUsers = await prisma.studentUsers.findMany()
    * ```
    */
  get studentUsers(): Prisma.StudentUsersDelegate<ExtArgs>;

  /**
   * `prisma.instituteStaff`: Exposes CRUD operations for the **InstituteStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstituteStaffs
    * const instituteStaffs = await prisma.instituteStaff.findMany()
    * ```
    */
  get instituteStaff(): Prisma.InstituteStaffDelegate<ExtArgs>;

  /**
   * `prisma.instituteStudents`: Exposes CRUD operations for the **InstituteStudents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstituteStudents
    * const instituteStudents = await prisma.instituteStudents.findMany()
    * ```
    */
  get instituteStudents(): Prisma.InstituteStudentsDelegate<ExtArgs>;

  /**
   * `prisma.providerStaff`: Exposes CRUD operations for the **ProviderStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderStaffs
    * const providerStaffs = await prisma.providerStaff.findMany()
    * ```
    */
  get providerStaff(): Prisma.ProviderStaffDelegate<ExtArgs>;

  /**
   * `prisma.potentialproviders`: Exposes CRUD operations for the **Potentialproviders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Potentialproviders
    * const potentialproviders = await prisma.potentialproviders.findMany()
    * ```
    */
  get potentialproviders(): Prisma.PotentialprovidersDelegate<ExtArgs>;

  /**
   * `prisma.pointOfOrigin`: Exposes CRUD operations for the **pointOfOrigin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointOfOrigins
    * const pointOfOrigins = await prisma.pointOfOrigin.findMany()
    * ```
    */
  get pointOfOrigin(): Prisma.pointOfOriginDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.0
   * Query Engine version: 0a83d8541752d7582de2ebc1ece46519ce72a848
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Addresses: 'Addresses',
    Cohorts: 'Cohorts',
    ProviderCohorts: 'ProviderCohorts',
    Contacts: 'Contacts',
    InstituteForms: 'InstituteForms',
    Institutes: 'Institutes',
    Logs: 'Logs',
    PlacementListings: 'PlacementListings',
    Placements: 'Placements',
    Providers: 'Providers',
    InstituteStudentUserGroups: 'InstituteStudentUserGroups',
    InstituteStaffUserGroups: 'InstituteStaffUserGroups',
    ProviderUserGroups: 'ProviderUserGroups',
    StudentUsers: 'StudentUsers',
    InstituteStaff: 'InstituteStaff',
    InstituteStudents: 'InstituteStudents',
    ProviderStaff: 'ProviderStaff',
    Potentialproviders: 'Potentialproviders',
    pointOfOrigin: 'pointOfOrigin'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'addresses' | 'cohorts' | 'providerCohorts' | 'contacts' | 'instituteForms' | 'institutes' | 'logs' | 'placementListings' | 'placements' | 'providers' | 'instituteStudentUserGroups' | 'instituteStaffUserGroups' | 'providerUserGroups' | 'studentUsers' | 'instituteStaff' | 'instituteStudents' | 'providerStaff' | 'potentialproviders' | 'pointOfOrigin'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Addresses: {
        payload: Prisma.$AddressesPayload<ExtArgs>
        fields: Prisma.AddressesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          findFirst: {
            args: Prisma.AddressesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          findMany: {
            args: Prisma.AddressesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>[]
          }
          create: {
            args: Prisma.AddressesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          createMany: {
            args: Prisma.AddressesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddressesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          update: {
            args: Prisma.AddressesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          deleteMany: {
            args: Prisma.AddressesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddressesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddressesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          aggregate: {
            args: Prisma.AddressesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddresses>
          }
          groupBy: {
            args: Prisma.AddressesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressesCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressesCountAggregateOutputType> | number
          }
        }
      }
      Cohorts: {
        payload: Prisma.$CohortsPayload<ExtArgs>
        fields: Prisma.CohortsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CohortsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CohortsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          findFirst: {
            args: Prisma.CohortsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CohortsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          findMany: {
            args: Prisma.CohortsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>[]
          }
          create: {
            args: Prisma.CohortsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          createMany: {
            args: Prisma.CohortsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CohortsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          update: {
            args: Prisma.CohortsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          deleteMany: {
            args: Prisma.CohortsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CohortsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CohortsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          aggregate: {
            args: Prisma.CohortsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCohorts>
          }
          groupBy: {
            args: Prisma.CohortsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CohortsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CohortsCountArgs<ExtArgs>,
            result: $Utils.Optional<CohortsCountAggregateOutputType> | number
          }
        }
      }
      ProviderCohorts: {
        payload: Prisma.$ProviderCohortsPayload<ExtArgs>
        fields: Prisma.ProviderCohortsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderCohortsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderCohortsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload>
          }
          findFirst: {
            args: Prisma.ProviderCohortsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderCohortsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload>
          }
          findMany: {
            args: Prisma.ProviderCohortsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload>[]
          }
          create: {
            args: Prisma.ProviderCohortsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload>
          }
          createMany: {
            args: Prisma.ProviderCohortsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProviderCohortsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload>
          }
          update: {
            args: Prisma.ProviderCohortsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload>
          }
          deleteMany: {
            args: Prisma.ProviderCohortsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderCohortsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProviderCohortsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderCohortsPayload>
          }
          aggregate: {
            args: Prisma.ProviderCohortsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProviderCohorts>
          }
          groupBy: {
            args: Prisma.ProviderCohortsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProviderCohortsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCohortsCountArgs<ExtArgs>,
            result: $Utils.Optional<ProviderCohortsCountAggregateOutputType> | number
          }
        }
      }
      Contacts: {
        payload: Prisma.$ContactsPayload<ExtArgs>
        fields: Prisma.ContactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findFirst: {
            args: Prisma.ContactsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findMany: {
            args: Prisma.ContactsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          create: {
            args: Prisma.ContactsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          createMany: {
            args: Prisma.ContactsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContactsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          update: {
            args: Prisma.ContactsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          deleteMany: {
            args: Prisma.ContactsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.ContactsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      InstituteForms: {
        payload: Prisma.$InstituteFormsPayload<ExtArgs>
        fields: Prisma.InstituteFormsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteFormsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteFormsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload>
          }
          findFirst: {
            args: Prisma.InstituteFormsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteFormsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload>
          }
          findMany: {
            args: Prisma.InstituteFormsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload>[]
          }
          create: {
            args: Prisma.InstituteFormsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload>
          }
          createMany: {
            args: Prisma.InstituteFormsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstituteFormsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload>
          }
          update: {
            args: Prisma.InstituteFormsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload>
          }
          deleteMany: {
            args: Prisma.InstituteFormsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteFormsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstituteFormsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteFormsPayload>
          }
          aggregate: {
            args: Prisma.InstituteFormsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstituteForms>
          }
          groupBy: {
            args: Prisma.InstituteFormsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstituteFormsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteFormsCountArgs<ExtArgs>,
            result: $Utils.Optional<InstituteFormsCountAggregateOutputType> | number
          }
        }
      }
      Institutes: {
        payload: Prisma.$InstitutesPayload<ExtArgs>
        fields: Prisma.InstitutesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          findFirst: {
            args: Prisma.InstitutesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          findMany: {
            args: Prisma.InstitutesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>[]
          }
          create: {
            args: Prisma.InstitutesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          createMany: {
            args: Prisma.InstitutesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstitutesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          update: {
            args: Prisma.InstitutesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          deleteMany: {
            args: Prisma.InstitutesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstitutesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          aggregate: {
            args: Prisma.InstitutesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstitutes>
          }
          groupBy: {
            args: Prisma.InstitutesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstitutesGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutesCountArgs<ExtArgs>,
            result: $Utils.Optional<InstitutesCountAggregateOutputType> | number
          }
        }
      }
      Logs: {
        payload: Prisma.$LogsPayload<ExtArgs>
        fields: Prisma.LogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findFirst: {
            args: Prisma.LogsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findMany: {
            args: Prisma.LogsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          create: {
            args: Prisma.LogsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          createMany: {
            args: Prisma.LogsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          update: {
            args: Prisma.LogsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          deleteMany: {
            args: Prisma.LogsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          aggregate: {
            args: Prisma.LogsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogs>
          }
          groupBy: {
            args: Prisma.LogsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogsCountArgs<ExtArgs>,
            result: $Utils.Optional<LogsCountAggregateOutputType> | number
          }
        }
      }
      PlacementListings: {
        payload: Prisma.$PlacementListingsPayload<ExtArgs>
        fields: Prisma.PlacementListingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlacementListingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlacementListingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          findFirst: {
            args: Prisma.PlacementListingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlacementListingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          findMany: {
            args: Prisma.PlacementListingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>[]
          }
          create: {
            args: Prisma.PlacementListingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          createMany: {
            args: Prisma.PlacementListingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlacementListingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          update: {
            args: Prisma.PlacementListingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          deleteMany: {
            args: Prisma.PlacementListingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlacementListingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlacementListingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          aggregate: {
            args: Prisma.PlacementListingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlacementListings>
          }
          groupBy: {
            args: Prisma.PlacementListingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlacementListingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlacementListingsCountArgs<ExtArgs>,
            result: $Utils.Optional<PlacementListingsCountAggregateOutputType> | number
          }
        }
      }
      Placements: {
        payload: Prisma.$PlacementsPayload<ExtArgs>
        fields: Prisma.PlacementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlacementsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlacementsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          findFirst: {
            args: Prisma.PlacementsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlacementsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          findMany: {
            args: Prisma.PlacementsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>[]
          }
          create: {
            args: Prisma.PlacementsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          createMany: {
            args: Prisma.PlacementsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlacementsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          update: {
            args: Prisma.PlacementsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          deleteMany: {
            args: Prisma.PlacementsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlacementsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlacementsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          aggregate: {
            args: Prisma.PlacementsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlacements>
          }
          groupBy: {
            args: Prisma.PlacementsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlacementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlacementsCountArgs<ExtArgs>,
            result: $Utils.Optional<PlacementsCountAggregateOutputType> | number
          }
        }
      }
      Providers: {
        payload: Prisma.$ProvidersPayload<ExtArgs>
        fields: Prisma.ProvidersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvidersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvidersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          findFirst: {
            args: Prisma.ProvidersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvidersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          findMany: {
            args: Prisma.ProvidersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>[]
          }
          create: {
            args: Prisma.ProvidersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          createMany: {
            args: Prisma.ProvidersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProvidersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          update: {
            args: Prisma.ProvidersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          deleteMany: {
            args: Prisma.ProvidersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProvidersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProvidersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          aggregate: {
            args: Prisma.ProvidersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProviders>
          }
          groupBy: {
            args: Prisma.ProvidersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProvidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvidersCountArgs<ExtArgs>,
            result: $Utils.Optional<ProvidersCountAggregateOutputType> | number
          }
        }
      }
      InstituteStudentUserGroups: {
        payload: Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>
        fields: Prisma.InstituteStudentUserGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteStudentUserGroupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteStudentUserGroupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload>
          }
          findFirst: {
            args: Prisma.InstituteStudentUserGroupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteStudentUserGroupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload>
          }
          findMany: {
            args: Prisma.InstituteStudentUserGroupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload>[]
          }
          create: {
            args: Prisma.InstituteStudentUserGroupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload>
          }
          createMany: {
            args: Prisma.InstituteStudentUserGroupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstituteStudentUserGroupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload>
          }
          update: {
            args: Prisma.InstituteStudentUserGroupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload>
          }
          deleteMany: {
            args: Prisma.InstituteStudentUserGroupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteStudentUserGroupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstituteStudentUserGroupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentUserGroupsPayload>
          }
          aggregate: {
            args: Prisma.InstituteStudentUserGroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstituteStudentUserGroups>
          }
          groupBy: {
            args: Prisma.InstituteStudentUserGroupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStudentUserGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteStudentUserGroupsCountArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStudentUserGroupsCountAggregateOutputType> | number
          }
        }
      }
      InstituteStaffUserGroups: {
        payload: Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>
        fields: Prisma.InstituteStaffUserGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteStaffUserGroupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteStaffUserGroupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload>
          }
          findFirst: {
            args: Prisma.InstituteStaffUserGroupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteStaffUserGroupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload>
          }
          findMany: {
            args: Prisma.InstituteStaffUserGroupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload>[]
          }
          create: {
            args: Prisma.InstituteStaffUserGroupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload>
          }
          createMany: {
            args: Prisma.InstituteStaffUserGroupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstituteStaffUserGroupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload>
          }
          update: {
            args: Prisma.InstituteStaffUserGroupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload>
          }
          deleteMany: {
            args: Prisma.InstituteStaffUserGroupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteStaffUserGroupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstituteStaffUserGroupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffUserGroupsPayload>
          }
          aggregate: {
            args: Prisma.InstituteStaffUserGroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstituteStaffUserGroups>
          }
          groupBy: {
            args: Prisma.InstituteStaffUserGroupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStaffUserGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteStaffUserGroupsCountArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStaffUserGroupsCountAggregateOutputType> | number
          }
        }
      }
      ProviderUserGroups: {
        payload: Prisma.$ProviderUserGroupsPayload<ExtArgs>
        fields: Prisma.ProviderUserGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderUserGroupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderUserGroupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload>
          }
          findFirst: {
            args: Prisma.ProviderUserGroupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderUserGroupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload>
          }
          findMany: {
            args: Prisma.ProviderUserGroupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload>[]
          }
          create: {
            args: Prisma.ProviderUserGroupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload>
          }
          createMany: {
            args: Prisma.ProviderUserGroupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProviderUserGroupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload>
          }
          update: {
            args: Prisma.ProviderUserGroupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload>
          }
          deleteMany: {
            args: Prisma.ProviderUserGroupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUserGroupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProviderUserGroupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderUserGroupsPayload>
          }
          aggregate: {
            args: Prisma.ProviderUserGroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProviderUserGroups>
          }
          groupBy: {
            args: Prisma.ProviderUserGroupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProviderUserGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderUserGroupsCountArgs<ExtArgs>,
            result: $Utils.Optional<ProviderUserGroupsCountAggregateOutputType> | number
          }
        }
      }
      StudentUsers: {
        payload: Prisma.$StudentUsersPayload<ExtArgs>
        fields: Prisma.StudentUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentUsersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentUsersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          findFirst: {
            args: Prisma.StudentUsersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentUsersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          findMany: {
            args: Prisma.StudentUsersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>[]
          }
          create: {
            args: Prisma.StudentUsersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          createMany: {
            args: Prisma.StudentUsersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentUsersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          update: {
            args: Prisma.StudentUsersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          deleteMany: {
            args: Prisma.StudentUsersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUsersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentUsersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          aggregate: {
            args: Prisma.StudentUsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentUsers>
          }
          groupBy: {
            args: Prisma.StudentUsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentUsersCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentUsersCountAggregateOutputType> | number
          }
        }
      }
      InstituteStaff: {
        payload: Prisma.$InstituteStaffPayload<ExtArgs>
        fields: Prisma.InstituteStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteStaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteStaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          findFirst: {
            args: Prisma.InstituteStaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteStaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          findMany: {
            args: Prisma.InstituteStaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>[]
          }
          create: {
            args: Prisma.InstituteStaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          createMany: {
            args: Prisma.InstituteStaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstituteStaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          update: {
            args: Prisma.InstituteStaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          deleteMany: {
            args: Prisma.InstituteStaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteStaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstituteStaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          aggregate: {
            args: Prisma.InstituteStaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstituteStaff>
          }
          groupBy: {
            args: Prisma.InstituteStaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteStaffCountArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStaffCountAggregateOutputType> | number
          }
        }
      }
      InstituteStudents: {
        payload: Prisma.$InstituteStudentsPayload<ExtArgs>
        fields: Prisma.InstituteStudentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteStudentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteStudentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          findFirst: {
            args: Prisma.InstituteStudentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteStudentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          findMany: {
            args: Prisma.InstituteStudentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>[]
          }
          create: {
            args: Prisma.InstituteStudentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          createMany: {
            args: Prisma.InstituteStudentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstituteStudentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          update: {
            args: Prisma.InstituteStudentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          deleteMany: {
            args: Prisma.InstituteStudentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteStudentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstituteStudentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          aggregate: {
            args: Prisma.InstituteStudentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstituteStudents>
          }
          groupBy: {
            args: Prisma.InstituteStudentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteStudentsCountArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStudentsCountAggregateOutputType> | number
          }
        }
      }
      ProviderStaff: {
        payload: Prisma.$ProviderStaffPayload<ExtArgs>
        fields: Prisma.ProviderStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderStaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderStaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          findFirst: {
            args: Prisma.ProviderStaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderStaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          findMany: {
            args: Prisma.ProviderStaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>[]
          }
          create: {
            args: Prisma.ProviderStaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          createMany: {
            args: Prisma.ProviderStaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProviderStaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          update: {
            args: Prisma.ProviderStaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          deleteMany: {
            args: Prisma.ProviderStaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderStaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProviderStaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          aggregate: {
            args: Prisma.ProviderStaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProviderStaff>
          }
          groupBy: {
            args: Prisma.ProviderStaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProviderStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderStaffCountArgs<ExtArgs>,
            result: $Utils.Optional<ProviderStaffCountAggregateOutputType> | number
          }
        }
      }
      Potentialproviders: {
        payload: Prisma.$PotentialprovidersPayload<ExtArgs>
        fields: Prisma.PotentialprovidersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PotentialprovidersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PotentialprovidersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload>
          }
          findFirst: {
            args: Prisma.PotentialprovidersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PotentialprovidersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload>
          }
          findMany: {
            args: Prisma.PotentialprovidersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload>[]
          }
          create: {
            args: Prisma.PotentialprovidersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload>
          }
          createMany: {
            args: Prisma.PotentialprovidersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PotentialprovidersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload>
          }
          update: {
            args: Prisma.PotentialprovidersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload>
          }
          deleteMany: {
            args: Prisma.PotentialprovidersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PotentialprovidersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PotentialprovidersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PotentialprovidersPayload>
          }
          aggregate: {
            args: Prisma.PotentialprovidersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePotentialproviders>
          }
          groupBy: {
            args: Prisma.PotentialprovidersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PotentialprovidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.PotentialprovidersCountArgs<ExtArgs>,
            result: $Utils.Optional<PotentialprovidersCountAggregateOutputType> | number
          }
        }
      }
      pointOfOrigin: {
        payload: Prisma.$pointOfOriginPayload<ExtArgs>
        fields: Prisma.pointOfOriginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pointOfOriginFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pointOfOriginFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload>
          }
          findFirst: {
            args: Prisma.pointOfOriginFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pointOfOriginFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload>
          }
          findMany: {
            args: Prisma.pointOfOriginFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload>[]
          }
          create: {
            args: Prisma.pointOfOriginCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload>
          }
          createMany: {
            args: Prisma.pointOfOriginCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.pointOfOriginDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload>
          }
          update: {
            args: Prisma.pointOfOriginUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload>
          }
          deleteMany: {
            args: Prisma.pointOfOriginDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.pointOfOriginUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.pointOfOriginUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$pointOfOriginPayload>
          }
          aggregate: {
            args: Prisma.PointOfOriginAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePointOfOrigin>
          }
          groupBy: {
            args: Prisma.pointOfOriginGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PointOfOriginGroupByOutputType>[]
          }
          count: {
            args: Prisma.pointOfOriginCountArgs<ExtArgs>,
            result: $Utils.Optional<PointOfOriginCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AddressesCountOutputType
   */

  export type AddressesCountOutputType = {
    Contacts: number
    PlacementListings: number
    Placements: number
    ProviderCohorts: number
  }

  export type AddressesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contacts?: boolean | AddressesCountOutputTypeCountContactsArgs
    PlacementListings?: boolean | AddressesCountOutputTypeCountPlacementListingsArgs
    Placements?: boolean | AddressesCountOutputTypeCountPlacementsArgs
    ProviderCohorts?: boolean | AddressesCountOutputTypeCountProviderCohortsArgs
  }

  // Custom InputTypes

  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressesCountOutputType
     */
    select?: AddressesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
  }


  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeCountPlacementListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementListingsWhereInput
  }


  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementsWhereInput
  }


  /**
   * AddressesCountOutputType without action
   */
  export type AddressesCountOutputTypeCountProviderCohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderCohortsWhereInput
  }



  /**
   * Count Type CohortsCountOutputType
   */

  export type CohortsCountOutputType = {
    InstituteStudents: number
  }

  export type CohortsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InstituteStudents?: boolean | CohortsCountOutputTypeCountInstituteStudentsArgs
  }

  // Custom InputTypes

  /**
   * CohortsCountOutputType without action
   */
  export type CohortsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CohortsCountOutputType
     */
    select?: CohortsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CohortsCountOutputType without action
   */
  export type CohortsCountOutputTypeCountInstituteStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStudentsWhereInput
  }



  /**
   * Count Type InstitutesCountOutputType
   */

  export type InstitutesCountOutputType = {
    Addresses: number
    Cohorts: number
    Forms: number
    InstituteStaff: number
    StaffUserGroups: number
    StudentUserGroups: number
    InstituteStudents: number
    Placements: number
  }

  export type InstitutesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Addresses?: boolean | InstitutesCountOutputTypeCountAddressesArgs
    Cohorts?: boolean | InstitutesCountOutputTypeCountCohortsArgs
    Forms?: boolean | InstitutesCountOutputTypeCountFormsArgs
    InstituteStaff?: boolean | InstitutesCountOutputTypeCountInstituteStaffArgs
    StaffUserGroups?: boolean | InstitutesCountOutputTypeCountStaffUserGroupsArgs
    StudentUserGroups?: boolean | InstitutesCountOutputTypeCountStudentUserGroupsArgs
    InstituteStudents?: boolean | InstitutesCountOutputTypeCountInstituteStudentsArgs
    Placements?: boolean | InstitutesCountOutputTypeCountPlacementsArgs
  }

  // Custom InputTypes

  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutesCountOutputType
     */
    select?: InstitutesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressesWhereInput
  }


  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeCountCohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CohortsWhereInput
  }


  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeCountFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteFormsWhereInput
  }


  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeCountInstituteStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStaffWhereInput
  }


  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeCountStaffUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStaffUserGroupsWhereInput
  }


  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeCountStudentUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStudentUserGroupsWhereInput
  }


  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeCountInstituteStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStudentsWhereInput
  }


  /**
   * InstitutesCountOutputType without action
   */
  export type InstitutesCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementsWhereInput
  }



  /**
   * Count Type PlacementsCountOutputType
   */

  export type PlacementsCountOutputType = {
    Logs: number
  }

  export type PlacementsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Logs?: boolean | PlacementsCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes

  /**
   * PlacementsCountOutputType without action
   */
  export type PlacementsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementsCountOutputType
     */
    select?: PlacementsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PlacementsCountOutputType without action
   */
  export type PlacementsCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }



  /**
   * Count Type ProvidersCountOutputType
   */

  export type ProvidersCountOutputType = {
    Addresses: number
    PlacementListings: number
    Placements: number
    ProviderStaff: number
    ProviderUserGroups: number
    ProviderCohorts: number
  }

  export type ProvidersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Addresses?: boolean | ProvidersCountOutputTypeCountAddressesArgs
    PlacementListings?: boolean | ProvidersCountOutputTypeCountPlacementListingsArgs
    Placements?: boolean | ProvidersCountOutputTypeCountPlacementsArgs
    ProviderStaff?: boolean | ProvidersCountOutputTypeCountProviderStaffArgs
    ProviderUserGroups?: boolean | ProvidersCountOutputTypeCountProviderUserGroupsArgs
    ProviderCohorts?: boolean | ProvidersCountOutputTypeCountProviderCohortsArgs
  }

  // Custom InputTypes

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvidersCountOutputType
     */
    select?: ProvidersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressesWhereInput
  }


  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountPlacementListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementListingsWhereInput
  }


  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementsWhereInput
  }


  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountProviderStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderStaffWhereInput
  }


  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountProviderUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderUserGroupsWhereInput
  }


  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountProviderCohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderCohortsWhereInput
  }



  /**
   * Count Type InstituteStudentUserGroupsCountOutputType
   */

  export type InstituteStudentUserGroupsCountOutputType = {
    InstituteStudents: number
    Placements: number
  }

  export type InstituteStudentUserGroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InstituteStudents?: boolean | InstituteStudentUserGroupsCountOutputTypeCountInstituteStudentsArgs
    Placements?: boolean | InstituteStudentUserGroupsCountOutputTypeCountPlacementsArgs
  }

  // Custom InputTypes

  /**
   * InstituteStudentUserGroupsCountOutputType without action
   */
  export type InstituteStudentUserGroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroupsCountOutputType
     */
    select?: InstituteStudentUserGroupsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InstituteStudentUserGroupsCountOutputType without action
   */
  export type InstituteStudentUserGroupsCountOutputTypeCountInstituteStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStudentsWhereInput
  }


  /**
   * InstituteStudentUserGroupsCountOutputType without action
   */
  export type InstituteStudentUserGroupsCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementsWhereInput
  }



  /**
   * Count Type InstituteStaffUserGroupsCountOutputType
   */

  export type InstituteStaffUserGroupsCountOutputType = {
    InstituteStaff: number
  }

  export type InstituteStaffUserGroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InstituteStaff?: boolean | InstituteStaffUserGroupsCountOutputTypeCountInstituteStaffArgs
  }

  // Custom InputTypes

  /**
   * InstituteStaffUserGroupsCountOutputType without action
   */
  export type InstituteStaffUserGroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroupsCountOutputType
     */
    select?: InstituteStaffUserGroupsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InstituteStaffUserGroupsCountOutputType without action
   */
  export type InstituteStaffUserGroupsCountOutputTypeCountInstituteStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStaffWhereInput
  }



  /**
   * Count Type ProviderUserGroupsCountOutputType
   */

  export type ProviderUserGroupsCountOutputType = {
    ProviderStaff: number
  }

  export type ProviderUserGroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProviderStaff?: boolean | ProviderUserGroupsCountOutputTypeCountProviderStaffArgs
  }

  // Custom InputTypes

  /**
   * ProviderUserGroupsCountOutputType without action
   */
  export type ProviderUserGroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroupsCountOutputType
     */
    select?: ProviderUserGroupsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProviderUserGroupsCountOutputType without action
   */
  export type ProviderUserGroupsCountOutputTypeCountProviderStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderStaffWhereInput
  }



  /**
   * Count Type StudentUsersCountOutputType
   */

  export type StudentUsersCountOutputType = {
    Contacts: number
    Placements: number
  }

  export type StudentUsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contacts?: boolean | StudentUsersCountOutputTypeCountContactsArgs
    Placements?: boolean | StudentUsersCountOutputTypeCountPlacementsArgs
  }

  // Custom InputTypes

  /**
   * StudentUsersCountOutputType without action
   */
  export type StudentUsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsersCountOutputType
     */
    select?: StudentUsersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StudentUsersCountOutputType without action
   */
  export type StudentUsersCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
  }


  /**
   * StudentUsersCountOutputType without action
   */
  export type StudentUsersCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementsWhereInput
  }



  /**
   * Count Type InstituteStudentsCountOutputType
   */

  export type InstituteStudentsCountOutputType = {
    Contacts: number
    Placements: number
  }

  export type InstituteStudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contacts?: boolean | InstituteStudentsCountOutputTypeCountContactsArgs
    Placements?: boolean | InstituteStudentsCountOutputTypeCountPlacementsArgs
  }

  // Custom InputTypes

  /**
   * InstituteStudentsCountOutputType without action
   */
  export type InstituteStudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentsCountOutputType
     */
    select?: InstituteStudentsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InstituteStudentsCountOutputType without action
   */
  export type InstituteStudentsCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
  }


  /**
   * InstituteStudentsCountOutputType without action
   */
  export type InstituteStudentsCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementsWhereInput
  }



  /**
   * Count Type PointOfOriginCountOutputType
   */

  export type PointOfOriginCountOutputType = {
    Potentialproviders: number
  }

  export type PointOfOriginCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Potentialproviders?: boolean | PointOfOriginCountOutputTypeCountPotentialprovidersArgs
  }

  // Custom InputTypes

  /**
   * PointOfOriginCountOutputType without action
   */
  export type PointOfOriginCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfOriginCountOutputType
     */
    select?: PointOfOriginCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PointOfOriginCountOutputType without action
   */
  export type PointOfOriginCountOutputTypeCountPotentialprovidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PotentialprovidersWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Addresses
   */

  export type AggregateAddresses = {
    _count: AddressesCountAggregateOutputType | null
    _min: AddressesMinAggregateOutputType | null
    _max: AddressesMaxAggregateOutputType | null
  }

  export type AddressesMinAggregateOutputType = {
    addressId: string | null
    name: string | null
    stage: string | null
    addressLine1: string | null
    addressLine2: string | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    email: string | null
    geoHash: string | null
    locality: string | null
    phone: string | null
    postal_code: string | null
    instituteId: string | null
    providerId: string | null
  }

  export type AddressesMaxAggregateOutputType = {
    addressId: string | null
    name: string | null
    stage: string | null
    addressLine1: string | null
    addressLine2: string | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    email: string | null
    geoHash: string | null
    locality: string | null
    phone: string | null
    postal_code: string | null
    instituteId: string | null
    providerId: string | null
  }

  export type AddressesCountAggregateOutputType = {
    addressId: number
    name: number
    stage: number
    addressLine1: number
    addressLine2: number
    contactForename: number
    contactSurname: number
    country: number
    email: number
    geoHash: number
    locality: number
    phone: number
    postal_code: number
    instituteId: number
    providerId: number
    _all: number
  }


  export type AddressesMinAggregateInputType = {
    addressId?: true
    name?: true
    stage?: true
    addressLine1?: true
    addressLine2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    email?: true
    geoHash?: true
    locality?: true
    phone?: true
    postal_code?: true
    instituteId?: true
    providerId?: true
  }

  export type AddressesMaxAggregateInputType = {
    addressId?: true
    name?: true
    stage?: true
    addressLine1?: true
    addressLine2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    email?: true
    geoHash?: true
    locality?: true
    phone?: true
    postal_code?: true
    instituteId?: true
    providerId?: true
  }

  export type AddressesCountAggregateInputType = {
    addressId?: true
    name?: true
    stage?: true
    addressLine1?: true
    addressLine2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    email?: true
    geoHash?: true
    locality?: true
    phone?: true
    postal_code?: true
    instituteId?: true
    providerId?: true
    _all?: true
  }

  export type AddressesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to aggregate.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressesMaxAggregateInputType
  }

  export type GetAddressesAggregateType<T extends AddressesAggregateArgs> = {
        [P in keyof T & keyof AggregateAddresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddresses[P]>
      : GetScalarType<T[P], AggregateAddresses[P]>
  }




  export type AddressesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressesWhereInput
    orderBy?: AddressesOrderByWithAggregationInput | AddressesOrderByWithAggregationInput[]
    by: AddressesScalarFieldEnum[] | AddressesScalarFieldEnum
    having?: AddressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressesCountAggregateInputType | true
    _min?: AddressesMinAggregateInputType
    _max?: AddressesMaxAggregateInputType
  }

  export type AddressesGroupByOutputType = {
    addressId: string
    name: string
    stage: string | null
    addressLine1: string | null
    addressLine2: string | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    email: string | null
    geoHash: string | null
    locality: string | null
    phone: string | null
    postal_code: string | null
    instituteId: string | null
    providerId: string | null
    _count: AddressesCountAggregateOutputType | null
    _min: AddressesMinAggregateOutputType | null
    _max: AddressesMaxAggregateOutputType | null
  }

  type GetAddressesGroupByPayload<T extends AddressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressesGroupByOutputType[P]>
            : GetScalarType<T[P], AddressesGroupByOutputType[P]>
        }
      >
    >


  export type AddressesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    addressId?: boolean
    name?: boolean
    stage?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    country?: boolean
    email?: boolean
    geoHash?: boolean
    locality?: boolean
    phone?: boolean
    postal_code?: boolean
    instituteId?: boolean
    providerId?: boolean
    institute?: boolean | Addresses$instituteArgs<ExtArgs>
    provider?: boolean | Addresses$providerArgs<ExtArgs>
    Contacts?: boolean | Addresses$ContactsArgs<ExtArgs>
    PlacementListings?: boolean | Addresses$PlacementListingsArgs<ExtArgs>
    Placements?: boolean | Addresses$PlacementsArgs<ExtArgs>
    ProviderCohorts?: boolean | Addresses$ProviderCohortsArgs<ExtArgs>
    _count?: boolean | AddressesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addresses"]>

  export type AddressesSelectScalar = {
    addressId?: boolean
    name?: boolean
    stage?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    country?: boolean
    email?: boolean
    geoHash?: boolean
    locality?: boolean
    phone?: boolean
    postal_code?: boolean
    instituteId?: boolean
    providerId?: boolean
  }

  export type AddressesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institute?: boolean | Addresses$instituteArgs<ExtArgs>
    provider?: boolean | Addresses$providerArgs<ExtArgs>
    Contacts?: boolean | Addresses$ContactsArgs<ExtArgs>
    PlacementListings?: boolean | Addresses$PlacementListingsArgs<ExtArgs>
    Placements?: boolean | Addresses$PlacementsArgs<ExtArgs>
    ProviderCohorts?: boolean | Addresses$ProviderCohortsArgs<ExtArgs>
    _count?: boolean | AddressesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AddressesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Addresses"
    objects: {
      institute: Prisma.$InstitutesPayload<ExtArgs> | null
      provider: Prisma.$ProvidersPayload<ExtArgs> | null
      Contacts: Prisma.$ContactsPayload<ExtArgs>[]
      PlacementListings: Prisma.$PlacementListingsPayload<ExtArgs>[]
      Placements: Prisma.$PlacementsPayload<ExtArgs>[]
      ProviderCohorts: Prisma.$ProviderCohortsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      addressId: string
      name: string
      stage: string | null
      addressLine1: string | null
      addressLine2: string | null
      contactForename: string | null
      contactSurname: string | null
      country: string | null
      email: string | null
      geoHash: string | null
      locality: string | null
      phone: string | null
      postal_code: string | null
      instituteId: string | null
      providerId: string | null
    }, ExtArgs["result"]["addresses"]>
    composites: {}
  }


  type AddressesGetPayload<S extends boolean | null | undefined | AddressesDefaultArgs> = $Result.GetResult<Prisma.$AddressesPayload, S>

  type AddressesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressesCountAggregateInputType | true
    }

  export interface AddressesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Addresses'], meta: { name: 'Addresses' } }
    /**
     * Find zero or one Addresses that matches the filter.
     * @param {AddressesFindUniqueArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Addresses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressesFindUniqueOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindFirstArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindFirstArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindFirstOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.addresses.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.addresses.findMany({ take: 10 })
     * 
     * // Only select the `addressId`
     * const addressesWithAddressIdOnly = await prisma.addresses.findMany({ select: { addressId: true } })
     * 
    **/
    findMany<T extends AddressesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Addresses.
     * @param {AddressesCreateArgs} args - Arguments to create a Addresses.
     * @example
     * // Create one Addresses
     * const Addresses = await prisma.addresses.create({
     *   data: {
     *     // ... data to create a Addresses
     *   }
     * })
     * 
    **/
    create<T extends AddressesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesCreateArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Addresses.
     *     @param {AddressesCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const addresses = await prisma.addresses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Addresses.
     * @param {AddressesDeleteArgs} args - Arguments to delete one Addresses.
     * @example
     * // Delete one Addresses
     * const Addresses = await prisma.addresses.delete({
     *   where: {
     *     // ... filter to delete one Addresses
     *   }
     * })
     * 
    **/
    delete<T extends AddressesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesDeleteArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Addresses.
     * @param {AddressesUpdateArgs} args - Arguments to update one Addresses.
     * @example
     * // Update one Addresses
     * const addresses = await prisma.addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpdateArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressesDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const addresses = await prisma.addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Addresses.
     * @param {AddressesUpsertArgs} args - Arguments to update or create a Addresses.
     * @example
     * // Update or create a Addresses
     * const addresses = await prisma.addresses.upsert({
     *   create: {
     *     // ... data to create a Addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Addresses we want to update
     *   }
     * })
    **/
    upsert<T extends AddressesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpsertArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.addresses.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressesCountArgs>(
      args?: Subset<T, AddressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressesAggregateArgs>(args: Subset<T, AddressesAggregateArgs>): Prisma.PrismaPromise<GetAddressesAggregateType<T>>

    /**
     * Group by Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressesGroupByArgs['orderBy'] }
        : { orderBy?: AddressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Addresses model
   */
  readonly fields: AddressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    institute<T extends Addresses$instituteArgs<ExtArgs> = {}>(args?: Subset<T, Addresses$instituteArgs<ExtArgs>>): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    provider<T extends Addresses$providerArgs<ExtArgs> = {}>(args?: Subset<T, Addresses$providerArgs<ExtArgs>>): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Contacts<T extends Addresses$ContactsArgs<ExtArgs> = {}>(args?: Subset<T, Addresses$ContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findMany'> | Null>;

    PlacementListings<T extends Addresses$PlacementListingsArgs<ExtArgs> = {}>(args?: Subset<T, Addresses$PlacementListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Placements<T extends Addresses$PlacementsArgs<ExtArgs> = {}>(args?: Subset<T, Addresses$PlacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findMany'> | Null>;

    ProviderCohorts<T extends Addresses$ProviderCohortsArgs<ExtArgs> = {}>(args?: Subset<T, Addresses$ProviderCohortsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Addresses model
   */ 
  interface AddressesFieldRefs {
    readonly addressId: FieldRef<"Addresses", 'String'>
    readonly name: FieldRef<"Addresses", 'String'>
    readonly stage: FieldRef<"Addresses", 'String'>
    readonly addressLine1: FieldRef<"Addresses", 'String'>
    readonly addressLine2: FieldRef<"Addresses", 'String'>
    readonly contactForename: FieldRef<"Addresses", 'String'>
    readonly contactSurname: FieldRef<"Addresses", 'String'>
    readonly country: FieldRef<"Addresses", 'String'>
    readonly email: FieldRef<"Addresses", 'String'>
    readonly geoHash: FieldRef<"Addresses", 'String'>
    readonly locality: FieldRef<"Addresses", 'String'>
    readonly phone: FieldRef<"Addresses", 'String'>
    readonly postal_code: FieldRef<"Addresses", 'String'>
    readonly instituteId: FieldRef<"Addresses", 'String'>
    readonly providerId: FieldRef<"Addresses", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Addresses findUnique
   */
  export type AddressesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where: AddressesWhereUniqueInput
  }


  /**
   * Addresses findUniqueOrThrow
   */
  export type AddressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where: AddressesWhereUniqueInput
  }


  /**
   * Addresses findFirst
   */
  export type AddressesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }


  /**
   * Addresses findFirstOrThrow
   */
  export type AddressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }


  /**
   * Addresses findMany
   */
  export type AddressesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }


  /**
   * Addresses create
   */
  export type AddressesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * The data needed to create a Addresses.
     */
    data: XOR<AddressesCreateInput, AddressesUncheckedCreateInput>
  }


  /**
   * Addresses createMany
   */
  export type AddressesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressesCreateManyInput | AddressesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Addresses update
   */
  export type AddressesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * The data needed to update a Addresses.
     */
    data: XOR<AddressesUpdateInput, AddressesUncheckedUpdateInput>
    /**
     * Choose, which Addresses to update.
     */
    where: AddressesWhereUniqueInput
  }


  /**
   * Addresses updateMany
   */
  export type AddressesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressesUpdateManyMutationInput, AddressesUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressesWhereInput
  }


  /**
   * Addresses upsert
   */
  export type AddressesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * The filter to search for the Addresses to update in case it exists.
     */
    where: AddressesWhereUniqueInput
    /**
     * In case the Addresses found by the `where` argument doesn't exist, create a new Addresses with this data.
     */
    create: XOR<AddressesCreateInput, AddressesUncheckedCreateInput>
    /**
     * In case the Addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressesUpdateInput, AddressesUncheckedUpdateInput>
  }


  /**
   * Addresses delete
   */
  export type AddressesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    /**
     * Filter which Addresses to delete.
     */
    where: AddressesWhereUniqueInput
  }


  /**
   * Addresses deleteMany
   */
  export type AddressesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressesWhereInput
  }


  /**
   * Addresses.institute
   */
  export type Addresses$instituteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    where?: InstitutesWhereInput
  }


  /**
   * Addresses.provider
   */
  export type Addresses$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    where?: ProvidersWhereInput
  }


  /**
   * Addresses.Contacts
   */
  export type Addresses$ContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    cursor?: ContactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * Addresses.PlacementListings
   */
  export type Addresses$PlacementListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    where?: PlacementListingsWhereInput
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    cursor?: PlacementListingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementListingsScalarFieldEnum | PlacementListingsScalarFieldEnum[]
  }


  /**
   * Addresses.Placements
   */
  export type Addresses$PlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    where?: PlacementsWhereInput
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    cursor?: PlacementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Addresses.ProviderCohorts
   */
  export type Addresses$ProviderCohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    where?: ProviderCohortsWhereInput
    orderBy?: ProviderCohortsOrderByWithRelationInput | ProviderCohortsOrderByWithRelationInput[]
    cursor?: ProviderCohortsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderCohortsScalarFieldEnum | ProviderCohortsScalarFieldEnum[]
  }


  /**
   * Addresses without action
   */
  export type AddressesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
  }



  /**
   * Model Cohorts
   */

  export type AggregateCohorts = {
    _count: CohortsCountAggregateOutputType | null
    _min: CohortsMinAggregateOutputType | null
    _max: CohortsMaxAggregateOutputType | null
  }

  export type CohortsMinAggregateOutputType = {
    cohortId: string | null
    designatedStaff: string | null
    stage: string | null
    placementType: string | null
    name: string | null
    startPlacements: string | null
    endPlacements: string | null
    startSubmission: string | null
    endSubmission: string | null
    workflow: string | null
    instituteId: string | null
  }

  export type CohortsMaxAggregateOutputType = {
    cohortId: string | null
    designatedStaff: string | null
    stage: string | null
    placementType: string | null
    name: string | null
    startPlacements: string | null
    endPlacements: string | null
    startSubmission: string | null
    endSubmission: string | null
    workflow: string | null
    instituteId: string | null
  }

  export type CohortsCountAggregateOutputType = {
    cohortId: number
    designatedStaff: number
    stage: number
    placementType: number
    name: number
    startPlacements: number
    endPlacements: number
    startSubmission: number
    endSubmission: number
    includedFiles: number
    includedForms: number
    workflow: number
    instituteId: number
    _all: number
  }


  export type CohortsMinAggregateInputType = {
    cohortId?: true
    designatedStaff?: true
    stage?: true
    placementType?: true
    name?: true
    startPlacements?: true
    endPlacements?: true
    startSubmission?: true
    endSubmission?: true
    workflow?: true
    instituteId?: true
  }

  export type CohortsMaxAggregateInputType = {
    cohortId?: true
    designatedStaff?: true
    stage?: true
    placementType?: true
    name?: true
    startPlacements?: true
    endPlacements?: true
    startSubmission?: true
    endSubmission?: true
    workflow?: true
    instituteId?: true
  }

  export type CohortsCountAggregateInputType = {
    cohortId?: true
    designatedStaff?: true
    stage?: true
    placementType?: true
    name?: true
    startPlacements?: true
    endPlacements?: true
    startSubmission?: true
    endSubmission?: true
    includedFiles?: true
    includedForms?: true
    workflow?: true
    instituteId?: true
    _all?: true
  }

  export type CohortsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cohorts to aggregate.
     */
    where?: CohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cohorts
    **/
    _count?: true | CohortsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CohortsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CohortsMaxAggregateInputType
  }

  export type GetCohortsAggregateType<T extends CohortsAggregateArgs> = {
        [P in keyof T & keyof AggregateCohorts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCohorts[P]>
      : GetScalarType<T[P], AggregateCohorts[P]>
  }




  export type CohortsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CohortsWhereInput
    orderBy?: CohortsOrderByWithAggregationInput | CohortsOrderByWithAggregationInput[]
    by: CohortsScalarFieldEnum[] | CohortsScalarFieldEnum
    having?: CohortsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CohortsCountAggregateInputType | true
    _min?: CohortsMinAggregateInputType
    _max?: CohortsMaxAggregateInputType
  }

  export type CohortsGroupByOutputType = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles: string[]
    includedForms: string[]
    workflow: string
    instituteId: string
    _count: CohortsCountAggregateOutputType | null
    _min: CohortsMinAggregateOutputType | null
    _max: CohortsMaxAggregateOutputType | null
  }

  type GetCohortsGroupByPayload<T extends CohortsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CohortsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CohortsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CohortsGroupByOutputType[P]>
            : GetScalarType<T[P], CohortsGroupByOutputType[P]>
        }
      >
    >


  export type CohortsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cohortId?: boolean
    designatedStaff?: boolean
    stage?: boolean
    placementType?: boolean
    name?: boolean
    startPlacements?: boolean
    endPlacements?: boolean
    startSubmission?: boolean
    endSubmission?: boolean
    includedFiles?: boolean
    includedForms?: boolean
    workflow?: boolean
    instituteId?: boolean
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    InstituteStudents?: boolean | Cohorts$InstituteStudentsArgs<ExtArgs>
    _count?: boolean | CohortsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cohorts"]>

  export type CohortsSelectScalar = {
    cohortId?: boolean
    designatedStaff?: boolean
    stage?: boolean
    placementType?: boolean
    name?: boolean
    startPlacements?: boolean
    endPlacements?: boolean
    startSubmission?: boolean
    endSubmission?: boolean
    includedFiles?: boolean
    includedForms?: boolean
    workflow?: boolean
    instituteId?: boolean
  }

  export type CohortsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    InstituteStudents?: boolean | Cohorts$InstituteStudentsArgs<ExtArgs>
    _count?: boolean | CohortsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CohortsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cohorts"
    objects: {
      institute: Prisma.$InstitutesPayload<ExtArgs>
      InstituteStudents: Prisma.$InstituteStudentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cohortId: string
      designatedStaff: string
      stage: string
      placementType: string
      name: string
      startPlacements: string
      endPlacements: string
      startSubmission: string
      endSubmission: string
      includedFiles: string[]
      includedForms: string[]
      workflow: string
      instituteId: string
    }, ExtArgs["result"]["cohorts"]>
    composites: {}
  }


  type CohortsGetPayload<S extends boolean | null | undefined | CohortsDefaultArgs> = $Result.GetResult<Prisma.$CohortsPayload, S>

  type CohortsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CohortsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CohortsCountAggregateInputType | true
    }

  export interface CohortsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cohorts'], meta: { name: 'Cohorts' } }
    /**
     * Find zero or one Cohorts that matches the filter.
     * @param {CohortsFindUniqueArgs} args - Arguments to find a Cohorts
     * @example
     * // Get one Cohorts
     * const cohorts = await prisma.cohorts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CohortsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsFindUniqueArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cohorts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CohortsFindUniqueOrThrowArgs} args - Arguments to find a Cohorts
     * @example
     * // Get one Cohorts
     * const cohorts = await prisma.cohorts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CohortsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cohorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsFindFirstArgs} args - Arguments to find a Cohorts
     * @example
     * // Get one Cohorts
     * const cohorts = await prisma.cohorts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CohortsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsFindFirstArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cohorts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsFindFirstOrThrowArgs} args - Arguments to find a Cohorts
     * @example
     * // Get one Cohorts
     * const cohorts = await prisma.cohorts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CohortsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cohorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cohorts
     * const cohorts = await prisma.cohorts.findMany()
     * 
     * // Get first 10 Cohorts
     * const cohorts = await prisma.cohorts.findMany({ take: 10 })
     * 
     * // Only select the `cohortId`
     * const cohortsWithCohortIdOnly = await prisma.cohorts.findMany({ select: { cohortId: true } })
     * 
    **/
    findMany<T extends CohortsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cohorts.
     * @param {CohortsCreateArgs} args - Arguments to create a Cohorts.
     * @example
     * // Create one Cohorts
     * const Cohorts = await prisma.cohorts.create({
     *   data: {
     *     // ... data to create a Cohorts
     *   }
     * })
     * 
    **/
    create<T extends CohortsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsCreateArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cohorts.
     *     @param {CohortsCreateManyArgs} args - Arguments to create many Cohorts.
     *     @example
     *     // Create many Cohorts
     *     const cohorts = await prisma.cohorts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CohortsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cohorts.
     * @param {CohortsDeleteArgs} args - Arguments to delete one Cohorts.
     * @example
     * // Delete one Cohorts
     * const Cohorts = await prisma.cohorts.delete({
     *   where: {
     *     // ... filter to delete one Cohorts
     *   }
     * })
     * 
    **/
    delete<T extends CohortsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsDeleteArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cohorts.
     * @param {CohortsUpdateArgs} args - Arguments to update one Cohorts.
     * @example
     * // Update one Cohorts
     * const cohorts = await prisma.cohorts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CohortsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsUpdateArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cohorts.
     * @param {CohortsDeleteManyArgs} args - Arguments to filter Cohorts to delete.
     * @example
     * // Delete a few Cohorts
     * const { count } = await prisma.cohorts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CohortsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cohorts
     * const cohorts = await prisma.cohorts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CohortsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cohorts.
     * @param {CohortsUpsertArgs} args - Arguments to update or create a Cohorts.
     * @example
     * // Update or create a Cohorts
     * const cohorts = await prisma.cohorts.upsert({
     *   create: {
     *     // ... data to create a Cohorts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cohorts we want to update
     *   }
     * })
    **/
    upsert<T extends CohortsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsUpsertArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsCountArgs} args - Arguments to filter Cohorts to count.
     * @example
     * // Count the number of Cohorts
     * const count = await prisma.cohorts.count({
     *   where: {
     *     // ... the filter for the Cohorts we want to count
     *   }
     * })
    **/
    count<T extends CohortsCountArgs>(
      args?: Subset<T, CohortsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CohortsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CohortsAggregateArgs>(args: Subset<T, CohortsAggregateArgs>): Prisma.PrismaPromise<GetCohortsAggregateType<T>>

    /**
     * Group by Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CohortsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CohortsGroupByArgs['orderBy'] }
        : { orderBy?: CohortsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CohortsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCohortsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cohorts model
   */
  readonly fields: CohortsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cohorts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CohortsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    institute<T extends InstitutesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutesDefaultArgs<ExtArgs>>): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    InstituteStudents<T extends Cohorts$InstituteStudentsArgs<ExtArgs> = {}>(args?: Subset<T, Cohorts$InstituteStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Cohorts model
   */ 
  interface CohortsFieldRefs {
    readonly cohortId: FieldRef<"Cohorts", 'String'>
    readonly designatedStaff: FieldRef<"Cohorts", 'String'>
    readonly stage: FieldRef<"Cohorts", 'String'>
    readonly placementType: FieldRef<"Cohorts", 'String'>
    readonly name: FieldRef<"Cohorts", 'String'>
    readonly startPlacements: FieldRef<"Cohorts", 'String'>
    readonly endPlacements: FieldRef<"Cohorts", 'String'>
    readonly startSubmission: FieldRef<"Cohorts", 'String'>
    readonly endSubmission: FieldRef<"Cohorts", 'String'>
    readonly includedFiles: FieldRef<"Cohorts", 'String[]'>
    readonly includedForms: FieldRef<"Cohorts", 'String[]'>
    readonly workflow: FieldRef<"Cohorts", 'String'>
    readonly instituteId: FieldRef<"Cohorts", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Cohorts findUnique
   */
  export type CohortsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where: CohortsWhereUniqueInput
  }


  /**
   * Cohorts findUniqueOrThrow
   */
  export type CohortsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where: CohortsWhereUniqueInput
  }


  /**
   * Cohorts findFirst
   */
  export type CohortsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where?: CohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cohorts.
     */
    cursor?: CohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cohorts.
     */
    distinct?: CohortsScalarFieldEnum | CohortsScalarFieldEnum[]
  }


  /**
   * Cohorts findFirstOrThrow
   */
  export type CohortsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where?: CohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cohorts.
     */
    cursor?: CohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cohorts.
     */
    distinct?: CohortsScalarFieldEnum | CohortsScalarFieldEnum[]
  }


  /**
   * Cohorts findMany
   */
  export type CohortsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where?: CohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cohorts.
     */
    cursor?: CohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    distinct?: CohortsScalarFieldEnum | CohortsScalarFieldEnum[]
  }


  /**
   * Cohorts create
   */
  export type CohortsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * The data needed to create a Cohorts.
     */
    data: XOR<CohortsCreateInput, CohortsUncheckedCreateInput>
  }


  /**
   * Cohorts createMany
   */
  export type CohortsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cohorts.
     */
    data: CohortsCreateManyInput | CohortsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Cohorts update
   */
  export type CohortsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * The data needed to update a Cohorts.
     */
    data: XOR<CohortsUpdateInput, CohortsUncheckedUpdateInput>
    /**
     * Choose, which Cohorts to update.
     */
    where: CohortsWhereUniqueInput
  }


  /**
   * Cohorts updateMany
   */
  export type CohortsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cohorts.
     */
    data: XOR<CohortsUpdateManyMutationInput, CohortsUncheckedUpdateManyInput>
    /**
     * Filter which Cohorts to update
     */
    where?: CohortsWhereInput
  }


  /**
   * Cohorts upsert
   */
  export type CohortsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * The filter to search for the Cohorts to update in case it exists.
     */
    where: CohortsWhereUniqueInput
    /**
     * In case the Cohorts found by the `where` argument doesn't exist, create a new Cohorts with this data.
     */
    create: XOR<CohortsCreateInput, CohortsUncheckedCreateInput>
    /**
     * In case the Cohorts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CohortsUpdateInput, CohortsUncheckedUpdateInput>
  }


  /**
   * Cohorts delete
   */
  export type CohortsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    /**
     * Filter which Cohorts to delete.
     */
    where: CohortsWhereUniqueInput
  }


  /**
   * Cohorts deleteMany
   */
  export type CohortsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cohorts to delete
     */
    where?: CohortsWhereInput
  }


  /**
   * Cohorts.InstituteStudents
   */
  export type Cohorts$InstituteStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    where?: InstituteStudentsWhereInput
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    cursor?: InstituteStudentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * Cohorts without action
   */
  export type CohortsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
  }



  /**
   * Model ProviderCohorts
   */

  export type AggregateProviderCohorts = {
    _count: ProviderCohortsCountAggregateOutputType | null
    _min: ProviderCohortsMinAggregateOutputType | null
    _max: ProviderCohortsMaxAggregateOutputType | null
  }

  export type ProviderCohortsMinAggregateOutputType = {
    cohortId: string | null
    stage: string | null
    name: string | null
    addressId: string | null
    providerId: string | null
  }

  export type ProviderCohortsMaxAggregateOutputType = {
    cohortId: string | null
    stage: string | null
    name: string | null
    addressId: string | null
    providerId: string | null
  }

  export type ProviderCohortsCountAggregateOutputType = {
    cohortId: number
    stage: number
    name: number
    addressId: number
    providerId: number
    _all: number
  }


  export type ProviderCohortsMinAggregateInputType = {
    cohortId?: true
    stage?: true
    name?: true
    addressId?: true
    providerId?: true
  }

  export type ProviderCohortsMaxAggregateInputType = {
    cohortId?: true
    stage?: true
    name?: true
    addressId?: true
    providerId?: true
  }

  export type ProviderCohortsCountAggregateInputType = {
    cohortId?: true
    stage?: true
    name?: true
    addressId?: true
    providerId?: true
    _all?: true
  }

  export type ProviderCohortsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderCohorts to aggregate.
     */
    where?: ProviderCohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderCohorts to fetch.
     */
    orderBy?: ProviderCohortsOrderByWithRelationInput | ProviderCohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderCohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderCohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderCohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderCohorts
    **/
    _count?: true | ProviderCohortsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderCohortsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderCohortsMaxAggregateInputType
  }

  export type GetProviderCohortsAggregateType<T extends ProviderCohortsAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderCohorts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderCohorts[P]>
      : GetScalarType<T[P], AggregateProviderCohorts[P]>
  }




  export type ProviderCohortsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderCohortsWhereInput
    orderBy?: ProviderCohortsOrderByWithAggregationInput | ProviderCohortsOrderByWithAggregationInput[]
    by: ProviderCohortsScalarFieldEnum[] | ProviderCohortsScalarFieldEnum
    having?: ProviderCohortsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCohortsCountAggregateInputType | true
    _min?: ProviderCohortsMinAggregateInputType
    _max?: ProviderCohortsMaxAggregateInputType
  }

  export type ProviderCohortsGroupByOutputType = {
    cohortId: string
    stage: string
    name: string
    addressId: string
    providerId: string
    _count: ProviderCohortsCountAggregateOutputType | null
    _min: ProviderCohortsMinAggregateOutputType | null
    _max: ProviderCohortsMaxAggregateOutputType | null
  }

  type GetProviderCohortsGroupByPayload<T extends ProviderCohortsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderCohortsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderCohortsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderCohortsGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderCohortsGroupByOutputType[P]>
        }
      >
    >


  export type ProviderCohortsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cohortId?: boolean
    stage?: boolean
    name?: boolean
    addressId?: boolean
    providerId?: boolean
    address?: boolean | AddressesDefaultArgs<ExtArgs>
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerCohorts"]>

  export type ProviderCohortsSelectScalar = {
    cohortId?: boolean
    stage?: boolean
    name?: boolean
    addressId?: boolean
    providerId?: boolean
  }

  export type ProviderCohortsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressesDefaultArgs<ExtArgs>
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
  }


  export type $ProviderCohortsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderCohorts"
    objects: {
      address: Prisma.$AddressesPayload<ExtArgs>
      provider: Prisma.$ProvidersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cohortId: string
      stage: string
      name: string
      addressId: string
      providerId: string
    }, ExtArgs["result"]["providerCohorts"]>
    composites: {}
  }


  type ProviderCohortsGetPayload<S extends boolean | null | undefined | ProviderCohortsDefaultArgs> = $Result.GetResult<Prisma.$ProviderCohortsPayload, S>

  type ProviderCohortsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProviderCohortsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProviderCohortsCountAggregateInputType | true
    }

  export interface ProviderCohortsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderCohorts'], meta: { name: 'ProviderCohorts' } }
    /**
     * Find zero or one ProviderCohorts that matches the filter.
     * @param {ProviderCohortsFindUniqueArgs} args - Arguments to find a ProviderCohorts
     * @example
     * // Get one ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderCohortsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCohortsFindUniqueArgs<ExtArgs>>
    ): Prisma__ProviderCohortsClient<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProviderCohorts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProviderCohortsFindUniqueOrThrowArgs} args - Arguments to find a ProviderCohorts
     * @example
     * // Get one ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProviderCohortsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderCohortsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderCohortsClient<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProviderCohorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCohortsFindFirstArgs} args - Arguments to find a ProviderCohorts
     * @example
     * // Get one ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderCohortsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderCohortsFindFirstArgs<ExtArgs>>
    ): Prisma__ProviderCohortsClient<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProviderCohorts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCohortsFindFirstOrThrowArgs} args - Arguments to find a ProviderCohorts
     * @example
     * // Get one ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProviderCohortsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderCohortsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderCohortsClient<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProviderCohorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCohortsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.findMany()
     * 
     * // Get first 10 ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.findMany({ take: 10 })
     * 
     * // Only select the `cohortId`
     * const providerCohortsWithCohortIdOnly = await prisma.providerCohorts.findMany({ select: { cohortId: true } })
     * 
    **/
    findMany<T extends ProviderCohortsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderCohortsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProviderCohorts.
     * @param {ProviderCohortsCreateArgs} args - Arguments to create a ProviderCohorts.
     * @example
     * // Create one ProviderCohorts
     * const ProviderCohorts = await prisma.providerCohorts.create({
     *   data: {
     *     // ... data to create a ProviderCohorts
     *   }
     * })
     * 
    **/
    create<T extends ProviderCohortsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCohortsCreateArgs<ExtArgs>>
    ): Prisma__ProviderCohortsClient<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProviderCohorts.
     *     @param {ProviderCohortsCreateManyArgs} args - Arguments to create many ProviderCohorts.
     *     @example
     *     // Create many ProviderCohorts
     *     const providerCohorts = await prisma.providerCohorts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProviderCohortsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderCohortsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProviderCohorts.
     * @param {ProviderCohortsDeleteArgs} args - Arguments to delete one ProviderCohorts.
     * @example
     * // Delete one ProviderCohorts
     * const ProviderCohorts = await prisma.providerCohorts.delete({
     *   where: {
     *     // ... filter to delete one ProviderCohorts
     *   }
     * })
     * 
    **/
    delete<T extends ProviderCohortsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCohortsDeleteArgs<ExtArgs>>
    ): Prisma__ProviderCohortsClient<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProviderCohorts.
     * @param {ProviderCohortsUpdateArgs} args - Arguments to update one ProviderCohorts.
     * @example
     * // Update one ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderCohortsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCohortsUpdateArgs<ExtArgs>>
    ): Prisma__ProviderCohortsClient<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProviderCohorts.
     * @param {ProviderCohortsDeleteManyArgs} args - Arguments to filter ProviderCohorts to delete.
     * @example
     * // Delete a few ProviderCohorts
     * const { count } = await prisma.providerCohorts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderCohortsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderCohortsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderCohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCohortsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderCohortsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCohortsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProviderCohorts.
     * @param {ProviderCohortsUpsertArgs} args - Arguments to update or create a ProviderCohorts.
     * @example
     * // Update or create a ProviderCohorts
     * const providerCohorts = await prisma.providerCohorts.upsert({
     *   create: {
     *     // ... data to create a ProviderCohorts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderCohorts we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderCohortsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCohortsUpsertArgs<ExtArgs>>
    ): Prisma__ProviderCohortsClient<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProviderCohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCohortsCountArgs} args - Arguments to filter ProviderCohorts to count.
     * @example
     * // Count the number of ProviderCohorts
     * const count = await prisma.providerCohorts.count({
     *   where: {
     *     // ... the filter for the ProviderCohorts we want to count
     *   }
     * })
    **/
    count<T extends ProviderCohortsCountArgs>(
      args?: Subset<T, ProviderCohortsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCohortsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderCohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCohortsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderCohortsAggregateArgs>(args: Subset<T, ProviderCohortsAggregateArgs>): Prisma.PrismaPromise<GetProviderCohortsAggregateType<T>>

    /**
     * Group by ProviderCohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCohortsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderCohortsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderCohortsGroupByArgs['orderBy'] }
        : { orderBy?: ProviderCohortsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderCohortsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderCohortsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderCohorts model
   */
  readonly fields: ProviderCohortsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderCohorts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderCohortsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends AddressesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressesDefaultArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    provider<T extends ProvidersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvidersDefaultArgs<ExtArgs>>): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProviderCohorts model
   */ 
  interface ProviderCohortsFieldRefs {
    readonly cohortId: FieldRef<"ProviderCohorts", 'String'>
    readonly stage: FieldRef<"ProviderCohorts", 'String'>
    readonly name: FieldRef<"ProviderCohorts", 'String'>
    readonly addressId: FieldRef<"ProviderCohorts", 'String'>
    readonly providerId: FieldRef<"ProviderCohorts", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ProviderCohorts findUnique
   */
  export type ProviderCohortsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCohorts to fetch.
     */
    where: ProviderCohortsWhereUniqueInput
  }


  /**
   * ProviderCohorts findUniqueOrThrow
   */
  export type ProviderCohortsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCohorts to fetch.
     */
    where: ProviderCohortsWhereUniqueInput
  }


  /**
   * ProviderCohorts findFirst
   */
  export type ProviderCohortsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCohorts to fetch.
     */
    where?: ProviderCohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderCohorts to fetch.
     */
    orderBy?: ProviderCohortsOrderByWithRelationInput | ProviderCohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderCohorts.
     */
    cursor?: ProviderCohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderCohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderCohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderCohorts.
     */
    distinct?: ProviderCohortsScalarFieldEnum | ProviderCohortsScalarFieldEnum[]
  }


  /**
   * ProviderCohorts findFirstOrThrow
   */
  export type ProviderCohortsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCohorts to fetch.
     */
    where?: ProviderCohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderCohorts to fetch.
     */
    orderBy?: ProviderCohortsOrderByWithRelationInput | ProviderCohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderCohorts.
     */
    cursor?: ProviderCohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderCohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderCohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderCohorts.
     */
    distinct?: ProviderCohortsScalarFieldEnum | ProviderCohortsScalarFieldEnum[]
  }


  /**
   * ProviderCohorts findMany
   */
  export type ProviderCohortsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderCohorts to fetch.
     */
    where?: ProviderCohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderCohorts to fetch.
     */
    orderBy?: ProviderCohortsOrderByWithRelationInput | ProviderCohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderCohorts.
     */
    cursor?: ProviderCohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderCohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderCohorts.
     */
    skip?: number
    distinct?: ProviderCohortsScalarFieldEnum | ProviderCohortsScalarFieldEnum[]
  }


  /**
   * ProviderCohorts create
   */
  export type ProviderCohortsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderCohorts.
     */
    data: XOR<ProviderCohortsCreateInput, ProviderCohortsUncheckedCreateInput>
  }


  /**
   * ProviderCohorts createMany
   */
  export type ProviderCohortsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderCohorts.
     */
    data: ProviderCohortsCreateManyInput | ProviderCohortsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProviderCohorts update
   */
  export type ProviderCohortsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderCohorts.
     */
    data: XOR<ProviderCohortsUpdateInput, ProviderCohortsUncheckedUpdateInput>
    /**
     * Choose, which ProviderCohorts to update.
     */
    where: ProviderCohortsWhereUniqueInput
  }


  /**
   * ProviderCohorts updateMany
   */
  export type ProviderCohortsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderCohorts.
     */
    data: XOR<ProviderCohortsUpdateManyMutationInput, ProviderCohortsUncheckedUpdateManyInput>
    /**
     * Filter which ProviderCohorts to update
     */
    where?: ProviderCohortsWhereInput
  }


  /**
   * ProviderCohorts upsert
   */
  export type ProviderCohortsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderCohorts to update in case it exists.
     */
    where: ProviderCohortsWhereUniqueInput
    /**
     * In case the ProviderCohorts found by the `where` argument doesn't exist, create a new ProviderCohorts with this data.
     */
    create: XOR<ProviderCohortsCreateInput, ProviderCohortsUncheckedCreateInput>
    /**
     * In case the ProviderCohorts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderCohortsUpdateInput, ProviderCohortsUncheckedUpdateInput>
  }


  /**
   * ProviderCohorts delete
   */
  export type ProviderCohortsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    /**
     * Filter which ProviderCohorts to delete.
     */
    where: ProviderCohortsWhereUniqueInput
  }


  /**
   * ProviderCohorts deleteMany
   */
  export type ProviderCohortsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderCohorts to delete
     */
    where?: ProviderCohortsWhereInput
  }


  /**
   * ProviderCohorts without action
   */
  export type ProviderCohortsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
  }



  /**
   * Model Contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsMinAggregateOutputType = {
    contactId: string | null
    contactForename: string | null
    contactSurname: string | null
    created: string | null
    name: string | null
    providerPhone: string | null
    InstituteStudentUserId: string | null
    addressId: string | null
    studentUserId: string | null
  }

  export type ContactsMaxAggregateOutputType = {
    contactId: string | null
    contactForename: string | null
    contactSurname: string | null
    created: string | null
    name: string | null
    providerPhone: string | null
    InstituteStudentUserId: string | null
    addressId: string | null
    studentUserId: string | null
  }

  export type ContactsCountAggregateOutputType = {
    contactId: number
    contactForename: number
    contactSurname: number
    created: number
    name: number
    providerPhone: number
    InstituteStudentUserId: number
    addressId: number
    studentUserId: number
    _all: number
  }


  export type ContactsMinAggregateInputType = {
    contactId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    name?: true
    providerPhone?: true
    InstituteStudentUserId?: true
    addressId?: true
    studentUserId?: true
  }

  export type ContactsMaxAggregateInputType = {
    contactId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    name?: true
    providerPhone?: true
    InstituteStudentUserId?: true
    addressId?: true
    studentUserId?: true
  }

  export type ContactsCountAggregateInputType = {
    contactId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    name?: true
    providerPhone?: true
    InstituteStudentUserId?: true
    addressId?: true
    studentUserId?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to aggregate.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type ContactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithAggregationInput | ContactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: ContactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstituteStudentUserId: string
    addressId: string
    studentUserId: string
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends ContactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type ContactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    created?: boolean
    name?: boolean
    providerPhone?: boolean
    InstituteStudentUserId?: boolean
    addressId?: boolean
    studentUserId?: boolean
    InstitutestudentUser?: boolean | InstituteStudentsDefaultArgs<ExtArgs>
    address?: boolean | AddressesDefaultArgs<ExtArgs>
    studentUser?: boolean | StudentUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectScalar = {
    contactId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    created?: boolean
    name?: boolean
    providerPhone?: boolean
    InstituteStudentUserId?: boolean
    addressId?: boolean
    studentUserId?: boolean
  }

  export type ContactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InstitutestudentUser?: boolean | InstituteStudentsDefaultArgs<ExtArgs>
    address?: boolean | AddressesDefaultArgs<ExtArgs>
    studentUser?: boolean | StudentUsersDefaultArgs<ExtArgs>
  }


  export type $ContactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contacts"
    objects: {
      InstitutestudentUser: Prisma.$InstituteStudentsPayload<ExtArgs>
      address: Prisma.$AddressesPayload<ExtArgs>
      studentUser: Prisma.$StudentUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contactId: string
      contactForename: string
      contactSurname: string
      created: string
      name: string
      providerPhone: string
      InstituteStudentUserId: string
      addressId: string
      studentUserId: string
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }


  type ContactsGetPayload<S extends boolean | null | undefined | ContactsDefaultArgs> = $Result.GetResult<Prisma.$ContactsPayload, S>

  type ContactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface ContactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contacts'], meta: { name: 'Contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {ContactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contacts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsFindFirstArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `contactId`
     * const contactsWithContactIdOnly = await prisma.contacts.findMany({ select: { contactId: true } })
     * 
    **/
    findMany<T extends ContactsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contacts.
     * @param {ContactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
    **/
    create<T extends ContactsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsCreateArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contacts.
     *     @param {ContactsCreateManyArgs} args - Arguments to create many Contacts.
     *     @example
     *     // Create many Contacts
     *     const contacts = await prisma.contacts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contacts.
     * @param {ContactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
    **/
    delete<T extends ContactsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsDeleteArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contacts.
     * @param {ContactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsUpdateArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contacts.
     * @param {ContactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
    **/
    upsert<T extends ContactsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsUpsertArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactsCountArgs>(
      args?: Subset<T, ContactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactsGroupByArgs['orderBy'] }
        : { orderBy?: ContactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contacts model
   */
  readonly fields: ContactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    InstitutestudentUser<T extends InstituteStudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStudentsDefaultArgs<ExtArgs>>): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    address<T extends AddressesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressesDefaultArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    studentUser<T extends StudentUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentUsersDefaultArgs<ExtArgs>>): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Contacts model
   */ 
  interface ContactsFieldRefs {
    readonly contactId: FieldRef<"Contacts", 'String'>
    readonly contactForename: FieldRef<"Contacts", 'String'>
    readonly contactSurname: FieldRef<"Contacts", 'String'>
    readonly created: FieldRef<"Contacts", 'String'>
    readonly name: FieldRef<"Contacts", 'String'>
    readonly providerPhone: FieldRef<"Contacts", 'String'>
    readonly InstituteStudentUserId: FieldRef<"Contacts", 'String'>
    readonly addressId: FieldRef<"Contacts", 'String'>
    readonly studentUserId: FieldRef<"Contacts", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Contacts findUnique
   */
  export type ContactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }


  /**
   * Contacts findUniqueOrThrow
   */
  export type ContactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }


  /**
   * Contacts findFirst
   */
  export type ContactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * Contacts findFirstOrThrow
   */
  export type ContactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * Contacts findMany
   */
  export type ContactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * Contacts create
   */
  export type ContactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The data needed to create a Contacts.
     */
    data: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
  }


  /**
   * Contacts createMany
   */
  export type ContactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactsCreateManyInput | ContactsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Contacts update
   */
  export type ContactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The data needed to update a Contacts.
     */
    data: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
    /**
     * Choose, which Contacts to update.
     */
    where: ContactsWhereUniqueInput
  }


  /**
   * Contacts updateMany
   */
  export type ContactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactsWhereInput
  }


  /**
   * Contacts upsert
   */
  export type ContactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The filter to search for the Contacts to update in case it exists.
     */
    where: ContactsWhereUniqueInput
    /**
     * In case the Contacts found by the `where` argument doesn't exist, create a new Contacts with this data.
     */
    create: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
    /**
     * In case the Contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
  }


  /**
   * Contacts delete
   */
  export type ContactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter which Contacts to delete.
     */
    where: ContactsWhereUniqueInput
  }


  /**
   * Contacts deleteMany
   */
  export type ContactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactsWhereInput
  }


  /**
   * Contacts without action
   */
  export type ContactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
  }



  /**
   * Model InstituteForms
   */

  export type AggregateInstituteForms = {
    _count: InstituteFormsCountAggregateOutputType | null
    _min: InstituteFormsMinAggregateOutputType | null
    _max: InstituteFormsMaxAggregateOutputType | null
  }

  export type InstituteFormsMinAggregateOutputType = {
    formId: string | null
    updated: string | null
    instituteId: string | null
  }

  export type InstituteFormsMaxAggregateOutputType = {
    formId: string | null
    updated: string | null
    instituteId: string | null
  }

  export type InstituteFormsCountAggregateOutputType = {
    formId: number
    form: number
    updated: number
    instituteId: number
    _all: number
  }


  export type InstituteFormsMinAggregateInputType = {
    formId?: true
    updated?: true
    instituteId?: true
  }

  export type InstituteFormsMaxAggregateInputType = {
    formId?: true
    updated?: true
    instituteId?: true
  }

  export type InstituteFormsCountAggregateInputType = {
    formId?: true
    form?: true
    updated?: true
    instituteId?: true
    _all?: true
  }

  export type InstituteFormsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteForms to aggregate.
     */
    where?: InstituteFormsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteForms to fetch.
     */
    orderBy?: InstituteFormsOrderByWithRelationInput | InstituteFormsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteFormsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstituteForms
    **/
    _count?: true | InstituteFormsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteFormsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteFormsMaxAggregateInputType
  }

  export type GetInstituteFormsAggregateType<T extends InstituteFormsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstituteForms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstituteForms[P]>
      : GetScalarType<T[P], AggregateInstituteForms[P]>
  }




  export type InstituteFormsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteFormsWhereInput
    orderBy?: InstituteFormsOrderByWithAggregationInput | InstituteFormsOrderByWithAggregationInput[]
    by: InstituteFormsScalarFieldEnum[] | InstituteFormsScalarFieldEnum
    having?: InstituteFormsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteFormsCountAggregateInputType | true
    _min?: InstituteFormsMinAggregateInputType
    _max?: InstituteFormsMaxAggregateInputType
  }

  export type InstituteFormsGroupByOutputType = {
    formId: string
    form: JsonValue
    updated: string
    instituteId: string
    _count: InstituteFormsCountAggregateOutputType | null
    _min: InstituteFormsMinAggregateOutputType | null
    _max: InstituteFormsMaxAggregateOutputType | null
  }

  type GetInstituteFormsGroupByPayload<T extends InstituteFormsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteFormsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteFormsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteFormsGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteFormsGroupByOutputType[P]>
        }
      >
    >


  export type InstituteFormsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    formId?: boolean
    form?: boolean
    updated?: boolean
    instituteId?: boolean
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instituteForms"]>

  export type InstituteFormsSelectScalar = {
    formId?: boolean
    form?: boolean
    updated?: boolean
    instituteId?: boolean
  }

  export type InstituteFormsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
  }


  export type $InstituteFormsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstituteForms"
    objects: {
      institute: Prisma.$InstitutesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      formId: string
      form: Prisma.JsonValue
      updated: string
      instituteId: string
    }, ExtArgs["result"]["instituteForms"]>
    composites: {}
  }


  type InstituteFormsGetPayload<S extends boolean | null | undefined | InstituteFormsDefaultArgs> = $Result.GetResult<Prisma.$InstituteFormsPayload, S>

  type InstituteFormsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstituteFormsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstituteFormsCountAggregateInputType | true
    }

  export interface InstituteFormsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstituteForms'], meta: { name: 'InstituteForms' } }
    /**
     * Find zero or one InstituteForms that matches the filter.
     * @param {InstituteFormsFindUniqueArgs} args - Arguments to find a InstituteForms
     * @example
     * // Get one InstituteForms
     * const instituteForms = await prisma.instituteForms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstituteFormsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteFormsFindUniqueArgs<ExtArgs>>
    ): Prisma__InstituteFormsClient<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InstituteForms that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstituteFormsFindUniqueOrThrowArgs} args - Arguments to find a InstituteForms
     * @example
     * // Get one InstituteForms
     * const instituteForms = await prisma.instituteForms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstituteFormsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteFormsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteFormsClient<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InstituteForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFormsFindFirstArgs} args - Arguments to find a InstituteForms
     * @example
     * // Get one InstituteForms
     * const instituteForms = await prisma.instituteForms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstituteFormsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteFormsFindFirstArgs<ExtArgs>>
    ): Prisma__InstituteFormsClient<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InstituteForms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFormsFindFirstOrThrowArgs} args - Arguments to find a InstituteForms
     * @example
     * // Get one InstituteForms
     * const instituteForms = await prisma.instituteForms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstituteFormsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteFormsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteFormsClient<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InstituteForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFormsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstituteForms
     * const instituteForms = await prisma.instituteForms.findMany()
     * 
     * // Get first 10 InstituteForms
     * const instituteForms = await prisma.instituteForms.findMany({ take: 10 })
     * 
     * // Only select the `formId`
     * const instituteFormsWithFormIdOnly = await prisma.instituteForms.findMany({ select: { formId: true } })
     * 
    **/
    findMany<T extends InstituteFormsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteFormsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InstituteForms.
     * @param {InstituteFormsCreateArgs} args - Arguments to create a InstituteForms.
     * @example
     * // Create one InstituteForms
     * const InstituteForms = await prisma.instituteForms.create({
     *   data: {
     *     // ... data to create a InstituteForms
     *   }
     * })
     * 
    **/
    create<T extends InstituteFormsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteFormsCreateArgs<ExtArgs>>
    ): Prisma__InstituteFormsClient<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InstituteForms.
     *     @param {InstituteFormsCreateManyArgs} args - Arguments to create many InstituteForms.
     *     @example
     *     // Create many InstituteForms
     *     const instituteForms = await prisma.instituteForms.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstituteFormsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteFormsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InstituteForms.
     * @param {InstituteFormsDeleteArgs} args - Arguments to delete one InstituteForms.
     * @example
     * // Delete one InstituteForms
     * const InstituteForms = await prisma.instituteForms.delete({
     *   where: {
     *     // ... filter to delete one InstituteForms
     *   }
     * })
     * 
    **/
    delete<T extends InstituteFormsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteFormsDeleteArgs<ExtArgs>>
    ): Prisma__InstituteFormsClient<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InstituteForms.
     * @param {InstituteFormsUpdateArgs} args - Arguments to update one InstituteForms.
     * @example
     * // Update one InstituteForms
     * const instituteForms = await prisma.instituteForms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstituteFormsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteFormsUpdateArgs<ExtArgs>>
    ): Prisma__InstituteFormsClient<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InstituteForms.
     * @param {InstituteFormsDeleteManyArgs} args - Arguments to filter InstituteForms to delete.
     * @example
     * // Delete a few InstituteForms
     * const { count } = await prisma.instituteForms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstituteFormsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteFormsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstituteForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFormsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstituteForms
     * const instituteForms = await prisma.instituteForms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstituteFormsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteFormsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstituteForms.
     * @param {InstituteFormsUpsertArgs} args - Arguments to update or create a InstituteForms.
     * @example
     * // Update or create a InstituteForms
     * const instituteForms = await prisma.instituteForms.upsert({
     *   create: {
     *     // ... data to create a InstituteForms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstituteForms we want to update
     *   }
     * })
    **/
    upsert<T extends InstituteFormsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteFormsUpsertArgs<ExtArgs>>
    ): Prisma__InstituteFormsClient<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InstituteForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFormsCountArgs} args - Arguments to filter InstituteForms to count.
     * @example
     * // Count the number of InstituteForms
     * const count = await prisma.instituteForms.count({
     *   where: {
     *     // ... the filter for the InstituteForms we want to count
     *   }
     * })
    **/
    count<T extends InstituteFormsCountArgs>(
      args?: Subset<T, InstituteFormsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteFormsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstituteForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFormsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteFormsAggregateArgs>(args: Subset<T, InstituteFormsAggregateArgs>): Prisma.PrismaPromise<GetInstituteFormsAggregateType<T>>

    /**
     * Group by InstituteForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFormsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteFormsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteFormsGroupByArgs['orderBy'] }
        : { orderBy?: InstituteFormsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteFormsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteFormsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstituteForms model
   */
  readonly fields: InstituteFormsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstituteForms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteFormsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    institute<T extends InstitutesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutesDefaultArgs<ExtArgs>>): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InstituteForms model
   */ 
  interface InstituteFormsFieldRefs {
    readonly formId: FieldRef<"InstituteForms", 'String'>
    readonly form: FieldRef<"InstituteForms", 'Json'>
    readonly updated: FieldRef<"InstituteForms", 'String'>
    readonly instituteId: FieldRef<"InstituteForms", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InstituteForms findUnique
   */
  export type InstituteFormsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteForms to fetch.
     */
    where: InstituteFormsWhereUniqueInput
  }


  /**
   * InstituteForms findUniqueOrThrow
   */
  export type InstituteFormsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteForms to fetch.
     */
    where: InstituteFormsWhereUniqueInput
  }


  /**
   * InstituteForms findFirst
   */
  export type InstituteFormsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteForms to fetch.
     */
    where?: InstituteFormsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteForms to fetch.
     */
    orderBy?: InstituteFormsOrderByWithRelationInput | InstituteFormsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteForms.
     */
    cursor?: InstituteFormsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteForms.
     */
    distinct?: InstituteFormsScalarFieldEnum | InstituteFormsScalarFieldEnum[]
  }


  /**
   * InstituteForms findFirstOrThrow
   */
  export type InstituteFormsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteForms to fetch.
     */
    where?: InstituteFormsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteForms to fetch.
     */
    orderBy?: InstituteFormsOrderByWithRelationInput | InstituteFormsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteForms.
     */
    cursor?: InstituteFormsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteForms.
     */
    distinct?: InstituteFormsScalarFieldEnum | InstituteFormsScalarFieldEnum[]
  }


  /**
   * InstituteForms findMany
   */
  export type InstituteFormsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteForms to fetch.
     */
    where?: InstituteFormsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteForms to fetch.
     */
    orderBy?: InstituteFormsOrderByWithRelationInput | InstituteFormsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstituteForms.
     */
    cursor?: InstituteFormsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteForms.
     */
    skip?: number
    distinct?: InstituteFormsScalarFieldEnum | InstituteFormsScalarFieldEnum[]
  }


  /**
   * InstituteForms create
   */
  export type InstituteFormsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * The data needed to create a InstituteForms.
     */
    data: XOR<InstituteFormsCreateInput, InstituteFormsUncheckedCreateInput>
  }


  /**
   * InstituteForms createMany
   */
  export type InstituteFormsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstituteForms.
     */
    data: InstituteFormsCreateManyInput | InstituteFormsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InstituteForms update
   */
  export type InstituteFormsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * The data needed to update a InstituteForms.
     */
    data: XOR<InstituteFormsUpdateInput, InstituteFormsUncheckedUpdateInput>
    /**
     * Choose, which InstituteForms to update.
     */
    where: InstituteFormsWhereUniqueInput
  }


  /**
   * InstituteForms updateMany
   */
  export type InstituteFormsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstituteForms.
     */
    data: XOR<InstituteFormsUpdateManyMutationInput, InstituteFormsUncheckedUpdateManyInput>
    /**
     * Filter which InstituteForms to update
     */
    where?: InstituteFormsWhereInput
  }


  /**
   * InstituteForms upsert
   */
  export type InstituteFormsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * The filter to search for the InstituteForms to update in case it exists.
     */
    where: InstituteFormsWhereUniqueInput
    /**
     * In case the InstituteForms found by the `where` argument doesn't exist, create a new InstituteForms with this data.
     */
    create: XOR<InstituteFormsCreateInput, InstituteFormsUncheckedCreateInput>
    /**
     * In case the InstituteForms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteFormsUpdateInput, InstituteFormsUncheckedUpdateInput>
  }


  /**
   * InstituteForms delete
   */
  export type InstituteFormsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    /**
     * Filter which InstituteForms to delete.
     */
    where: InstituteFormsWhereUniqueInput
  }


  /**
   * InstituteForms deleteMany
   */
  export type InstituteFormsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteForms to delete
     */
    where?: InstituteFormsWhereInput
  }


  /**
   * InstituteForms without action
   */
  export type InstituteFormsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
  }



  /**
   * Model Institutes
   */

  export type AggregateInstitutes = {
    _count: InstitutesCountAggregateOutputType | null
    _avg: InstitutesAvgAggregateOutputType | null
    _sum: InstitutesSumAggregateOutputType | null
    _min: InstitutesMinAggregateOutputType | null
    _max: InstitutesMaxAggregateOutputType | null
  }

  export type InstitutesAvgAggregateOutputType = {
    staff: number | null
    staffActive: number | null
    students: number | null
    studentsActive: number | null
  }

  export type InstitutesSumAggregateOutputType = {
    staff: number | null
    staffActive: number | null
    students: number | null
    studentsActive: number | null
  }

  export type InstitutesMinAggregateOutputType = {
    instituteId: string | null
    admin: string | null
    externalProviderUploads: boolean | null
    name: string | null
    referral: string | null
    status: string | null
    staff: number | null
    staffActive: number | null
    students: number | null
    studentsActive: number | null
  }

  export type InstitutesMaxAggregateOutputType = {
    instituteId: string | null
    admin: string | null
    externalProviderUploads: boolean | null
    name: string | null
    referral: string | null
    status: string | null
    staff: number | null
    staffActive: number | null
    students: number | null
    studentsActive: number | null
  }

  export type InstitutesCountAggregateOutputType = {
    instituteId: number
    admin: number
    externalProviderUploads: number
    name: number
    referral: number
    status: number
    studentsFields: number
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields: number
    staffGuidance: number
    studentsGuidance: number
    verifiedProviders: number
    _all: number
  }


  export type InstitutesAvgAggregateInputType = {
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
  }

  export type InstitutesSumAggregateInputType = {
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
  }

  export type InstitutesMinAggregateInputType = {
    instituteId?: true
    admin?: true
    externalProviderUploads?: true
    name?: true
    referral?: true
    status?: true
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
  }

  export type InstitutesMaxAggregateInputType = {
    instituteId?: true
    admin?: true
    externalProviderUploads?: true
    name?: true
    referral?: true
    status?: true
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
  }

  export type InstitutesCountAggregateInputType = {
    instituteId?: true
    admin?: true
    externalProviderUploads?: true
    name?: true
    referral?: true
    status?: true
    studentsFields?: true
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
    staffFields?: true
    staffGuidance?: true
    studentsGuidance?: true
    verifiedProviders?: true
    _all?: true
  }

  export type InstitutesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutes to aggregate.
     */
    where?: InstitutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstitutesOrderByWithRelationInput | InstitutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutes
    **/
    _count?: true | InstitutesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstitutesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstitutesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutesMaxAggregateInputType
  }

  export type GetInstitutesAggregateType<T extends InstitutesAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitutes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitutes[P]>
      : GetScalarType<T[P], AggregateInstitutes[P]>
  }




  export type InstitutesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutesWhereInput
    orderBy?: InstitutesOrderByWithAggregationInput | InstitutesOrderByWithAggregationInput[]
    by: InstitutesScalarFieldEnum[] | InstitutesScalarFieldEnum
    having?: InstitutesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutesCountAggregateInputType | true
    _avg?: InstitutesAvgAggregateInputType
    _sum?: InstitutesSumAggregateInputType
    _min?: InstitutesMinAggregateInputType
    _max?: InstitutesMaxAggregateInputType
  }

  export type InstitutesGroupByOutputType = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral: string | null
    status: string
    studentsFields: string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields: string[]
    staffGuidance: JsonValue
    studentsGuidance: JsonValue
    verifiedProviders: string[]
    _count: InstitutesCountAggregateOutputType | null
    _avg: InstitutesAvgAggregateOutputType | null
    _sum: InstitutesSumAggregateOutputType | null
    _min: InstitutesMinAggregateOutputType | null
    _max: InstitutesMaxAggregateOutputType | null
  }

  type GetInstitutesGroupByPayload<T extends InstitutesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutesGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutesGroupByOutputType[P]>
        }
      >
    >


  export type InstitutesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instituteId?: boolean
    admin?: boolean
    externalProviderUploads?: boolean
    name?: boolean
    referral?: boolean
    status?: boolean
    studentsFields?: boolean
    staff?: boolean
    staffActive?: boolean
    students?: boolean
    studentsActive?: boolean
    staffFields?: boolean
    staffGuidance?: boolean
    studentsGuidance?: boolean
    verifiedProviders?: boolean
    Addresses?: boolean | Institutes$AddressesArgs<ExtArgs>
    Cohorts?: boolean | Institutes$CohortsArgs<ExtArgs>
    Forms?: boolean | Institutes$FormsArgs<ExtArgs>
    InstituteStaff?: boolean | Institutes$InstituteStaffArgs<ExtArgs>
    StaffUserGroups?: boolean | Institutes$StaffUserGroupsArgs<ExtArgs>
    StudentUserGroups?: boolean | Institutes$StudentUserGroupsArgs<ExtArgs>
    InstituteStudents?: boolean | Institutes$InstituteStudentsArgs<ExtArgs>
    Placements?: boolean | Institutes$PlacementsArgs<ExtArgs>
    _count?: boolean | InstitutesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institutes"]>

  export type InstitutesSelectScalar = {
    instituteId?: boolean
    admin?: boolean
    externalProviderUploads?: boolean
    name?: boolean
    referral?: boolean
    status?: boolean
    studentsFields?: boolean
    staff?: boolean
    staffActive?: boolean
    students?: boolean
    studentsActive?: boolean
    staffFields?: boolean
    staffGuidance?: boolean
    studentsGuidance?: boolean
    verifiedProviders?: boolean
  }

  export type InstitutesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Addresses?: boolean | Institutes$AddressesArgs<ExtArgs>
    Cohorts?: boolean | Institutes$CohortsArgs<ExtArgs>
    Forms?: boolean | Institutes$FormsArgs<ExtArgs>
    InstituteStaff?: boolean | Institutes$InstituteStaffArgs<ExtArgs>
    StaffUserGroups?: boolean | Institutes$StaffUserGroupsArgs<ExtArgs>
    StudentUserGroups?: boolean | Institutes$StudentUserGroupsArgs<ExtArgs>
    InstituteStudents?: boolean | Institutes$InstituteStudentsArgs<ExtArgs>
    Placements?: boolean | Institutes$PlacementsArgs<ExtArgs>
    _count?: boolean | InstitutesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InstitutesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institutes"
    objects: {
      Addresses: Prisma.$AddressesPayload<ExtArgs>[]
      Cohorts: Prisma.$CohortsPayload<ExtArgs>[]
      Forms: Prisma.$InstituteFormsPayload<ExtArgs>[]
      InstituteStaff: Prisma.$InstituteStaffPayload<ExtArgs>[]
      StaffUserGroups: Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>[]
      StudentUserGroups: Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>[]
      InstituteStudents: Prisma.$InstituteStudentsPayload<ExtArgs>[]
      Placements: Prisma.$PlacementsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      instituteId: string
      admin: string
      externalProviderUploads: boolean
      name: string
      referral: string | null
      status: string
      studentsFields: string[]
      staff: number
      staffActive: number
      students: number
      studentsActive: number
      staffFields: string[]
      staffGuidance: Prisma.JsonValue
      studentsGuidance: Prisma.JsonValue
      verifiedProviders: string[]
    }, ExtArgs["result"]["institutes"]>
    composites: {}
  }


  type InstitutesGetPayload<S extends boolean | null | undefined | InstitutesDefaultArgs> = $Result.GetResult<Prisma.$InstitutesPayload, S>

  type InstitutesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstitutesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstitutesCountAggregateInputType | true
    }

  export interface InstitutesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institutes'], meta: { name: 'Institutes' } }
    /**
     * Find zero or one Institutes that matches the filter.
     * @param {InstitutesFindUniqueArgs} args - Arguments to find a Institutes
     * @example
     * // Get one Institutes
     * const institutes = await prisma.institutes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstitutesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesFindUniqueArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Institutes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstitutesFindUniqueOrThrowArgs} args - Arguments to find a Institutes
     * @example
     * // Get one Institutes
     * const institutes = await prisma.institutes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstitutesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Institutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesFindFirstArgs} args - Arguments to find a Institutes
     * @example
     * // Get one Institutes
     * const institutes = await prisma.institutes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstitutesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesFindFirstArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Institutes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesFindFirstOrThrowArgs} args - Arguments to find a Institutes
     * @example
     * // Get one Institutes
     * const institutes = await prisma.institutes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstitutesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Institutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutes
     * const institutes = await prisma.institutes.findMany()
     * 
     * // Get first 10 Institutes
     * const institutes = await prisma.institutes.findMany({ take: 10 })
     * 
     * // Only select the `instituteId`
     * const institutesWithInstituteIdOnly = await prisma.institutes.findMany({ select: { instituteId: true } })
     * 
    **/
    findMany<T extends InstitutesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Institutes.
     * @param {InstitutesCreateArgs} args - Arguments to create a Institutes.
     * @example
     * // Create one Institutes
     * const Institutes = await prisma.institutes.create({
     *   data: {
     *     // ... data to create a Institutes
     *   }
     * })
     * 
    **/
    create<T extends InstitutesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesCreateArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Institutes.
     *     @param {InstitutesCreateManyArgs} args - Arguments to create many Institutes.
     *     @example
     *     // Create many Institutes
     *     const institutes = await prisma.institutes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstitutesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Institutes.
     * @param {InstitutesDeleteArgs} args - Arguments to delete one Institutes.
     * @example
     * // Delete one Institutes
     * const Institutes = await prisma.institutes.delete({
     *   where: {
     *     // ... filter to delete one Institutes
     *   }
     * })
     * 
    **/
    delete<T extends InstitutesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesDeleteArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Institutes.
     * @param {InstitutesUpdateArgs} args - Arguments to update one Institutes.
     * @example
     * // Update one Institutes
     * const institutes = await prisma.institutes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstitutesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesUpdateArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Institutes.
     * @param {InstitutesDeleteManyArgs} args - Arguments to filter Institutes to delete.
     * @example
     * // Delete a few Institutes
     * const { count } = await prisma.institutes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstitutesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutes
     * const institutes = await prisma.institutes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstitutesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institutes.
     * @param {InstitutesUpsertArgs} args - Arguments to update or create a Institutes.
     * @example
     * // Update or create a Institutes
     * const institutes = await prisma.institutes.upsert({
     *   create: {
     *     // ... data to create a Institutes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institutes we want to update
     *   }
     * })
    **/
    upsert<T extends InstitutesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesUpsertArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesCountArgs} args - Arguments to filter Institutes to count.
     * @example
     * // Count the number of Institutes
     * const count = await prisma.institutes.count({
     *   where: {
     *     // ... the filter for the Institutes we want to count
     *   }
     * })
    **/
    count<T extends InstitutesCountArgs>(
      args?: Subset<T, InstitutesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutesAggregateArgs>(args: Subset<T, InstitutesAggregateArgs>): Prisma.PrismaPromise<GetInstitutesAggregateType<T>>

    /**
     * Group by Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutesGroupByArgs['orderBy'] }
        : { orderBy?: InstitutesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institutes model
   */
  readonly fields: InstitutesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institutes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Addresses<T extends Institutes$AddressesArgs<ExtArgs> = {}>(args?: Subset<T, Institutes$AddressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Cohorts<T extends Institutes$CohortsArgs<ExtArgs> = {}>(args?: Subset<T, Institutes$CohortsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Forms<T extends Institutes$FormsArgs<ExtArgs> = {}>(args?: Subset<T, Institutes$FormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteFormsPayload<ExtArgs>, T, 'findMany'> | Null>;

    InstituteStaff<T extends Institutes$InstituteStaffArgs<ExtArgs> = {}>(args?: Subset<T, Institutes$InstituteStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findMany'> | Null>;

    StaffUserGroups<T extends Institutes$StaffUserGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Institutes$StaffUserGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'findMany'> | Null>;

    StudentUserGroups<T extends Institutes$StudentUserGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Institutes$StudentUserGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'findMany'> | Null>;

    InstituteStudents<T extends Institutes$InstituteStudentsArgs<ExtArgs> = {}>(args?: Subset<T, Institutes$InstituteStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Placements<T extends Institutes$PlacementsArgs<ExtArgs> = {}>(args?: Subset<T, Institutes$PlacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Institutes model
   */ 
  interface InstitutesFieldRefs {
    readonly instituteId: FieldRef<"Institutes", 'String'>
    readonly admin: FieldRef<"Institutes", 'String'>
    readonly externalProviderUploads: FieldRef<"Institutes", 'Boolean'>
    readonly name: FieldRef<"Institutes", 'String'>
    readonly referral: FieldRef<"Institutes", 'String'>
    readonly status: FieldRef<"Institutes", 'String'>
    readonly studentsFields: FieldRef<"Institutes", 'String[]'>
    readonly staff: FieldRef<"Institutes", 'Int'>
    readonly staffActive: FieldRef<"Institutes", 'Int'>
    readonly students: FieldRef<"Institutes", 'Int'>
    readonly studentsActive: FieldRef<"Institutes", 'Int'>
    readonly staffFields: FieldRef<"Institutes", 'String[]'>
    readonly staffGuidance: FieldRef<"Institutes", 'Json'>
    readonly studentsGuidance: FieldRef<"Institutes", 'Json'>
    readonly verifiedProviders: FieldRef<"Institutes", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * Institutes findUnique
   */
  export type InstitutesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where: InstitutesWhereUniqueInput
  }


  /**
   * Institutes findUniqueOrThrow
   */
  export type InstitutesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where: InstitutesWhereUniqueInput
  }


  /**
   * Institutes findFirst
   */
  export type InstitutesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where?: InstitutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstitutesOrderByWithRelationInput | InstitutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutes.
     */
    cursor?: InstitutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutes.
     */
    distinct?: InstitutesScalarFieldEnum | InstitutesScalarFieldEnum[]
  }


  /**
   * Institutes findFirstOrThrow
   */
  export type InstitutesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where?: InstitutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstitutesOrderByWithRelationInput | InstitutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutes.
     */
    cursor?: InstitutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutes.
     */
    distinct?: InstitutesScalarFieldEnum | InstitutesScalarFieldEnum[]
  }


  /**
   * Institutes findMany
   */
  export type InstitutesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where?: InstitutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstitutesOrderByWithRelationInput | InstitutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutes.
     */
    cursor?: InstitutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    distinct?: InstitutesScalarFieldEnum | InstitutesScalarFieldEnum[]
  }


  /**
   * Institutes create
   */
  export type InstitutesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * The data needed to create a Institutes.
     */
    data: XOR<InstitutesCreateInput, InstitutesUncheckedCreateInput>
  }


  /**
   * Institutes createMany
   */
  export type InstitutesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutes.
     */
    data: InstitutesCreateManyInput | InstitutesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Institutes update
   */
  export type InstitutesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * The data needed to update a Institutes.
     */
    data: XOR<InstitutesUpdateInput, InstitutesUncheckedUpdateInput>
    /**
     * Choose, which Institutes to update.
     */
    where: InstitutesWhereUniqueInput
  }


  /**
   * Institutes updateMany
   */
  export type InstitutesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutes.
     */
    data: XOR<InstitutesUpdateManyMutationInput, InstitutesUncheckedUpdateManyInput>
    /**
     * Filter which Institutes to update
     */
    where?: InstitutesWhereInput
  }


  /**
   * Institutes upsert
   */
  export type InstitutesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * The filter to search for the Institutes to update in case it exists.
     */
    where: InstitutesWhereUniqueInput
    /**
     * In case the Institutes found by the `where` argument doesn't exist, create a new Institutes with this data.
     */
    create: XOR<InstitutesCreateInput, InstitutesUncheckedCreateInput>
    /**
     * In case the Institutes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutesUpdateInput, InstitutesUncheckedUpdateInput>
  }


  /**
   * Institutes delete
   */
  export type InstitutesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
    /**
     * Filter which Institutes to delete.
     */
    where: InstitutesWhereUniqueInput
  }


  /**
   * Institutes deleteMany
   */
  export type InstitutesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutes to delete
     */
    where?: InstitutesWhereInput
  }


  /**
   * Institutes.Addresses
   */
  export type Institutes$AddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    where?: AddressesWhereInput
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    cursor?: AddressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }


  /**
   * Institutes.Cohorts
   */
  export type Institutes$CohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CohortsInclude<ExtArgs> | null
    where?: CohortsWhereInput
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    cursor?: CohortsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CohortsScalarFieldEnum | CohortsScalarFieldEnum[]
  }


  /**
   * Institutes.Forms
   */
  export type Institutes$FormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteForms
     */
    select?: InstituteFormsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteFormsInclude<ExtArgs> | null
    where?: InstituteFormsWhereInput
    orderBy?: InstituteFormsOrderByWithRelationInput | InstituteFormsOrderByWithRelationInput[]
    cursor?: InstituteFormsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteFormsScalarFieldEnum | InstituteFormsScalarFieldEnum[]
  }


  /**
   * Institutes.InstituteStaff
   */
  export type Institutes$InstituteStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    where?: InstituteStaffWhereInput
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    cursor?: InstituteStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteStaffScalarFieldEnum | InstituteStaffScalarFieldEnum[]
  }


  /**
   * Institutes.StaffUserGroups
   */
  export type Institutes$StaffUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    where?: InstituteStaffUserGroupsWhereInput
    orderBy?: InstituteStaffUserGroupsOrderByWithRelationInput | InstituteStaffUserGroupsOrderByWithRelationInput[]
    cursor?: InstituteStaffUserGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteStaffUserGroupsScalarFieldEnum | InstituteStaffUserGroupsScalarFieldEnum[]
  }


  /**
   * Institutes.StudentUserGroups
   */
  export type Institutes$StudentUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    where?: InstituteStudentUserGroupsWhereInput
    orderBy?: InstituteStudentUserGroupsOrderByWithRelationInput | InstituteStudentUserGroupsOrderByWithRelationInput[]
    cursor?: InstituteStudentUserGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteStudentUserGroupsScalarFieldEnum | InstituteStudentUserGroupsScalarFieldEnum[]
  }


  /**
   * Institutes.InstituteStudents
   */
  export type Institutes$InstituteStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    where?: InstituteStudentsWhereInput
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    cursor?: InstituteStudentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * Institutes.Placements
   */
  export type Institutes$PlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    where?: PlacementsWhereInput
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    cursor?: PlacementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Institutes without action
   */
  export type InstitutesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstitutesInclude<ExtArgs> | null
  }



  /**
   * Model Logs
   */

  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsMinAggregateOutputType = {
    logId: string | null
    uid: string | null
    placementId: string | null
  }

  export type LogsMaxAggregateOutputType = {
    logId: string | null
    uid: string | null
    placementId: string | null
  }

  export type LogsCountAggregateOutputType = {
    logId: number
    provider: number
    students: number
    staff: number
    uid: number
    placementId: number
    _all: number
  }


  export type LogsMinAggregateInputType = {
    logId?: true
    uid?: true
    placementId?: true
  }

  export type LogsMaxAggregateInputType = {
    logId?: true
    uid?: true
    placementId?: true
  }

  export type LogsCountAggregateInputType = {
    logId?: true
    provider?: true
    students?: true
    staff?: true
    uid?: true
    placementId?: true
    _all?: true
  }

  export type LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to aggregate.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type LogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithAggregationInput | LogsOrderByWithAggregationInput[]
    by: LogsScalarFieldEnum[] | LogsScalarFieldEnum
    having?: LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }

  export type LogsGroupByOutputType = {
    logId: string
    provider: JsonValue
    students: JsonValue
    staff: JsonValue
    uid: string
    placementId: string
    _count: LogsCountAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends LogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type LogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    logId?: boolean
    provider?: boolean
    students?: boolean
    staff?: boolean
    uid?: boolean
    placementId?: boolean
    placement?: boolean | PlacementsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logs"]>

  export type LogsSelectScalar = {
    logId?: boolean
    provider?: boolean
    students?: boolean
    staff?: boolean
    uid?: boolean
    placementId?: boolean
  }

  export type LogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    placement?: boolean | PlacementsDefaultArgs<ExtArgs>
  }


  export type $LogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logs"
    objects: {
      placement: Prisma.$PlacementsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      logId: string
      provider: Prisma.JsonValue
      students: Prisma.JsonValue
      staff: Prisma.JsonValue
      uid: string
      placementId: string
    }, ExtArgs["result"]["logs"]>
    composites: {}
  }


  type LogsGetPayload<S extends boolean | null | undefined | LogsDefaultArgs> = $Result.GetResult<Prisma.$LogsPayload, S>

  type LogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogsCountAggregateInputType | true
    }

  export interface LogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logs'], meta: { name: 'Logs' } }
    /**
     * Find zero or one Logs that matches the filter.
     * @param {LogsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogsFindUniqueArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindFirstArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `logId`
     * const logsWithLogIdOnly = await prisma.logs.findMany({ select: { logId: true } })
     * 
    **/
    findMany<T extends LogsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Logs.
     * @param {LogsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
    **/
    create<T extends LogsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogsCreateArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Logs.
     *     @param {LogsCreateManyArgs} args - Arguments to create many Logs.
     *     @example
     *     // Create many Logs
     *     const logs = await prisma.logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logs.
     * @param {LogsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
    **/
    delete<T extends LogsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogsDeleteArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Logs.
     * @param {LogsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpdateArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs.
     * @param {LogsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
    **/
    upsert<T extends LogsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpsertArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogsCountArgs>(
      args?: Subset<T, LogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): Prisma.PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsGroupByArgs['orderBy'] }
        : { orderBy?: LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logs model
   */
  readonly fields: LogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    placement<T extends PlacementsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlacementsDefaultArgs<ExtArgs>>): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Logs model
   */ 
  interface LogsFieldRefs {
    readonly logId: FieldRef<"Logs", 'String'>
    readonly provider: FieldRef<"Logs", 'Json'>
    readonly students: FieldRef<"Logs", 'Json'>
    readonly staff: FieldRef<"Logs", 'Json'>
    readonly uid: FieldRef<"Logs", 'String'>
    readonly placementId: FieldRef<"Logs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Logs findUnique
   */
  export type LogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs findUniqueOrThrow
   */
  export type LogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs findFirst
   */
  export type LogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs findFirstOrThrow
   */
  export type LogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs findMany
   */
  export type LogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs create
   */
  export type LogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to create a Logs.
     */
    data: XOR<LogsCreateInput, LogsUncheckedCreateInput>
  }


  /**
   * Logs createMany
   */
  export type LogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogsCreateManyInput | LogsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Logs update
   */
  export type LogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to update a Logs.
     */
    data: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
    /**
     * Choose, which Logs to update.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs updateMany
   */
  export type LogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogsWhereInput
  }


  /**
   * Logs upsert
   */
  export type LogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The filter to search for the Logs to update in case it exists.
     */
    where: LogsWhereUniqueInput
    /**
     * In case the Logs found by the `where` argument doesn't exist, create a new Logs with this data.
     */
    create: XOR<LogsCreateInput, LogsUncheckedCreateInput>
    /**
     * In case the Logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
  }


  /**
   * Logs delete
   */
  export type LogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter which Logs to delete.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs deleteMany
   */
  export type LogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogsWhereInput
  }


  /**
   * Logs without action
   */
  export type LogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
  }



  /**
   * Model PlacementListings
   */

  export type AggregatePlacementListings = {
    _count: PlacementListingsCountAggregateOutputType | null
    _min: PlacementListingsMinAggregateOutputType | null
    _max: PlacementListingsMaxAggregateOutputType | null
  }

  export type PlacementListingsMinAggregateOutputType = {
    placementListingId: string | null
    addressId: string | null
    contactForename: string | null
    contactSurname: string | null
    created: Date | null
    mapConsent: boolean | null
    mapConsentDate: string | null
    providerEmail: string | null
    providerId: string | null
    providerPhone: string | null
    title: string | null
    uploadedBy: string | null
  }

  export type PlacementListingsMaxAggregateOutputType = {
    placementListingId: string | null
    addressId: string | null
    contactForename: string | null
    contactSurname: string | null
    created: Date | null
    mapConsent: boolean | null
    mapConsentDate: string | null
    providerEmail: string | null
    providerId: string | null
    providerPhone: string | null
    title: string | null
    uploadedBy: string | null
  }

  export type PlacementListingsCountAggregateOutputType = {
    placementListingId: number
    addressId: number
    contactForename: number
    contactSurname: number
    created: number
    mapConsent: number
    mapConsentDate: number
    providerEmail: number
    providerId: number
    providerPhone: number
    savedBy: number
    questions: number
    title: number
    uploadedBy: number
    _all: number
  }


  export type PlacementListingsMinAggregateInputType = {
    placementListingId?: true
    addressId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    mapConsent?: true
    mapConsentDate?: true
    providerEmail?: true
    providerId?: true
    providerPhone?: true
    title?: true
    uploadedBy?: true
  }

  export type PlacementListingsMaxAggregateInputType = {
    placementListingId?: true
    addressId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    mapConsent?: true
    mapConsentDate?: true
    providerEmail?: true
    providerId?: true
    providerPhone?: true
    title?: true
    uploadedBy?: true
  }

  export type PlacementListingsCountAggregateInputType = {
    placementListingId?: true
    addressId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    mapConsent?: true
    mapConsentDate?: true
    providerEmail?: true
    providerId?: true
    providerPhone?: true
    savedBy?: true
    questions?: true
    title?: true
    uploadedBy?: true
    _all?: true
  }

  export type PlacementListingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlacementListings to aggregate.
     */
    where?: PlacementListingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementListings to fetch.
     */
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlacementListingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlacementListings
    **/
    _count?: true | PlacementListingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlacementListingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlacementListingsMaxAggregateInputType
  }

  export type GetPlacementListingsAggregateType<T extends PlacementListingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlacementListings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlacementListings[P]>
      : GetScalarType<T[P], AggregatePlacementListings[P]>
  }




  export type PlacementListingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementListingsWhereInput
    orderBy?: PlacementListingsOrderByWithAggregationInput | PlacementListingsOrderByWithAggregationInput[]
    by: PlacementListingsScalarFieldEnum[] | PlacementListingsScalarFieldEnum
    having?: PlacementListingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlacementListingsCountAggregateInputType | true
    _min?: PlacementListingsMinAggregateInputType
    _max?: PlacementListingsMaxAggregateInputType
  }

  export type PlacementListingsGroupByOutputType = {
    placementListingId: string
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonValue
    questions: JsonValue
    title: string
    uploadedBy: string
    _count: PlacementListingsCountAggregateOutputType | null
    _min: PlacementListingsMinAggregateOutputType | null
    _max: PlacementListingsMaxAggregateOutputType | null
  }

  type GetPlacementListingsGroupByPayload<T extends PlacementListingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlacementListingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlacementListingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlacementListingsGroupByOutputType[P]>
            : GetScalarType<T[P], PlacementListingsGroupByOutputType[P]>
        }
      >
    >


  export type PlacementListingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    placementListingId?: boolean
    addressId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    created?: boolean
    mapConsent?: boolean
    mapConsentDate?: boolean
    providerEmail?: boolean
    providerId?: boolean
    providerPhone?: boolean
    savedBy?: boolean
    questions?: boolean
    title?: boolean
    uploadedBy?: boolean
    address?: boolean | AddressesDefaultArgs<ExtArgs>
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placementListings"]>

  export type PlacementListingsSelectScalar = {
    placementListingId?: boolean
    addressId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    created?: boolean
    mapConsent?: boolean
    mapConsentDate?: boolean
    providerEmail?: boolean
    providerId?: boolean
    providerPhone?: boolean
    savedBy?: boolean
    questions?: boolean
    title?: boolean
    uploadedBy?: boolean
  }

  export type PlacementListingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressesDefaultArgs<ExtArgs>
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
  }


  export type $PlacementListingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlacementListings"
    objects: {
      address: Prisma.$AddressesPayload<ExtArgs>
      provider: Prisma.$ProvidersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      placementListingId: string
      addressId: string
      contactForename: string
      contactSurname: string
      created: Date
      mapConsent: boolean
      mapConsentDate: string
      providerEmail: string
      providerId: string
      providerPhone: string
      savedBy: Prisma.JsonValue
      questions: Prisma.JsonValue
      title: string
      uploadedBy: string
    }, ExtArgs["result"]["placementListings"]>
    composites: {}
  }


  type PlacementListingsGetPayload<S extends boolean | null | undefined | PlacementListingsDefaultArgs> = $Result.GetResult<Prisma.$PlacementListingsPayload, S>

  type PlacementListingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlacementListingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlacementListingsCountAggregateInputType | true
    }

  export interface PlacementListingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlacementListings'], meta: { name: 'PlacementListings' } }
    /**
     * Find zero or one PlacementListings that matches the filter.
     * @param {PlacementListingsFindUniqueArgs} args - Arguments to find a PlacementListings
     * @example
     * // Get one PlacementListings
     * const placementListings = await prisma.placementListings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlacementListingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsFindUniqueArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PlacementListings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlacementListingsFindUniqueOrThrowArgs} args - Arguments to find a PlacementListings
     * @example
     * // Get one PlacementListings
     * const placementListings = await prisma.placementListings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlacementListingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PlacementListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsFindFirstArgs} args - Arguments to find a PlacementListings
     * @example
     * // Get one PlacementListings
     * const placementListings = await prisma.placementListings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlacementListingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsFindFirstArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PlacementListings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsFindFirstOrThrowArgs} args - Arguments to find a PlacementListings
     * @example
     * // Get one PlacementListings
     * const placementListings = await prisma.placementListings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlacementListingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PlacementListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlacementListings
     * const placementListings = await prisma.placementListings.findMany()
     * 
     * // Get first 10 PlacementListings
     * const placementListings = await prisma.placementListings.findMany({ take: 10 })
     * 
     * // Only select the `placementListingId`
     * const placementListingsWithPlacementListingIdOnly = await prisma.placementListings.findMany({ select: { placementListingId: true } })
     * 
    **/
    findMany<T extends PlacementListingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PlacementListings.
     * @param {PlacementListingsCreateArgs} args - Arguments to create a PlacementListings.
     * @example
     * // Create one PlacementListings
     * const PlacementListings = await prisma.placementListings.create({
     *   data: {
     *     // ... data to create a PlacementListings
     *   }
     * })
     * 
    **/
    create<T extends PlacementListingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsCreateArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PlacementListings.
     *     @param {PlacementListingsCreateManyArgs} args - Arguments to create many PlacementListings.
     *     @example
     *     // Create many PlacementListings
     *     const placementListings = await prisma.placementListings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlacementListingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlacementListings.
     * @param {PlacementListingsDeleteArgs} args - Arguments to delete one PlacementListings.
     * @example
     * // Delete one PlacementListings
     * const PlacementListings = await prisma.placementListings.delete({
     *   where: {
     *     // ... filter to delete one PlacementListings
     *   }
     * })
     * 
    **/
    delete<T extends PlacementListingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsDeleteArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PlacementListings.
     * @param {PlacementListingsUpdateArgs} args - Arguments to update one PlacementListings.
     * @example
     * // Update one PlacementListings
     * const placementListings = await prisma.placementListings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlacementListingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsUpdateArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PlacementListings.
     * @param {PlacementListingsDeleteManyArgs} args - Arguments to filter PlacementListings to delete.
     * @example
     * // Delete a few PlacementListings
     * const { count } = await prisma.placementListings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlacementListingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlacementListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlacementListings
     * const placementListings = await prisma.placementListings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlacementListingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlacementListings.
     * @param {PlacementListingsUpsertArgs} args - Arguments to update or create a PlacementListings.
     * @example
     * // Update or create a PlacementListings
     * const placementListings = await prisma.placementListings.upsert({
     *   create: {
     *     // ... data to create a PlacementListings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlacementListings we want to update
     *   }
     * })
    **/
    upsert<T extends PlacementListingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsUpsertArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PlacementListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsCountArgs} args - Arguments to filter PlacementListings to count.
     * @example
     * // Count the number of PlacementListings
     * const count = await prisma.placementListings.count({
     *   where: {
     *     // ... the filter for the PlacementListings we want to count
     *   }
     * })
    **/
    count<T extends PlacementListingsCountArgs>(
      args?: Subset<T, PlacementListingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlacementListingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlacementListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlacementListingsAggregateArgs>(args: Subset<T, PlacementListingsAggregateArgs>): Prisma.PrismaPromise<GetPlacementListingsAggregateType<T>>

    /**
     * Group by PlacementListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlacementListingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlacementListingsGroupByArgs['orderBy'] }
        : { orderBy?: PlacementListingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlacementListingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlacementListingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlacementListings model
   */
  readonly fields: PlacementListingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlacementListings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlacementListingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends AddressesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressesDefaultArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    provider<T extends ProvidersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvidersDefaultArgs<ExtArgs>>): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PlacementListings model
   */ 
  interface PlacementListingsFieldRefs {
    readonly placementListingId: FieldRef<"PlacementListings", 'String'>
    readonly addressId: FieldRef<"PlacementListings", 'String'>
    readonly contactForename: FieldRef<"PlacementListings", 'String'>
    readonly contactSurname: FieldRef<"PlacementListings", 'String'>
    readonly created: FieldRef<"PlacementListings", 'DateTime'>
    readonly mapConsent: FieldRef<"PlacementListings", 'Boolean'>
    readonly mapConsentDate: FieldRef<"PlacementListings", 'String'>
    readonly providerEmail: FieldRef<"PlacementListings", 'String'>
    readonly providerId: FieldRef<"PlacementListings", 'String'>
    readonly providerPhone: FieldRef<"PlacementListings", 'String'>
    readonly savedBy: FieldRef<"PlacementListings", 'Json'>
    readonly questions: FieldRef<"PlacementListings", 'Json'>
    readonly title: FieldRef<"PlacementListings", 'String'>
    readonly uploadedBy: FieldRef<"PlacementListings", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PlacementListings findUnique
   */
  export type PlacementListingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where: PlacementListingsWhereUniqueInput
  }


  /**
   * PlacementListings findUniqueOrThrow
   */
  export type PlacementListingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where: PlacementListingsWhereUniqueInput
  }


  /**
   * PlacementListings findFirst
   */
  export type PlacementListingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where?: PlacementListingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementListings to fetch.
     */
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlacementListings.
     */
    cursor?: PlacementListingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlacementListings.
     */
    distinct?: PlacementListingsScalarFieldEnum | PlacementListingsScalarFieldEnum[]
  }


  /**
   * PlacementListings findFirstOrThrow
   */
  export type PlacementListingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where?: PlacementListingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementListings to fetch.
     */
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlacementListings.
     */
    cursor?: PlacementListingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlacementListings.
     */
    distinct?: PlacementListingsScalarFieldEnum | PlacementListingsScalarFieldEnum[]
  }


  /**
   * PlacementListings findMany
   */
  export type PlacementListingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where?: PlacementListingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementListings to fetch.
     */
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlacementListings.
     */
    cursor?: PlacementListingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementListings.
     */
    skip?: number
    distinct?: PlacementListingsScalarFieldEnum | PlacementListingsScalarFieldEnum[]
  }


  /**
   * PlacementListings create
   */
  export type PlacementListingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * The data needed to create a PlacementListings.
     */
    data: XOR<PlacementListingsCreateInput, PlacementListingsUncheckedCreateInput>
  }


  /**
   * PlacementListings createMany
   */
  export type PlacementListingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlacementListings.
     */
    data: PlacementListingsCreateManyInput | PlacementListingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PlacementListings update
   */
  export type PlacementListingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * The data needed to update a PlacementListings.
     */
    data: XOR<PlacementListingsUpdateInput, PlacementListingsUncheckedUpdateInput>
    /**
     * Choose, which PlacementListings to update.
     */
    where: PlacementListingsWhereUniqueInput
  }


  /**
   * PlacementListings updateMany
   */
  export type PlacementListingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlacementListings.
     */
    data: XOR<PlacementListingsUpdateManyMutationInput, PlacementListingsUncheckedUpdateManyInput>
    /**
     * Filter which PlacementListings to update
     */
    where?: PlacementListingsWhereInput
  }


  /**
   * PlacementListings upsert
   */
  export type PlacementListingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * The filter to search for the PlacementListings to update in case it exists.
     */
    where: PlacementListingsWhereUniqueInput
    /**
     * In case the PlacementListings found by the `where` argument doesn't exist, create a new PlacementListings with this data.
     */
    create: XOR<PlacementListingsCreateInput, PlacementListingsUncheckedCreateInput>
    /**
     * In case the PlacementListings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlacementListingsUpdateInput, PlacementListingsUncheckedUpdateInput>
  }


  /**
   * PlacementListings delete
   */
  export type PlacementListingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    /**
     * Filter which PlacementListings to delete.
     */
    where: PlacementListingsWhereUniqueInput
  }


  /**
   * PlacementListings deleteMany
   */
  export type PlacementListingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlacementListings to delete
     */
    where?: PlacementListingsWhereInput
  }


  /**
   * PlacementListings without action
   */
  export type PlacementListingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
  }



  /**
   * Model Placements
   */

  export type AggregatePlacements = {
    _count: PlacementsCountAggregateOutputType | null
    _avg: PlacementsAvgAggregateOutputType | null
    _sum: PlacementsSumAggregateOutputType | null
    _min: PlacementsMinAggregateOutputType | null
    _max: PlacementsMaxAggregateOutputType | null
  }

  export type PlacementsAvgAggregateOutputType = {
    nextStatus: number | null
    status: number | null
  }

  export type PlacementsSumAggregateOutputType = {
    nextStatus: number | null
    status: number | null
  }

  export type PlacementsMinAggregateOutputType = {
    placementId: string | null
    cohortId: string | null
    contactForename: string | null
    contactSurname: string | null
    created: string | null
    draft: boolean | null
    endDate: string | null
    geoHash: string | null
    inProgress: boolean | null
    name: string | null
    parentEmailed: Date | null
    parentExpiry: string | null
    parentKey: string | null
    product: string | null
    providerEmail: string | null
    providerEmailed: Date | null
    providerExpiry: string | null
    providerKey: string | null
    providerName: string | null
    providerPhone: string | null
    nextStatus: number | null
    status: number | null
    startDate: string | null
    title: string | null
    uploadedBy: string | null
    addressId: string | null
    instituteId: string | null
    instituteStudentId: string | null
    providerId: string | null
    studentId: string | null
    userGroupId: string | null
  }

  export type PlacementsMaxAggregateOutputType = {
    placementId: string | null
    cohortId: string | null
    contactForename: string | null
    contactSurname: string | null
    created: string | null
    draft: boolean | null
    endDate: string | null
    geoHash: string | null
    inProgress: boolean | null
    name: string | null
    parentEmailed: Date | null
    parentExpiry: string | null
    parentKey: string | null
    product: string | null
    providerEmail: string | null
    providerEmailed: Date | null
    providerExpiry: string | null
    providerKey: string | null
    providerName: string | null
    providerPhone: string | null
    nextStatus: number | null
    status: number | null
    startDate: string | null
    title: string | null
    uploadedBy: string | null
    addressId: string | null
    instituteId: string | null
    instituteStudentId: string | null
    providerId: string | null
    studentId: string | null
    userGroupId: string | null
  }

  export type PlacementsCountAggregateOutputType = {
    placementId: number
    activeDates: number
    cohortId: number
    contactForename: number
    contactSurname: number
    created: number
    draft: number
    endDate: number
    flags: number
    geoHash: number
    inProgress: number
    leadTimes: number
    name: number
    parentEmailed: number
    parentExpiry: number
    parentKey: number
    product: number
    providerEmail: number
    providerEmailed: number
    providerExpiry: number
    providerKey: number
    providerName: number
    providerPhone: number
    nextStatus: number
    status: number
    startDate: number
    title: number
    forms: number
    questions: number
    uploadedBy: number
    addressId: number
    instituteId: number
    instituteStudentId: number
    providerId: number
    studentId: number
    userGroupId: number
    _all: number
  }


  export type PlacementsAvgAggregateInputType = {
    nextStatus?: true
    status?: true
  }

  export type PlacementsSumAggregateInputType = {
    nextStatus?: true
    status?: true
  }

  export type PlacementsMinAggregateInputType = {
    placementId?: true
    cohortId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    draft?: true
    endDate?: true
    geoHash?: true
    inProgress?: true
    name?: true
    parentEmailed?: true
    parentExpiry?: true
    parentKey?: true
    product?: true
    providerEmail?: true
    providerEmailed?: true
    providerExpiry?: true
    providerKey?: true
    providerName?: true
    providerPhone?: true
    nextStatus?: true
    status?: true
    startDate?: true
    title?: true
    uploadedBy?: true
    addressId?: true
    instituteId?: true
    instituteStudentId?: true
    providerId?: true
    studentId?: true
    userGroupId?: true
  }

  export type PlacementsMaxAggregateInputType = {
    placementId?: true
    cohortId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    draft?: true
    endDate?: true
    geoHash?: true
    inProgress?: true
    name?: true
    parentEmailed?: true
    parentExpiry?: true
    parentKey?: true
    product?: true
    providerEmail?: true
    providerEmailed?: true
    providerExpiry?: true
    providerKey?: true
    providerName?: true
    providerPhone?: true
    nextStatus?: true
    status?: true
    startDate?: true
    title?: true
    uploadedBy?: true
    addressId?: true
    instituteId?: true
    instituteStudentId?: true
    providerId?: true
    studentId?: true
    userGroupId?: true
  }

  export type PlacementsCountAggregateInputType = {
    placementId?: true
    activeDates?: true
    cohortId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    draft?: true
    endDate?: true
    flags?: true
    geoHash?: true
    inProgress?: true
    leadTimes?: true
    name?: true
    parentEmailed?: true
    parentExpiry?: true
    parentKey?: true
    product?: true
    providerEmail?: true
    providerEmailed?: true
    providerExpiry?: true
    providerKey?: true
    providerName?: true
    providerPhone?: true
    nextStatus?: true
    status?: true
    startDate?: true
    title?: true
    forms?: true
    questions?: true
    uploadedBy?: true
    addressId?: true
    instituteId?: true
    instituteStudentId?: true
    providerId?: true
    studentId?: true
    userGroupId?: true
    _all?: true
  }

  export type PlacementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Placements to aggregate.
     */
    where?: PlacementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlacementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Placements
    **/
    _count?: true | PlacementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlacementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlacementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlacementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlacementsMaxAggregateInputType
  }

  export type GetPlacementsAggregateType<T extends PlacementsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlacements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlacements[P]>
      : GetScalarType<T[P], AggregatePlacements[P]>
  }




  export type PlacementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementsWhereInput
    orderBy?: PlacementsOrderByWithAggregationInput | PlacementsOrderByWithAggregationInput[]
    by: PlacementsScalarFieldEnum[] | PlacementsScalarFieldEnum
    having?: PlacementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlacementsCountAggregateInputType | true
    _avg?: PlacementsAvgAggregateInputType
    _sum?: PlacementsSumAggregateInputType
    _min?: PlacementsMinAggregateInputType
    _max?: PlacementsMaxAggregateInputType
  }

  export type PlacementsGroupByOutputType = {
    placementId: string
    activeDates: string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags: string[]
    geoHash: string
    inProgress: boolean
    leadTimes: string[]
    name: string
    parentEmailed: Date | null
    parentExpiry: string | null
    parentKey: string | null
    product: string | null
    providerEmail: string | null
    providerEmailed: Date | null
    providerExpiry: string | null
    providerKey: string | null
    providerName: string | null
    providerPhone: string
    nextStatus: number | null
    status: number
    startDate: string
    title: string
    forms: JsonValue
    questions: JsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    userGroupId: string
    _count: PlacementsCountAggregateOutputType | null
    _avg: PlacementsAvgAggregateOutputType | null
    _sum: PlacementsSumAggregateOutputType | null
    _min: PlacementsMinAggregateOutputType | null
    _max: PlacementsMaxAggregateOutputType | null
  }

  type GetPlacementsGroupByPayload<T extends PlacementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlacementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlacementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlacementsGroupByOutputType[P]>
            : GetScalarType<T[P], PlacementsGroupByOutputType[P]>
        }
      >
    >


  export type PlacementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    placementId?: boolean
    activeDates?: boolean
    cohortId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    created?: boolean
    draft?: boolean
    endDate?: boolean
    flags?: boolean
    geoHash?: boolean
    inProgress?: boolean
    leadTimes?: boolean
    name?: boolean
    parentEmailed?: boolean
    parentExpiry?: boolean
    parentKey?: boolean
    product?: boolean
    providerEmail?: boolean
    providerEmailed?: boolean
    providerExpiry?: boolean
    providerKey?: boolean
    providerName?: boolean
    providerPhone?: boolean
    nextStatus?: boolean
    status?: boolean
    startDate?: boolean
    title?: boolean
    forms?: boolean
    questions?: boolean
    uploadedBy?: boolean
    addressId?: boolean
    instituteId?: boolean
    instituteStudentId?: boolean
    providerId?: boolean
    studentId?: boolean
    userGroupId?: boolean
    Logs?: boolean | Placements$LogsArgs<ExtArgs>
    address?: boolean | AddressesDefaultArgs<ExtArgs>
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    instituteStudent?: boolean | InstituteStudentsDefaultArgs<ExtArgs>
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
    student?: boolean | StudentUsersDefaultArgs<ExtArgs>
    userGroup?: boolean | InstituteStudentUserGroupsDefaultArgs<ExtArgs>
    _count?: boolean | PlacementsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placements"]>

  export type PlacementsSelectScalar = {
    placementId?: boolean
    activeDates?: boolean
    cohortId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    created?: boolean
    draft?: boolean
    endDate?: boolean
    flags?: boolean
    geoHash?: boolean
    inProgress?: boolean
    leadTimes?: boolean
    name?: boolean
    parentEmailed?: boolean
    parentExpiry?: boolean
    parentKey?: boolean
    product?: boolean
    providerEmail?: boolean
    providerEmailed?: boolean
    providerExpiry?: boolean
    providerKey?: boolean
    providerName?: boolean
    providerPhone?: boolean
    nextStatus?: boolean
    status?: boolean
    startDate?: boolean
    title?: boolean
    forms?: boolean
    questions?: boolean
    uploadedBy?: boolean
    addressId?: boolean
    instituteId?: boolean
    instituteStudentId?: boolean
    providerId?: boolean
    studentId?: boolean
    userGroupId?: boolean
  }

  export type PlacementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Logs?: boolean | Placements$LogsArgs<ExtArgs>
    address?: boolean | AddressesDefaultArgs<ExtArgs>
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    instituteStudent?: boolean | InstituteStudentsDefaultArgs<ExtArgs>
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
    student?: boolean | StudentUsersDefaultArgs<ExtArgs>
    userGroup?: boolean | InstituteStudentUserGroupsDefaultArgs<ExtArgs>
    _count?: boolean | PlacementsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PlacementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Placements"
    objects: {
      Logs: Prisma.$LogsPayload<ExtArgs>[]
      address: Prisma.$AddressesPayload<ExtArgs>
      institute: Prisma.$InstitutesPayload<ExtArgs>
      instituteStudent: Prisma.$InstituteStudentsPayload<ExtArgs>
      provider: Prisma.$ProvidersPayload<ExtArgs>
      student: Prisma.$StudentUsersPayload<ExtArgs>
      userGroup: Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      placementId: string
      activeDates: string[]
      cohortId: string
      contactForename: string
      contactSurname: string
      created: string
      draft: boolean
      endDate: string
      flags: string[]
      geoHash: string
      inProgress: boolean
      leadTimes: string[]
      name: string
      parentEmailed: Date | null
      parentExpiry: string | null
      parentKey: string | null
      product: string | null
      providerEmail: string | null
      providerEmailed: Date | null
      providerExpiry: string | null
      providerKey: string | null
      providerName: string | null
      providerPhone: string
      nextStatus: number | null
      status: number
      startDate: string
      title: string
      forms: Prisma.JsonValue
      questions: Prisma.JsonValue
      uploadedBy: string
      addressId: string
      instituteId: string
      instituteStudentId: string
      providerId: string
      studentId: string
      userGroupId: string
    }, ExtArgs["result"]["placements"]>
    composites: {}
  }


  type PlacementsGetPayload<S extends boolean | null | undefined | PlacementsDefaultArgs> = $Result.GetResult<Prisma.$PlacementsPayload, S>

  type PlacementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlacementsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlacementsCountAggregateInputType | true
    }

  export interface PlacementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Placements'], meta: { name: 'Placements' } }
    /**
     * Find zero or one Placements that matches the filter.
     * @param {PlacementsFindUniqueArgs} args - Arguments to find a Placements
     * @example
     * // Get one Placements
     * const placements = await prisma.placements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlacementsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsFindUniqueArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Placements that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlacementsFindUniqueOrThrowArgs} args - Arguments to find a Placements
     * @example
     * // Get one Placements
     * const placements = await prisma.placements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlacementsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Placements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsFindFirstArgs} args - Arguments to find a Placements
     * @example
     * // Get one Placements
     * const placements = await prisma.placements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlacementsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsFindFirstArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Placements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsFindFirstOrThrowArgs} args - Arguments to find a Placements
     * @example
     * // Get one Placements
     * const placements = await prisma.placements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlacementsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Placements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Placements
     * const placements = await prisma.placements.findMany()
     * 
     * // Get first 10 Placements
     * const placements = await prisma.placements.findMany({ take: 10 })
     * 
     * // Only select the `placementId`
     * const placementsWithPlacementIdOnly = await prisma.placements.findMany({ select: { placementId: true } })
     * 
    **/
    findMany<T extends PlacementsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Placements.
     * @param {PlacementsCreateArgs} args - Arguments to create a Placements.
     * @example
     * // Create one Placements
     * const Placements = await prisma.placements.create({
     *   data: {
     *     // ... data to create a Placements
     *   }
     * })
     * 
    **/
    create<T extends PlacementsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsCreateArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Placements.
     *     @param {PlacementsCreateManyArgs} args - Arguments to create many Placements.
     *     @example
     *     // Create many Placements
     *     const placements = await prisma.placements.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlacementsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Placements.
     * @param {PlacementsDeleteArgs} args - Arguments to delete one Placements.
     * @example
     * // Delete one Placements
     * const Placements = await prisma.placements.delete({
     *   where: {
     *     // ... filter to delete one Placements
     *   }
     * })
     * 
    **/
    delete<T extends PlacementsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsDeleteArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Placements.
     * @param {PlacementsUpdateArgs} args - Arguments to update one Placements.
     * @example
     * // Update one Placements
     * const placements = await prisma.placements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlacementsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsUpdateArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Placements.
     * @param {PlacementsDeleteManyArgs} args - Arguments to filter Placements to delete.
     * @example
     * // Delete a few Placements
     * const { count } = await prisma.placements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlacementsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Placements
     * const placements = await prisma.placements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlacementsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Placements.
     * @param {PlacementsUpsertArgs} args - Arguments to update or create a Placements.
     * @example
     * // Update or create a Placements
     * const placements = await prisma.placements.upsert({
     *   create: {
     *     // ... data to create a Placements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Placements we want to update
     *   }
     * })
    **/
    upsert<T extends PlacementsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsUpsertArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsCountArgs} args - Arguments to filter Placements to count.
     * @example
     * // Count the number of Placements
     * const count = await prisma.placements.count({
     *   where: {
     *     // ... the filter for the Placements we want to count
     *   }
     * })
    **/
    count<T extends PlacementsCountArgs>(
      args?: Subset<T, PlacementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlacementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlacementsAggregateArgs>(args: Subset<T, PlacementsAggregateArgs>): Prisma.PrismaPromise<GetPlacementsAggregateType<T>>

    /**
     * Group by Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlacementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlacementsGroupByArgs['orderBy'] }
        : { orderBy?: PlacementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlacementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlacementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Placements model
   */
  readonly fields: PlacementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Placements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlacementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Logs<T extends Placements$LogsArgs<ExtArgs> = {}>(args?: Subset<T, Placements$LogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findMany'> | Null>;

    address<T extends AddressesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressesDefaultArgs<ExtArgs>>): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    institute<T extends InstitutesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutesDefaultArgs<ExtArgs>>): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    instituteStudent<T extends InstituteStudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStudentsDefaultArgs<ExtArgs>>): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    provider<T extends ProvidersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvidersDefaultArgs<ExtArgs>>): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    student<T extends StudentUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentUsersDefaultArgs<ExtArgs>>): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    userGroup<T extends InstituteStudentUserGroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStudentUserGroupsDefaultArgs<ExtArgs>>): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Placements model
   */ 
  interface PlacementsFieldRefs {
    readonly placementId: FieldRef<"Placements", 'String'>
    readonly activeDates: FieldRef<"Placements", 'String[]'>
    readonly cohortId: FieldRef<"Placements", 'String'>
    readonly contactForename: FieldRef<"Placements", 'String'>
    readonly contactSurname: FieldRef<"Placements", 'String'>
    readonly created: FieldRef<"Placements", 'String'>
    readonly draft: FieldRef<"Placements", 'Boolean'>
    readonly endDate: FieldRef<"Placements", 'String'>
    readonly flags: FieldRef<"Placements", 'String[]'>
    readonly geoHash: FieldRef<"Placements", 'String'>
    readonly inProgress: FieldRef<"Placements", 'Boolean'>
    readonly leadTimes: FieldRef<"Placements", 'String[]'>
    readonly name: FieldRef<"Placements", 'String'>
    readonly parentEmailed: FieldRef<"Placements", 'DateTime'>
    readonly parentExpiry: FieldRef<"Placements", 'String'>
    readonly parentKey: FieldRef<"Placements", 'String'>
    readonly product: FieldRef<"Placements", 'String'>
    readonly providerEmail: FieldRef<"Placements", 'String'>
    readonly providerEmailed: FieldRef<"Placements", 'DateTime'>
    readonly providerExpiry: FieldRef<"Placements", 'String'>
    readonly providerKey: FieldRef<"Placements", 'String'>
    readonly providerName: FieldRef<"Placements", 'String'>
    readonly providerPhone: FieldRef<"Placements", 'String'>
    readonly nextStatus: FieldRef<"Placements", 'Int'>
    readonly status: FieldRef<"Placements", 'Int'>
    readonly startDate: FieldRef<"Placements", 'String'>
    readonly title: FieldRef<"Placements", 'String'>
    readonly forms: FieldRef<"Placements", 'Json'>
    readonly questions: FieldRef<"Placements", 'Json'>
    readonly uploadedBy: FieldRef<"Placements", 'String'>
    readonly addressId: FieldRef<"Placements", 'String'>
    readonly instituteId: FieldRef<"Placements", 'String'>
    readonly instituteStudentId: FieldRef<"Placements", 'String'>
    readonly providerId: FieldRef<"Placements", 'String'>
    readonly studentId: FieldRef<"Placements", 'String'>
    readonly userGroupId: FieldRef<"Placements", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Placements findUnique
   */
  export type PlacementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where: PlacementsWhereUniqueInput
  }


  /**
   * Placements findUniqueOrThrow
   */
  export type PlacementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where: PlacementsWhereUniqueInput
  }


  /**
   * Placements findFirst
   */
  export type PlacementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Placements findFirstOrThrow
   */
  export type PlacementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Placements findMany
   */
  export type PlacementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Placements.
     */
    cursor?: PlacementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Placements create
   */
  export type PlacementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * The data needed to create a Placements.
     */
    data: XOR<PlacementsCreateInput, PlacementsUncheckedCreateInput>
  }


  /**
   * Placements createMany
   */
  export type PlacementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Placements.
     */
    data: PlacementsCreateManyInput | PlacementsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Placements update
   */
  export type PlacementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * The data needed to update a Placements.
     */
    data: XOR<PlacementsUpdateInput, PlacementsUncheckedUpdateInput>
    /**
     * Choose, which Placements to update.
     */
    where: PlacementsWhereUniqueInput
  }


  /**
   * Placements updateMany
   */
  export type PlacementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Placements.
     */
    data: XOR<PlacementsUpdateManyMutationInput, PlacementsUncheckedUpdateManyInput>
    /**
     * Filter which Placements to update
     */
    where?: PlacementsWhereInput
  }


  /**
   * Placements upsert
   */
  export type PlacementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * The filter to search for the Placements to update in case it exists.
     */
    where: PlacementsWhereUniqueInput
    /**
     * In case the Placements found by the `where` argument doesn't exist, create a new Placements with this data.
     */
    create: XOR<PlacementsCreateInput, PlacementsUncheckedCreateInput>
    /**
     * In case the Placements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlacementsUpdateInput, PlacementsUncheckedUpdateInput>
  }


  /**
   * Placements delete
   */
  export type PlacementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    /**
     * Filter which Placements to delete.
     */
    where: PlacementsWhereUniqueInput
  }


  /**
   * Placements deleteMany
   */
  export type PlacementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Placements to delete
     */
    where?: PlacementsWhereInput
  }


  /**
   * Placements.Logs
   */
  export type Placements$LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Placements without action
   */
  export type PlacementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
  }



  /**
   * Model Providers
   */

  export type AggregateProviders = {
    _count: ProvidersCountAggregateOutputType | null
    _avg: ProvidersAvgAggregateOutputType | null
    _sum: ProvidersSumAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  export type ProvidersAvgAggregateOutputType = {
    activationCode: number | null
  }

  export type ProvidersSumAggregateOutputType = {
    activationCode: number | null
  }

  export type ProvidersMinAggregateOutputType = {
    providerId: string | null
    contactForename: string | null
    contactSurname: string | null
    email: string | null
    mapConsent: boolean | null
    insurance: boolean | null
    mapConsentDate: string | null
    name: string | null
    phone: string | null
    rememberConsent: boolean | null
    rememberConsentDate: string | null
    sector: string | null
    referral: string | null
    subsector: string | null
    uploadedBy: string | null
    website: string | null
    activationCode: number | null
    status: string | null
  }

  export type ProvidersMaxAggregateOutputType = {
    providerId: string | null
    contactForename: string | null
    contactSurname: string | null
    email: string | null
    mapConsent: boolean | null
    insurance: boolean | null
    mapConsentDate: string | null
    name: string | null
    phone: string | null
    rememberConsent: boolean | null
    rememberConsentDate: string | null
    sector: string | null
    referral: string | null
    subsector: string | null
    uploadedBy: string | null
    website: string | null
    activationCode: number | null
    status: string | null
  }

  export type ProvidersCountAggregateOutputType = {
    providerId: number
    contactForename: number
    contactSurname: number
    email: number
    mapConsent: number
    insurance: number
    mapConsentDate: number
    name: number
    phone: number
    rememberConsent: number
    rememberConsentDate: number
    savedBy: number
    sector: number
    referral: number
    subsector: number
    uploadedBy: number
    website: number
    activationCode: number
    status: number
    _all: number
  }


  export type ProvidersAvgAggregateInputType = {
    activationCode?: true
  }

  export type ProvidersSumAggregateInputType = {
    activationCode?: true
  }

  export type ProvidersMinAggregateInputType = {
    providerId?: true
    contactForename?: true
    contactSurname?: true
    email?: true
    mapConsent?: true
    insurance?: true
    mapConsentDate?: true
    name?: true
    phone?: true
    rememberConsent?: true
    rememberConsentDate?: true
    sector?: true
    referral?: true
    subsector?: true
    uploadedBy?: true
    website?: true
    activationCode?: true
    status?: true
  }

  export type ProvidersMaxAggregateInputType = {
    providerId?: true
    contactForename?: true
    contactSurname?: true
    email?: true
    mapConsent?: true
    insurance?: true
    mapConsentDate?: true
    name?: true
    phone?: true
    rememberConsent?: true
    rememberConsentDate?: true
    sector?: true
    referral?: true
    subsector?: true
    uploadedBy?: true
    website?: true
    activationCode?: true
    status?: true
  }

  export type ProvidersCountAggregateInputType = {
    providerId?: true
    contactForename?: true
    contactSurname?: true
    email?: true
    mapConsent?: true
    insurance?: true
    mapConsentDate?: true
    name?: true
    phone?: true
    rememberConsent?: true
    rememberConsentDate?: true
    savedBy?: true
    sector?: true
    referral?: true
    subsector?: true
    uploadedBy?: true
    website?: true
    activationCode?: true
    status?: true
    _all?: true
  }

  export type ProvidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to aggregate.
     */
    where?: ProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProvidersOrderByWithRelationInput | ProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProvidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvidersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvidersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvidersMaxAggregateInputType
  }

  export type GetProvidersAggregateType<T extends ProvidersAggregateArgs> = {
        [P in keyof T & keyof AggregateProviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviders[P]>
      : GetScalarType<T[P], AggregateProviders[P]>
  }




  export type ProvidersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvidersWhereInput
    orderBy?: ProvidersOrderByWithAggregationInput | ProvidersOrderByWithAggregationInput[]
    by: ProvidersScalarFieldEnum[] | ProvidersScalarFieldEnum
    having?: ProvidersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvidersCountAggregateInputType | true
    _avg?: ProvidersAvgAggregateInputType
    _sum?: ProvidersSumAggregateInputType
    _min?: ProvidersMinAggregateInputType
    _max?: ProvidersMaxAggregateInputType
  }

  export type ProvidersGroupByOutputType = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent: boolean | null
    insurance: boolean | null
    mapConsentDate: string | null
    name: string
    phone: string
    rememberConsent: boolean | null
    rememberConsentDate: string | null
    savedBy: JsonValue | null
    sector: string
    referral: string | null
    subsector: string
    uploadedBy: string
    website: string | null
    activationCode: number
    status: string
    _count: ProvidersCountAggregateOutputType | null
    _avg: ProvidersAvgAggregateOutputType | null
    _sum: ProvidersSumAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  type GetProvidersGroupByPayload<T extends ProvidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
            : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
        }
      >
    >


  export type ProvidersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    providerId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    email?: boolean
    mapConsent?: boolean
    insurance?: boolean
    mapConsentDate?: boolean
    name?: boolean
    phone?: boolean
    rememberConsent?: boolean
    rememberConsentDate?: boolean
    savedBy?: boolean
    sector?: boolean
    referral?: boolean
    subsector?: boolean
    uploadedBy?: boolean
    website?: boolean
    activationCode?: boolean
    status?: boolean
    Addresses?: boolean | Providers$AddressesArgs<ExtArgs>
    PlacementListings?: boolean | Providers$PlacementListingsArgs<ExtArgs>
    Placements?: boolean | Providers$PlacementsArgs<ExtArgs>
    ProviderStaff?: boolean | Providers$ProviderStaffArgs<ExtArgs>
    ProviderUserGroups?: boolean | Providers$ProviderUserGroupsArgs<ExtArgs>
    ProviderCohorts?: boolean | Providers$ProviderCohortsArgs<ExtArgs>
    _count?: boolean | ProvidersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providers"]>

  export type ProvidersSelectScalar = {
    providerId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    email?: boolean
    mapConsent?: boolean
    insurance?: boolean
    mapConsentDate?: boolean
    name?: boolean
    phone?: boolean
    rememberConsent?: boolean
    rememberConsentDate?: boolean
    savedBy?: boolean
    sector?: boolean
    referral?: boolean
    subsector?: boolean
    uploadedBy?: boolean
    website?: boolean
    activationCode?: boolean
    status?: boolean
  }

  export type ProvidersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Addresses?: boolean | Providers$AddressesArgs<ExtArgs>
    PlacementListings?: boolean | Providers$PlacementListingsArgs<ExtArgs>
    Placements?: boolean | Providers$PlacementsArgs<ExtArgs>
    ProviderStaff?: boolean | Providers$ProviderStaffArgs<ExtArgs>
    ProviderUserGroups?: boolean | Providers$ProviderUserGroupsArgs<ExtArgs>
    ProviderCohorts?: boolean | Providers$ProviderCohortsArgs<ExtArgs>
    _count?: boolean | ProvidersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProvidersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Providers"
    objects: {
      Addresses: Prisma.$AddressesPayload<ExtArgs>[]
      PlacementListings: Prisma.$PlacementListingsPayload<ExtArgs>[]
      Placements: Prisma.$PlacementsPayload<ExtArgs>[]
      ProviderStaff: Prisma.$ProviderStaffPayload<ExtArgs>[]
      ProviderUserGroups: Prisma.$ProviderUserGroupsPayload<ExtArgs>[]
      ProviderCohorts: Prisma.$ProviderCohortsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      providerId: string
      contactForename: string
      contactSurname: string
      email: string
      mapConsent: boolean | null
      insurance: boolean | null
      mapConsentDate: string | null
      name: string
      phone: string
      rememberConsent: boolean | null
      rememberConsentDate: string | null
      savedBy: Prisma.JsonValue | null
      sector: string
      referral: string | null
      subsector: string
      uploadedBy: string
      website: string | null
      activationCode: number
      status: string
    }, ExtArgs["result"]["providers"]>
    composites: {}
  }


  type ProvidersGetPayload<S extends boolean | null | undefined | ProvidersDefaultArgs> = $Result.GetResult<Prisma.$ProvidersPayload, S>

  type ProvidersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProvidersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProvidersCountAggregateInputType | true
    }

  export interface ProvidersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Providers'], meta: { name: 'Providers' } }
    /**
     * Find zero or one Providers that matches the filter.
     * @param {ProvidersFindUniqueArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProvidersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersFindUniqueArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Providers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProvidersFindUniqueOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProvidersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersFindFirstArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProvidersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersFindFirstArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Providers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersFindFirstOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProvidersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.providers.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.providers.findMany({ take: 10 })
     * 
     * // Only select the `providerId`
     * const providersWithProviderIdOnly = await prisma.providers.findMany({ select: { providerId: true } })
     * 
    **/
    findMany<T extends ProvidersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Providers.
     * @param {ProvidersCreateArgs} args - Arguments to create a Providers.
     * @example
     * // Create one Providers
     * const Providers = await prisma.providers.create({
     *   data: {
     *     // ... data to create a Providers
     *   }
     * })
     * 
    **/
    create<T extends ProvidersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersCreateArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Providers.
     *     @param {ProvidersCreateManyArgs} args - Arguments to create many Providers.
     *     @example
     *     // Create many Providers
     *     const providers = await prisma.providers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProvidersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Providers.
     * @param {ProvidersDeleteArgs} args - Arguments to delete one Providers.
     * @example
     * // Delete one Providers
     * const Providers = await prisma.providers.delete({
     *   where: {
     *     // ... filter to delete one Providers
     *   }
     * })
     * 
    **/
    delete<T extends ProvidersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersDeleteArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Providers.
     * @param {ProvidersUpdateArgs} args - Arguments to update one Providers.
     * @example
     * // Update one Providers
     * const providers = await prisma.providers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProvidersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersUpdateArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Providers.
     * @param {ProvidersDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.providers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProvidersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const providers = await prisma.providers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProvidersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Providers.
     * @param {ProvidersUpsertArgs} args - Arguments to update or create a Providers.
     * @example
     * // Update or create a Providers
     * const providers = await prisma.providers.upsert({
     *   create: {
     *     // ... data to create a Providers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Providers we want to update
     *   }
     * })
    **/
    upsert<T extends ProvidersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersUpsertArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.providers.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProvidersCountArgs>(
      args?: Subset<T, ProvidersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvidersAggregateArgs>(args: Subset<T, ProvidersAggregateArgs>): Prisma.PrismaPromise<GetProvidersAggregateType<T>>

    /**
     * Group by Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvidersGroupByArgs['orderBy'] }
        : { orderBy?: ProvidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Providers model
   */
  readonly fields: ProvidersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Providers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvidersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Addresses<T extends Providers$AddressesArgs<ExtArgs> = {}>(args?: Subset<T, Providers$AddressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findMany'> | Null>;

    PlacementListings<T extends Providers$PlacementListingsArgs<ExtArgs> = {}>(args?: Subset<T, Providers$PlacementListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Placements<T extends Providers$PlacementsArgs<ExtArgs> = {}>(args?: Subset<T, Providers$PlacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findMany'> | Null>;

    ProviderStaff<T extends Providers$ProviderStaffArgs<ExtArgs> = {}>(args?: Subset<T, Providers$ProviderStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findMany'> | Null>;

    ProviderUserGroups<T extends Providers$ProviderUserGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Providers$ProviderUserGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'findMany'> | Null>;

    ProviderCohorts<T extends Providers$ProviderCohortsArgs<ExtArgs> = {}>(args?: Subset<T, Providers$ProviderCohortsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderCohortsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Providers model
   */ 
  interface ProvidersFieldRefs {
    readonly providerId: FieldRef<"Providers", 'String'>
    readonly contactForename: FieldRef<"Providers", 'String'>
    readonly contactSurname: FieldRef<"Providers", 'String'>
    readonly email: FieldRef<"Providers", 'String'>
    readonly mapConsent: FieldRef<"Providers", 'Boolean'>
    readonly insurance: FieldRef<"Providers", 'Boolean'>
    readonly mapConsentDate: FieldRef<"Providers", 'String'>
    readonly name: FieldRef<"Providers", 'String'>
    readonly phone: FieldRef<"Providers", 'String'>
    readonly rememberConsent: FieldRef<"Providers", 'Boolean'>
    readonly rememberConsentDate: FieldRef<"Providers", 'String'>
    readonly savedBy: FieldRef<"Providers", 'Json'>
    readonly sector: FieldRef<"Providers", 'String'>
    readonly referral: FieldRef<"Providers", 'String'>
    readonly subsector: FieldRef<"Providers", 'String'>
    readonly uploadedBy: FieldRef<"Providers", 'String'>
    readonly website: FieldRef<"Providers", 'String'>
    readonly activationCode: FieldRef<"Providers", 'Int'>
    readonly status: FieldRef<"Providers", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Providers findUnique
   */
  export type ProvidersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where: ProvidersWhereUniqueInput
  }


  /**
   * Providers findUniqueOrThrow
   */
  export type ProvidersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where: ProvidersWhereUniqueInput
  }


  /**
   * Providers findFirst
   */
  export type ProvidersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProvidersOrderByWithRelationInput | ProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }


  /**
   * Providers findFirstOrThrow
   */
  export type ProvidersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProvidersOrderByWithRelationInput | ProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }


  /**
   * Providers findMany
   */
  export type ProvidersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProvidersOrderByWithRelationInput | ProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }


  /**
   * Providers create
   */
  export type ProvidersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * The data needed to create a Providers.
     */
    data: XOR<ProvidersCreateInput, ProvidersUncheckedCreateInput>
  }


  /**
   * Providers createMany
   */
  export type ProvidersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProvidersCreateManyInput | ProvidersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Providers update
   */
  export type ProvidersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * The data needed to update a Providers.
     */
    data: XOR<ProvidersUpdateInput, ProvidersUncheckedUpdateInput>
    /**
     * Choose, which Providers to update.
     */
    where: ProvidersWhereUniqueInput
  }


  /**
   * Providers updateMany
   */
  export type ProvidersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProvidersUpdateManyMutationInput, ProvidersUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProvidersWhereInput
  }


  /**
   * Providers upsert
   */
  export type ProvidersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * The filter to search for the Providers to update in case it exists.
     */
    where: ProvidersWhereUniqueInput
    /**
     * In case the Providers found by the `where` argument doesn't exist, create a new Providers with this data.
     */
    create: XOR<ProvidersCreateInput, ProvidersUncheckedCreateInput>
    /**
     * In case the Providers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvidersUpdateInput, ProvidersUncheckedUpdateInput>
  }


  /**
   * Providers delete
   */
  export type ProvidersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
    /**
     * Filter which Providers to delete.
     */
    where: ProvidersWhereUniqueInput
  }


  /**
   * Providers deleteMany
   */
  export type ProvidersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProvidersWhereInput
  }


  /**
   * Providers.Addresses
   */
  export type Providers$AddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressesInclude<ExtArgs> | null
    where?: AddressesWhereInput
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    cursor?: AddressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }


  /**
   * Providers.PlacementListings
   */
  export type Providers$PlacementListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementListingsInclude<ExtArgs> | null
    where?: PlacementListingsWhereInput
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    cursor?: PlacementListingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementListingsScalarFieldEnum | PlacementListingsScalarFieldEnum[]
  }


  /**
   * Providers.Placements
   */
  export type Providers$PlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    where?: PlacementsWhereInput
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    cursor?: PlacementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Providers.ProviderStaff
   */
  export type Providers$ProviderStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    where?: ProviderStaffWhereInput
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    cursor?: ProviderStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderStaffScalarFieldEnum | ProviderStaffScalarFieldEnum[]
  }


  /**
   * Providers.ProviderUserGroups
   */
  export type Providers$ProviderUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    where?: ProviderUserGroupsWhereInput
    orderBy?: ProviderUserGroupsOrderByWithRelationInput | ProviderUserGroupsOrderByWithRelationInput[]
    cursor?: ProviderUserGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderUserGroupsScalarFieldEnum | ProviderUserGroupsScalarFieldEnum[]
  }


  /**
   * Providers.ProviderCohorts
   */
  export type Providers$ProviderCohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCohorts
     */
    select?: ProviderCohortsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderCohortsInclude<ExtArgs> | null
    where?: ProviderCohortsWhereInput
    orderBy?: ProviderCohortsOrderByWithRelationInput | ProviderCohortsOrderByWithRelationInput[]
    cursor?: ProviderCohortsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderCohortsScalarFieldEnum | ProviderCohortsScalarFieldEnum[]
  }


  /**
   * Providers without action
   */
  export type ProvidersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProvidersInclude<ExtArgs> | null
  }



  /**
   * Model InstituteStudentUserGroups
   */

  export type AggregateInstituteStudentUserGroups = {
    _count: InstituteStudentUserGroupsCountAggregateOutputType | null
    _min: InstituteStudentUserGroupsMinAggregateOutputType | null
    _max: InstituteStudentUserGroupsMaxAggregateOutputType | null
  }

  export type InstituteStudentUserGroupsMinAggregateOutputType = {
    userGroupId: string | null
    default: boolean | null
    name: string | null
    updated: string | null
    instituteId: string | null
  }

  export type InstituteStudentUserGroupsMaxAggregateOutputType = {
    userGroupId: string | null
    default: boolean | null
    name: string | null
    updated: string | null
    instituteId: string | null
  }

  export type InstituteStudentUserGroupsCountAggregateOutputType = {
    userGroupId: number
    default: number
    name: number
    updated: number
    instituteId: number
    _all: number
  }


  export type InstituteStudentUserGroupsMinAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    instituteId?: true
  }

  export type InstituteStudentUserGroupsMaxAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    instituteId?: true
  }

  export type InstituteStudentUserGroupsCountAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    instituteId?: true
    _all?: true
  }

  export type InstituteStudentUserGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStudentUserGroups to aggregate.
     */
    where?: InstituteStudentUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudentUserGroups to fetch.
     */
    orderBy?: InstituteStudentUserGroupsOrderByWithRelationInput | InstituteStudentUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteStudentUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudentUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudentUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstituteStudentUserGroups
    **/
    _count?: true | InstituteStudentUserGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteStudentUserGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteStudentUserGroupsMaxAggregateInputType
  }

  export type GetInstituteStudentUserGroupsAggregateType<T extends InstituteStudentUserGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstituteStudentUserGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstituteStudentUserGroups[P]>
      : GetScalarType<T[P], AggregateInstituteStudentUserGroups[P]>
  }




  export type InstituteStudentUserGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStudentUserGroupsWhereInput
    orderBy?: InstituteStudentUserGroupsOrderByWithAggregationInput | InstituteStudentUserGroupsOrderByWithAggregationInput[]
    by: InstituteStudentUserGroupsScalarFieldEnum[] | InstituteStudentUserGroupsScalarFieldEnum
    having?: InstituteStudentUserGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteStudentUserGroupsCountAggregateInputType | true
    _min?: InstituteStudentUserGroupsMinAggregateInputType
    _max?: InstituteStudentUserGroupsMaxAggregateInputType
  }

  export type InstituteStudentUserGroupsGroupByOutputType = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
    _count: InstituteStudentUserGroupsCountAggregateOutputType | null
    _min: InstituteStudentUserGroupsMinAggregateOutputType | null
    _max: InstituteStudentUserGroupsMaxAggregateOutputType | null
  }

  type GetInstituteStudentUserGroupsGroupByPayload<T extends InstituteStudentUserGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteStudentUserGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteStudentUserGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteStudentUserGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteStudentUserGroupsGroupByOutputType[P]>
        }
      >
    >


  export type InstituteStudentUserGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userGroupId?: boolean
    default?: boolean
    name?: boolean
    updated?: boolean
    instituteId?: boolean
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    InstituteStudents?: boolean | InstituteStudentUserGroups$InstituteStudentsArgs<ExtArgs>
    Placements?: boolean | InstituteStudentUserGroups$PlacementsArgs<ExtArgs>
    _count?: boolean | InstituteStudentUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instituteStudentUserGroups"]>

  export type InstituteStudentUserGroupsSelectScalar = {
    userGroupId?: boolean
    default?: boolean
    name?: boolean
    updated?: boolean
    instituteId?: boolean
  }

  export type InstituteStudentUserGroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    InstituteStudents?: boolean | InstituteStudentUserGroups$InstituteStudentsArgs<ExtArgs>
    Placements?: boolean | InstituteStudentUserGroups$PlacementsArgs<ExtArgs>
    _count?: boolean | InstituteStudentUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InstituteStudentUserGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstituteStudentUserGroups"
    objects: {
      institute: Prisma.$InstitutesPayload<ExtArgs>
      InstituteStudents: Prisma.$InstituteStudentsPayload<ExtArgs>[]
      Placements: Prisma.$PlacementsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userGroupId: string
      default: boolean
      name: string
      updated: string
      instituteId: string
    }, ExtArgs["result"]["instituteStudentUserGroups"]>
    composites: {}
  }


  type InstituteStudentUserGroupsGetPayload<S extends boolean | null | undefined | InstituteStudentUserGroupsDefaultArgs> = $Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload, S>

  type InstituteStudentUserGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstituteStudentUserGroupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstituteStudentUserGroupsCountAggregateInputType | true
    }

  export interface InstituteStudentUserGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstituteStudentUserGroups'], meta: { name: 'InstituteStudentUserGroups' } }
    /**
     * Find zero or one InstituteStudentUserGroups that matches the filter.
     * @param {InstituteStudentUserGroupsFindUniqueArgs} args - Arguments to find a InstituteStudentUserGroups
     * @example
     * // Get one InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstituteStudentUserGroupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentUserGroupsFindUniqueArgs<ExtArgs>>
    ): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InstituteStudentUserGroups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstituteStudentUserGroupsFindUniqueOrThrowArgs} args - Arguments to find a InstituteStudentUserGroups
     * @example
     * // Get one InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstituteStudentUserGroupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentUserGroupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InstituteStudentUserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentUserGroupsFindFirstArgs} args - Arguments to find a InstituteStudentUserGroups
     * @example
     * // Get one InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstituteStudentUserGroupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentUserGroupsFindFirstArgs<ExtArgs>>
    ): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InstituteStudentUserGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentUserGroupsFindFirstOrThrowArgs} args - Arguments to find a InstituteStudentUserGroups
     * @example
     * // Get one InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstituteStudentUserGroupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentUserGroupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InstituteStudentUserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentUserGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.findMany()
     * 
     * // Get first 10 InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.findMany({ take: 10 })
     * 
     * // Only select the `userGroupId`
     * const instituteStudentUserGroupsWithUserGroupIdOnly = await prisma.instituteStudentUserGroups.findMany({ select: { userGroupId: true } })
     * 
    **/
    findMany<T extends InstituteStudentUserGroupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentUserGroupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InstituteStudentUserGroups.
     * @param {InstituteStudentUserGroupsCreateArgs} args - Arguments to create a InstituteStudentUserGroups.
     * @example
     * // Create one InstituteStudentUserGroups
     * const InstituteStudentUserGroups = await prisma.instituteStudentUserGroups.create({
     *   data: {
     *     // ... data to create a InstituteStudentUserGroups
     *   }
     * })
     * 
    **/
    create<T extends InstituteStudentUserGroupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentUserGroupsCreateArgs<ExtArgs>>
    ): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InstituteStudentUserGroups.
     *     @param {InstituteStudentUserGroupsCreateManyArgs} args - Arguments to create many InstituteStudentUserGroups.
     *     @example
     *     // Create many InstituteStudentUserGroups
     *     const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstituteStudentUserGroupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentUserGroupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InstituteStudentUserGroups.
     * @param {InstituteStudentUserGroupsDeleteArgs} args - Arguments to delete one InstituteStudentUserGroups.
     * @example
     * // Delete one InstituteStudentUserGroups
     * const InstituteStudentUserGroups = await prisma.instituteStudentUserGroups.delete({
     *   where: {
     *     // ... filter to delete one InstituteStudentUserGroups
     *   }
     * })
     * 
    **/
    delete<T extends InstituteStudentUserGroupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentUserGroupsDeleteArgs<ExtArgs>>
    ): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InstituteStudentUserGroups.
     * @param {InstituteStudentUserGroupsUpdateArgs} args - Arguments to update one InstituteStudentUserGroups.
     * @example
     * // Update one InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstituteStudentUserGroupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentUserGroupsUpdateArgs<ExtArgs>>
    ): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InstituteStudentUserGroups.
     * @param {InstituteStudentUserGroupsDeleteManyArgs} args - Arguments to filter InstituteStudentUserGroups to delete.
     * @example
     * // Delete a few InstituteStudentUserGroups
     * const { count } = await prisma.instituteStudentUserGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstituteStudentUserGroupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentUserGroupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstituteStudentUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentUserGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstituteStudentUserGroupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentUserGroupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstituteStudentUserGroups.
     * @param {InstituteStudentUserGroupsUpsertArgs} args - Arguments to update or create a InstituteStudentUserGroups.
     * @example
     * // Update or create a InstituteStudentUserGroups
     * const instituteStudentUserGroups = await prisma.instituteStudentUserGroups.upsert({
     *   create: {
     *     // ... data to create a InstituteStudentUserGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstituteStudentUserGroups we want to update
     *   }
     * })
    **/
    upsert<T extends InstituteStudentUserGroupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentUserGroupsUpsertArgs<ExtArgs>>
    ): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InstituteStudentUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentUserGroupsCountArgs} args - Arguments to filter InstituteStudentUserGroups to count.
     * @example
     * // Count the number of InstituteStudentUserGroups
     * const count = await prisma.instituteStudentUserGroups.count({
     *   where: {
     *     // ... the filter for the InstituteStudentUserGroups we want to count
     *   }
     * })
    **/
    count<T extends InstituteStudentUserGroupsCountArgs>(
      args?: Subset<T, InstituteStudentUserGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteStudentUserGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstituteStudentUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentUserGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteStudentUserGroupsAggregateArgs>(args: Subset<T, InstituteStudentUserGroupsAggregateArgs>): Prisma.PrismaPromise<GetInstituteStudentUserGroupsAggregateType<T>>

    /**
     * Group by InstituteStudentUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentUserGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteStudentUserGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteStudentUserGroupsGroupByArgs['orderBy'] }
        : { orderBy?: InstituteStudentUserGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteStudentUserGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteStudentUserGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstituteStudentUserGroups model
   */
  readonly fields: InstituteStudentUserGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstituteStudentUserGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteStudentUserGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    institute<T extends InstitutesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutesDefaultArgs<ExtArgs>>): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    InstituteStudents<T extends InstituteStudentUserGroups$InstituteStudentsArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStudentUserGroups$InstituteStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Placements<T extends InstituteStudentUserGroups$PlacementsArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStudentUserGroups$PlacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InstituteStudentUserGroups model
   */ 
  interface InstituteStudentUserGroupsFieldRefs {
    readonly userGroupId: FieldRef<"InstituteStudentUserGroups", 'String'>
    readonly default: FieldRef<"InstituteStudentUserGroups", 'Boolean'>
    readonly name: FieldRef<"InstituteStudentUserGroups", 'String'>
    readonly updated: FieldRef<"InstituteStudentUserGroups", 'String'>
    readonly instituteId: FieldRef<"InstituteStudentUserGroups", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InstituteStudentUserGroups findUnique
   */
  export type InstituteStudentUserGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudentUserGroups to fetch.
     */
    where: InstituteStudentUserGroupsWhereUniqueInput
  }


  /**
   * InstituteStudentUserGroups findUniqueOrThrow
   */
  export type InstituteStudentUserGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudentUserGroups to fetch.
     */
    where: InstituteStudentUserGroupsWhereUniqueInput
  }


  /**
   * InstituteStudentUserGroups findFirst
   */
  export type InstituteStudentUserGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudentUserGroups to fetch.
     */
    where?: InstituteStudentUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudentUserGroups to fetch.
     */
    orderBy?: InstituteStudentUserGroupsOrderByWithRelationInput | InstituteStudentUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStudentUserGroups.
     */
    cursor?: InstituteStudentUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudentUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudentUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStudentUserGroups.
     */
    distinct?: InstituteStudentUserGroupsScalarFieldEnum | InstituteStudentUserGroupsScalarFieldEnum[]
  }


  /**
   * InstituteStudentUserGroups findFirstOrThrow
   */
  export type InstituteStudentUserGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudentUserGroups to fetch.
     */
    where?: InstituteStudentUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudentUserGroups to fetch.
     */
    orderBy?: InstituteStudentUserGroupsOrderByWithRelationInput | InstituteStudentUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStudentUserGroups.
     */
    cursor?: InstituteStudentUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudentUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudentUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStudentUserGroups.
     */
    distinct?: InstituteStudentUserGroupsScalarFieldEnum | InstituteStudentUserGroupsScalarFieldEnum[]
  }


  /**
   * InstituteStudentUserGroups findMany
   */
  export type InstituteStudentUserGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudentUserGroups to fetch.
     */
    where?: InstituteStudentUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudentUserGroups to fetch.
     */
    orderBy?: InstituteStudentUserGroupsOrderByWithRelationInput | InstituteStudentUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstituteStudentUserGroups.
     */
    cursor?: InstituteStudentUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudentUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudentUserGroups.
     */
    skip?: number
    distinct?: InstituteStudentUserGroupsScalarFieldEnum | InstituteStudentUserGroupsScalarFieldEnum[]
  }


  /**
   * InstituteStudentUserGroups create
   */
  export type InstituteStudentUserGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a InstituteStudentUserGroups.
     */
    data: XOR<InstituteStudentUserGroupsCreateInput, InstituteStudentUserGroupsUncheckedCreateInput>
  }


  /**
   * InstituteStudentUserGroups createMany
   */
  export type InstituteStudentUserGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstituteStudentUserGroups.
     */
    data: InstituteStudentUserGroupsCreateManyInput | InstituteStudentUserGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InstituteStudentUserGroups update
   */
  export type InstituteStudentUserGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a InstituteStudentUserGroups.
     */
    data: XOR<InstituteStudentUserGroupsUpdateInput, InstituteStudentUserGroupsUncheckedUpdateInput>
    /**
     * Choose, which InstituteStudentUserGroups to update.
     */
    where: InstituteStudentUserGroupsWhereUniqueInput
  }


  /**
   * InstituteStudentUserGroups updateMany
   */
  export type InstituteStudentUserGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstituteStudentUserGroups.
     */
    data: XOR<InstituteStudentUserGroupsUpdateManyMutationInput, InstituteStudentUserGroupsUncheckedUpdateManyInput>
    /**
     * Filter which InstituteStudentUserGroups to update
     */
    where?: InstituteStudentUserGroupsWhereInput
  }


  /**
   * InstituteStudentUserGroups upsert
   */
  export type InstituteStudentUserGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the InstituteStudentUserGroups to update in case it exists.
     */
    where: InstituteStudentUserGroupsWhereUniqueInput
    /**
     * In case the InstituteStudentUserGroups found by the `where` argument doesn't exist, create a new InstituteStudentUserGroups with this data.
     */
    create: XOR<InstituteStudentUserGroupsCreateInput, InstituteStudentUserGroupsUncheckedCreateInput>
    /**
     * In case the InstituteStudentUserGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteStudentUserGroupsUpdateInput, InstituteStudentUserGroupsUncheckedUpdateInput>
  }


  /**
   * InstituteStudentUserGroups delete
   */
  export type InstituteStudentUserGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
    /**
     * Filter which InstituteStudentUserGroups to delete.
     */
    where: InstituteStudentUserGroupsWhereUniqueInput
  }


  /**
   * InstituteStudentUserGroups deleteMany
   */
  export type InstituteStudentUserGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStudentUserGroups to delete
     */
    where?: InstituteStudentUserGroupsWhereInput
  }


  /**
   * InstituteStudentUserGroups.InstituteStudents
   */
  export type InstituteStudentUserGroups$InstituteStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    where?: InstituteStudentsWhereInput
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    cursor?: InstituteStudentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * InstituteStudentUserGroups.Placements
   */
  export type InstituteStudentUserGroups$PlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    where?: PlacementsWhereInput
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    cursor?: PlacementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * InstituteStudentUserGroups without action
   */
  export type InstituteStudentUserGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudentUserGroups
     */
    select?: InstituteStudentUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentUserGroupsInclude<ExtArgs> | null
  }



  /**
   * Model InstituteStaffUserGroups
   */

  export type AggregateInstituteStaffUserGroups = {
    _count: InstituteStaffUserGroupsCountAggregateOutputType | null
    _min: InstituteStaffUserGroupsMinAggregateOutputType | null
    _max: InstituteStaffUserGroupsMaxAggregateOutputType | null
  }

  export type InstituteStaffUserGroupsMinAggregateOutputType = {
    userGroupId: string | null
    default: boolean | null
    name: string | null
    updated: string | null
    instituteId: string | null
  }

  export type InstituteStaffUserGroupsMaxAggregateOutputType = {
    userGroupId: string | null
    default: boolean | null
    name: string | null
    updated: string | null
    instituteId: string | null
  }

  export type InstituteStaffUserGroupsCountAggregateOutputType = {
    userGroupId: number
    default: number
    name: number
    updated: number
    instituteId: number
    _all: number
  }


  export type InstituteStaffUserGroupsMinAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    instituteId?: true
  }

  export type InstituteStaffUserGroupsMaxAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    instituteId?: true
  }

  export type InstituteStaffUserGroupsCountAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    instituteId?: true
    _all?: true
  }

  export type InstituteStaffUserGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStaffUserGroups to aggregate.
     */
    where?: InstituteStaffUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffUserGroups to fetch.
     */
    orderBy?: InstituteStaffUserGroupsOrderByWithRelationInput | InstituteStaffUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteStaffUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstituteStaffUserGroups
    **/
    _count?: true | InstituteStaffUserGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteStaffUserGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteStaffUserGroupsMaxAggregateInputType
  }

  export type GetInstituteStaffUserGroupsAggregateType<T extends InstituteStaffUserGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstituteStaffUserGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstituteStaffUserGroups[P]>
      : GetScalarType<T[P], AggregateInstituteStaffUserGroups[P]>
  }




  export type InstituteStaffUserGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStaffUserGroupsWhereInput
    orderBy?: InstituteStaffUserGroupsOrderByWithAggregationInput | InstituteStaffUserGroupsOrderByWithAggregationInput[]
    by: InstituteStaffUserGroupsScalarFieldEnum[] | InstituteStaffUserGroupsScalarFieldEnum
    having?: InstituteStaffUserGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteStaffUserGroupsCountAggregateInputType | true
    _min?: InstituteStaffUserGroupsMinAggregateInputType
    _max?: InstituteStaffUserGroupsMaxAggregateInputType
  }

  export type InstituteStaffUserGroupsGroupByOutputType = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
    _count: InstituteStaffUserGroupsCountAggregateOutputType | null
    _min: InstituteStaffUserGroupsMinAggregateOutputType | null
    _max: InstituteStaffUserGroupsMaxAggregateOutputType | null
  }

  type GetInstituteStaffUserGroupsGroupByPayload<T extends InstituteStaffUserGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteStaffUserGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteStaffUserGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteStaffUserGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteStaffUserGroupsGroupByOutputType[P]>
        }
      >
    >


  export type InstituteStaffUserGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userGroupId?: boolean
    default?: boolean
    name?: boolean
    updated?: boolean
    instituteId?: boolean
    InstituteStaff?: boolean | InstituteStaffUserGroups$InstituteStaffArgs<ExtArgs>
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    _count?: boolean | InstituteStaffUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instituteStaffUserGroups"]>

  export type InstituteStaffUserGroupsSelectScalar = {
    userGroupId?: boolean
    default?: boolean
    name?: boolean
    updated?: boolean
    instituteId?: boolean
  }

  export type InstituteStaffUserGroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InstituteStaff?: boolean | InstituteStaffUserGroups$InstituteStaffArgs<ExtArgs>
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    _count?: boolean | InstituteStaffUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InstituteStaffUserGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstituteStaffUserGroups"
    objects: {
      InstituteStaff: Prisma.$InstituteStaffPayload<ExtArgs>[]
      institute: Prisma.$InstitutesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userGroupId: string
      default: boolean
      name: string
      updated: string
      instituteId: string
    }, ExtArgs["result"]["instituteStaffUserGroups"]>
    composites: {}
  }


  type InstituteStaffUserGroupsGetPayload<S extends boolean | null | undefined | InstituteStaffUserGroupsDefaultArgs> = $Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload, S>

  type InstituteStaffUserGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstituteStaffUserGroupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstituteStaffUserGroupsCountAggregateInputType | true
    }

  export interface InstituteStaffUserGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstituteStaffUserGroups'], meta: { name: 'InstituteStaffUserGroups' } }
    /**
     * Find zero or one InstituteStaffUserGroups that matches the filter.
     * @param {InstituteStaffUserGroupsFindUniqueArgs} args - Arguments to find a InstituteStaffUserGroups
     * @example
     * // Get one InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstituteStaffUserGroupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUserGroupsFindUniqueArgs<ExtArgs>>
    ): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InstituteStaffUserGroups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstituteStaffUserGroupsFindUniqueOrThrowArgs} args - Arguments to find a InstituteStaffUserGroups
     * @example
     * // Get one InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstituteStaffUserGroupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffUserGroupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InstituteStaffUserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUserGroupsFindFirstArgs} args - Arguments to find a InstituteStaffUserGroups
     * @example
     * // Get one InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstituteStaffUserGroupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffUserGroupsFindFirstArgs<ExtArgs>>
    ): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InstituteStaffUserGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUserGroupsFindFirstOrThrowArgs} args - Arguments to find a InstituteStaffUserGroups
     * @example
     * // Get one InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstituteStaffUserGroupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffUserGroupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InstituteStaffUserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUserGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.findMany()
     * 
     * // Get first 10 InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.findMany({ take: 10 })
     * 
     * // Only select the `userGroupId`
     * const instituteStaffUserGroupsWithUserGroupIdOnly = await prisma.instituteStaffUserGroups.findMany({ select: { userGroupId: true } })
     * 
    **/
    findMany<T extends InstituteStaffUserGroupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffUserGroupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InstituteStaffUserGroups.
     * @param {InstituteStaffUserGroupsCreateArgs} args - Arguments to create a InstituteStaffUserGroups.
     * @example
     * // Create one InstituteStaffUserGroups
     * const InstituteStaffUserGroups = await prisma.instituteStaffUserGroups.create({
     *   data: {
     *     // ... data to create a InstituteStaffUserGroups
     *   }
     * })
     * 
    **/
    create<T extends InstituteStaffUserGroupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUserGroupsCreateArgs<ExtArgs>>
    ): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InstituteStaffUserGroups.
     *     @param {InstituteStaffUserGroupsCreateManyArgs} args - Arguments to create many InstituteStaffUserGroups.
     *     @example
     *     // Create many InstituteStaffUserGroups
     *     const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstituteStaffUserGroupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffUserGroupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InstituteStaffUserGroups.
     * @param {InstituteStaffUserGroupsDeleteArgs} args - Arguments to delete one InstituteStaffUserGroups.
     * @example
     * // Delete one InstituteStaffUserGroups
     * const InstituteStaffUserGroups = await prisma.instituteStaffUserGroups.delete({
     *   where: {
     *     // ... filter to delete one InstituteStaffUserGroups
     *   }
     * })
     * 
    **/
    delete<T extends InstituteStaffUserGroupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUserGroupsDeleteArgs<ExtArgs>>
    ): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InstituteStaffUserGroups.
     * @param {InstituteStaffUserGroupsUpdateArgs} args - Arguments to update one InstituteStaffUserGroups.
     * @example
     * // Update one InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstituteStaffUserGroupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUserGroupsUpdateArgs<ExtArgs>>
    ): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InstituteStaffUserGroups.
     * @param {InstituteStaffUserGroupsDeleteManyArgs} args - Arguments to filter InstituteStaffUserGroups to delete.
     * @example
     * // Delete a few InstituteStaffUserGroups
     * const { count } = await prisma.instituteStaffUserGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstituteStaffUserGroupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffUserGroupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstituteStaffUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUserGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstituteStaffUserGroupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUserGroupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstituteStaffUserGroups.
     * @param {InstituteStaffUserGroupsUpsertArgs} args - Arguments to update or create a InstituteStaffUserGroups.
     * @example
     * // Update or create a InstituteStaffUserGroups
     * const instituteStaffUserGroups = await prisma.instituteStaffUserGroups.upsert({
     *   create: {
     *     // ... data to create a InstituteStaffUserGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstituteStaffUserGroups we want to update
     *   }
     * })
    **/
    upsert<T extends InstituteStaffUserGroupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUserGroupsUpsertArgs<ExtArgs>>
    ): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InstituteStaffUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUserGroupsCountArgs} args - Arguments to filter InstituteStaffUserGroups to count.
     * @example
     * // Count the number of InstituteStaffUserGroups
     * const count = await prisma.instituteStaffUserGroups.count({
     *   where: {
     *     // ... the filter for the InstituteStaffUserGroups we want to count
     *   }
     * })
    **/
    count<T extends InstituteStaffUserGroupsCountArgs>(
      args?: Subset<T, InstituteStaffUserGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteStaffUserGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstituteStaffUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUserGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteStaffUserGroupsAggregateArgs>(args: Subset<T, InstituteStaffUserGroupsAggregateArgs>): Prisma.PrismaPromise<GetInstituteStaffUserGroupsAggregateType<T>>

    /**
     * Group by InstituteStaffUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUserGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteStaffUserGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteStaffUserGroupsGroupByArgs['orderBy'] }
        : { orderBy?: InstituteStaffUserGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteStaffUserGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteStaffUserGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstituteStaffUserGroups model
   */
  readonly fields: InstituteStaffUserGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstituteStaffUserGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteStaffUserGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    InstituteStaff<T extends InstituteStaffUserGroups$InstituteStaffArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStaffUserGroups$InstituteStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findMany'> | Null>;

    institute<T extends InstitutesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutesDefaultArgs<ExtArgs>>): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InstituteStaffUserGroups model
   */ 
  interface InstituteStaffUserGroupsFieldRefs {
    readonly userGroupId: FieldRef<"InstituteStaffUserGroups", 'String'>
    readonly default: FieldRef<"InstituteStaffUserGroups", 'Boolean'>
    readonly name: FieldRef<"InstituteStaffUserGroups", 'String'>
    readonly updated: FieldRef<"InstituteStaffUserGroups", 'String'>
    readonly instituteId: FieldRef<"InstituteStaffUserGroups", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InstituteStaffUserGroups findUnique
   */
  export type InstituteStaffUserGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaffUserGroups to fetch.
     */
    where: InstituteStaffUserGroupsWhereUniqueInput
  }


  /**
   * InstituteStaffUserGroups findUniqueOrThrow
   */
  export type InstituteStaffUserGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaffUserGroups to fetch.
     */
    where: InstituteStaffUserGroupsWhereUniqueInput
  }


  /**
   * InstituteStaffUserGroups findFirst
   */
  export type InstituteStaffUserGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaffUserGroups to fetch.
     */
    where?: InstituteStaffUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffUserGroups to fetch.
     */
    orderBy?: InstituteStaffUserGroupsOrderByWithRelationInput | InstituteStaffUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStaffUserGroups.
     */
    cursor?: InstituteStaffUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStaffUserGroups.
     */
    distinct?: InstituteStaffUserGroupsScalarFieldEnum | InstituteStaffUserGroupsScalarFieldEnum[]
  }


  /**
   * InstituteStaffUserGroups findFirstOrThrow
   */
  export type InstituteStaffUserGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaffUserGroups to fetch.
     */
    where?: InstituteStaffUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffUserGroups to fetch.
     */
    orderBy?: InstituteStaffUserGroupsOrderByWithRelationInput | InstituteStaffUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStaffUserGroups.
     */
    cursor?: InstituteStaffUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStaffUserGroups.
     */
    distinct?: InstituteStaffUserGroupsScalarFieldEnum | InstituteStaffUserGroupsScalarFieldEnum[]
  }


  /**
   * InstituteStaffUserGroups findMany
   */
  export type InstituteStaffUserGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaffUserGroups to fetch.
     */
    where?: InstituteStaffUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffUserGroups to fetch.
     */
    orderBy?: InstituteStaffUserGroupsOrderByWithRelationInput | InstituteStaffUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstituteStaffUserGroups.
     */
    cursor?: InstituteStaffUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffUserGroups.
     */
    skip?: number
    distinct?: InstituteStaffUserGroupsScalarFieldEnum | InstituteStaffUserGroupsScalarFieldEnum[]
  }


  /**
   * InstituteStaffUserGroups create
   */
  export type InstituteStaffUserGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a InstituteStaffUserGroups.
     */
    data: XOR<InstituteStaffUserGroupsCreateInput, InstituteStaffUserGroupsUncheckedCreateInput>
  }


  /**
   * InstituteStaffUserGroups createMany
   */
  export type InstituteStaffUserGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstituteStaffUserGroups.
     */
    data: InstituteStaffUserGroupsCreateManyInput | InstituteStaffUserGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InstituteStaffUserGroups update
   */
  export type InstituteStaffUserGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a InstituteStaffUserGroups.
     */
    data: XOR<InstituteStaffUserGroupsUpdateInput, InstituteStaffUserGroupsUncheckedUpdateInput>
    /**
     * Choose, which InstituteStaffUserGroups to update.
     */
    where: InstituteStaffUserGroupsWhereUniqueInput
  }


  /**
   * InstituteStaffUserGroups updateMany
   */
  export type InstituteStaffUserGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstituteStaffUserGroups.
     */
    data: XOR<InstituteStaffUserGroupsUpdateManyMutationInput, InstituteStaffUserGroupsUncheckedUpdateManyInput>
    /**
     * Filter which InstituteStaffUserGroups to update
     */
    where?: InstituteStaffUserGroupsWhereInput
  }


  /**
   * InstituteStaffUserGroups upsert
   */
  export type InstituteStaffUserGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the InstituteStaffUserGroups to update in case it exists.
     */
    where: InstituteStaffUserGroupsWhereUniqueInput
    /**
     * In case the InstituteStaffUserGroups found by the `where` argument doesn't exist, create a new InstituteStaffUserGroups with this data.
     */
    create: XOR<InstituteStaffUserGroupsCreateInput, InstituteStaffUserGroupsUncheckedCreateInput>
    /**
     * In case the InstituteStaffUserGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteStaffUserGroupsUpdateInput, InstituteStaffUserGroupsUncheckedUpdateInput>
  }


  /**
   * InstituteStaffUserGroups delete
   */
  export type InstituteStaffUserGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
    /**
     * Filter which InstituteStaffUserGroups to delete.
     */
    where: InstituteStaffUserGroupsWhereUniqueInput
  }


  /**
   * InstituteStaffUserGroups deleteMany
   */
  export type InstituteStaffUserGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStaffUserGroups to delete
     */
    where?: InstituteStaffUserGroupsWhereInput
  }


  /**
   * InstituteStaffUserGroups.InstituteStaff
   */
  export type InstituteStaffUserGroups$InstituteStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    where?: InstituteStaffWhereInput
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    cursor?: InstituteStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstituteStaffScalarFieldEnum | InstituteStaffScalarFieldEnum[]
  }


  /**
   * InstituteStaffUserGroups without action
   */
  export type InstituteStaffUserGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaffUserGroups
     */
    select?: InstituteStaffUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffUserGroupsInclude<ExtArgs> | null
  }



  /**
   * Model ProviderUserGroups
   */

  export type AggregateProviderUserGroups = {
    _count: ProviderUserGroupsCountAggregateOutputType | null
    _min: ProviderUserGroupsMinAggregateOutputType | null
    _max: ProviderUserGroupsMaxAggregateOutputType | null
  }

  export type ProviderUserGroupsMinAggregateOutputType = {
    userGroupId: string | null
    default: boolean | null
    name: string | null
    updated: string | null
    providerId: string | null
  }

  export type ProviderUserGroupsMaxAggregateOutputType = {
    userGroupId: string | null
    default: boolean | null
    name: string | null
    updated: string | null
    providerId: string | null
  }

  export type ProviderUserGroupsCountAggregateOutputType = {
    userGroupId: number
    default: number
    name: number
    updated: number
    providerId: number
    _all: number
  }


  export type ProviderUserGroupsMinAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    providerId?: true
  }

  export type ProviderUserGroupsMaxAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    providerId?: true
  }

  export type ProviderUserGroupsCountAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    updated?: true
    providerId?: true
    _all?: true
  }

  export type ProviderUserGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderUserGroups to aggregate.
     */
    where?: ProviderUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderUserGroups to fetch.
     */
    orderBy?: ProviderUserGroupsOrderByWithRelationInput | ProviderUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderUserGroups
    **/
    _count?: true | ProviderUserGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderUserGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderUserGroupsMaxAggregateInputType
  }

  export type GetProviderUserGroupsAggregateType<T extends ProviderUserGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderUserGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderUserGroups[P]>
      : GetScalarType<T[P], AggregateProviderUserGroups[P]>
  }




  export type ProviderUserGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderUserGroupsWhereInput
    orderBy?: ProviderUserGroupsOrderByWithAggregationInput | ProviderUserGroupsOrderByWithAggregationInput[]
    by: ProviderUserGroupsScalarFieldEnum[] | ProviderUserGroupsScalarFieldEnum
    having?: ProviderUserGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderUserGroupsCountAggregateInputType | true
    _min?: ProviderUserGroupsMinAggregateInputType
    _max?: ProviderUserGroupsMaxAggregateInputType
  }

  export type ProviderUserGroupsGroupByOutputType = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    providerId: string
    _count: ProviderUserGroupsCountAggregateOutputType | null
    _min: ProviderUserGroupsMinAggregateOutputType | null
    _max: ProviderUserGroupsMaxAggregateOutputType | null
  }

  type GetProviderUserGroupsGroupByPayload<T extends ProviderUserGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderUserGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderUserGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderUserGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderUserGroupsGroupByOutputType[P]>
        }
      >
    >


  export type ProviderUserGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userGroupId?: boolean
    default?: boolean
    name?: boolean
    updated?: boolean
    providerId?: boolean
    ProviderStaff?: boolean | ProviderUserGroups$ProviderStaffArgs<ExtArgs>
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
    _count?: boolean | ProviderUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerUserGroups"]>

  export type ProviderUserGroupsSelectScalar = {
    userGroupId?: boolean
    default?: boolean
    name?: boolean
    updated?: boolean
    providerId?: boolean
  }

  export type ProviderUserGroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProviderStaff?: boolean | ProviderUserGroups$ProviderStaffArgs<ExtArgs>
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
    _count?: boolean | ProviderUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProviderUserGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderUserGroups"
    objects: {
      ProviderStaff: Prisma.$ProviderStaffPayload<ExtArgs>[]
      provider: Prisma.$ProvidersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userGroupId: string
      default: boolean
      name: string
      updated: string
      providerId: string
    }, ExtArgs["result"]["providerUserGroups"]>
    composites: {}
  }


  type ProviderUserGroupsGetPayload<S extends boolean | null | undefined | ProviderUserGroupsDefaultArgs> = $Result.GetResult<Prisma.$ProviderUserGroupsPayload, S>

  type ProviderUserGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProviderUserGroupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProviderUserGroupsCountAggregateInputType | true
    }

  export interface ProviderUserGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderUserGroups'], meta: { name: 'ProviderUserGroups' } }
    /**
     * Find zero or one ProviderUserGroups that matches the filter.
     * @param {ProviderUserGroupsFindUniqueArgs} args - Arguments to find a ProviderUserGroups
     * @example
     * // Get one ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderUserGroupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUserGroupsFindUniqueArgs<ExtArgs>>
    ): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProviderUserGroups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProviderUserGroupsFindUniqueOrThrowArgs} args - Arguments to find a ProviderUserGroups
     * @example
     * // Get one ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProviderUserGroupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderUserGroupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProviderUserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUserGroupsFindFirstArgs} args - Arguments to find a ProviderUserGroups
     * @example
     * // Get one ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderUserGroupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderUserGroupsFindFirstArgs<ExtArgs>>
    ): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProviderUserGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUserGroupsFindFirstOrThrowArgs} args - Arguments to find a ProviderUserGroups
     * @example
     * // Get one ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProviderUserGroupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderUserGroupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProviderUserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUserGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.findMany()
     * 
     * // Get first 10 ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.findMany({ take: 10 })
     * 
     * // Only select the `userGroupId`
     * const providerUserGroupsWithUserGroupIdOnly = await prisma.providerUserGroups.findMany({ select: { userGroupId: true } })
     * 
    **/
    findMany<T extends ProviderUserGroupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderUserGroupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProviderUserGroups.
     * @param {ProviderUserGroupsCreateArgs} args - Arguments to create a ProviderUserGroups.
     * @example
     * // Create one ProviderUserGroups
     * const ProviderUserGroups = await prisma.providerUserGroups.create({
     *   data: {
     *     // ... data to create a ProviderUserGroups
     *   }
     * })
     * 
    **/
    create<T extends ProviderUserGroupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUserGroupsCreateArgs<ExtArgs>>
    ): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProviderUserGroups.
     *     @param {ProviderUserGroupsCreateManyArgs} args - Arguments to create many ProviderUserGroups.
     *     @example
     *     // Create many ProviderUserGroups
     *     const providerUserGroups = await prisma.providerUserGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProviderUserGroupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderUserGroupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProviderUserGroups.
     * @param {ProviderUserGroupsDeleteArgs} args - Arguments to delete one ProviderUserGroups.
     * @example
     * // Delete one ProviderUserGroups
     * const ProviderUserGroups = await prisma.providerUserGroups.delete({
     *   where: {
     *     // ... filter to delete one ProviderUserGroups
     *   }
     * })
     * 
    **/
    delete<T extends ProviderUserGroupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUserGroupsDeleteArgs<ExtArgs>>
    ): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProviderUserGroups.
     * @param {ProviderUserGroupsUpdateArgs} args - Arguments to update one ProviderUserGroups.
     * @example
     * // Update one ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderUserGroupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUserGroupsUpdateArgs<ExtArgs>>
    ): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProviderUserGroups.
     * @param {ProviderUserGroupsDeleteManyArgs} args - Arguments to filter ProviderUserGroups to delete.
     * @example
     * // Delete a few ProviderUserGroups
     * const { count } = await prisma.providerUserGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderUserGroupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderUserGroupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUserGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderUserGroupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUserGroupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProviderUserGroups.
     * @param {ProviderUserGroupsUpsertArgs} args - Arguments to update or create a ProviderUserGroups.
     * @example
     * // Update or create a ProviderUserGroups
     * const providerUserGroups = await prisma.providerUserGroups.upsert({
     *   create: {
     *     // ... data to create a ProviderUserGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderUserGroups we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderUserGroupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUserGroupsUpsertArgs<ExtArgs>>
    ): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProviderUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUserGroupsCountArgs} args - Arguments to filter ProviderUserGroups to count.
     * @example
     * // Count the number of ProviderUserGroups
     * const count = await prisma.providerUserGroups.count({
     *   where: {
     *     // ... the filter for the ProviderUserGroups we want to count
     *   }
     * })
    **/
    count<T extends ProviderUserGroupsCountArgs>(
      args?: Subset<T, ProviderUserGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderUserGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUserGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderUserGroupsAggregateArgs>(args: Subset<T, ProviderUserGroupsAggregateArgs>): Prisma.PrismaPromise<GetProviderUserGroupsAggregateType<T>>

    /**
     * Group by ProviderUserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUserGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderUserGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderUserGroupsGroupByArgs['orderBy'] }
        : { orderBy?: ProviderUserGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderUserGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderUserGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderUserGroups model
   */
  readonly fields: ProviderUserGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderUserGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderUserGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ProviderStaff<T extends ProviderUserGroups$ProviderStaffArgs<ExtArgs> = {}>(args?: Subset<T, ProviderUserGroups$ProviderStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findMany'> | Null>;

    provider<T extends ProvidersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvidersDefaultArgs<ExtArgs>>): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProviderUserGroups model
   */ 
  interface ProviderUserGroupsFieldRefs {
    readonly userGroupId: FieldRef<"ProviderUserGroups", 'String'>
    readonly default: FieldRef<"ProviderUserGroups", 'Boolean'>
    readonly name: FieldRef<"ProviderUserGroups", 'String'>
    readonly updated: FieldRef<"ProviderUserGroups", 'String'>
    readonly providerId: FieldRef<"ProviderUserGroups", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ProviderUserGroups findUnique
   */
  export type ProviderUserGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderUserGroups to fetch.
     */
    where: ProviderUserGroupsWhereUniqueInput
  }


  /**
   * ProviderUserGroups findUniqueOrThrow
   */
  export type ProviderUserGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderUserGroups to fetch.
     */
    where: ProviderUserGroupsWhereUniqueInput
  }


  /**
   * ProviderUserGroups findFirst
   */
  export type ProviderUserGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderUserGroups to fetch.
     */
    where?: ProviderUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderUserGroups to fetch.
     */
    orderBy?: ProviderUserGroupsOrderByWithRelationInput | ProviderUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderUserGroups.
     */
    cursor?: ProviderUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderUserGroups.
     */
    distinct?: ProviderUserGroupsScalarFieldEnum | ProviderUserGroupsScalarFieldEnum[]
  }


  /**
   * ProviderUserGroups findFirstOrThrow
   */
  export type ProviderUserGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderUserGroups to fetch.
     */
    where?: ProviderUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderUserGroups to fetch.
     */
    orderBy?: ProviderUserGroupsOrderByWithRelationInput | ProviderUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderUserGroups.
     */
    cursor?: ProviderUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderUserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderUserGroups.
     */
    distinct?: ProviderUserGroupsScalarFieldEnum | ProviderUserGroupsScalarFieldEnum[]
  }


  /**
   * ProviderUserGroups findMany
   */
  export type ProviderUserGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * Filter, which ProviderUserGroups to fetch.
     */
    where?: ProviderUserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderUserGroups to fetch.
     */
    orderBy?: ProviderUserGroupsOrderByWithRelationInput | ProviderUserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderUserGroups.
     */
    cursor?: ProviderUserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderUserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderUserGroups.
     */
    skip?: number
    distinct?: ProviderUserGroupsScalarFieldEnum | ProviderUserGroupsScalarFieldEnum[]
  }


  /**
   * ProviderUserGroups create
   */
  export type ProviderUserGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderUserGroups.
     */
    data: XOR<ProviderUserGroupsCreateInput, ProviderUserGroupsUncheckedCreateInput>
  }


  /**
   * ProviderUserGroups createMany
   */
  export type ProviderUserGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderUserGroups.
     */
    data: ProviderUserGroupsCreateManyInput | ProviderUserGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProviderUserGroups update
   */
  export type ProviderUserGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderUserGroups.
     */
    data: XOR<ProviderUserGroupsUpdateInput, ProviderUserGroupsUncheckedUpdateInput>
    /**
     * Choose, which ProviderUserGroups to update.
     */
    where: ProviderUserGroupsWhereUniqueInput
  }


  /**
   * ProviderUserGroups updateMany
   */
  export type ProviderUserGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderUserGroups.
     */
    data: XOR<ProviderUserGroupsUpdateManyMutationInput, ProviderUserGroupsUncheckedUpdateManyInput>
    /**
     * Filter which ProviderUserGroups to update
     */
    where?: ProviderUserGroupsWhereInput
  }


  /**
   * ProviderUserGroups upsert
   */
  export type ProviderUserGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderUserGroups to update in case it exists.
     */
    where: ProviderUserGroupsWhereUniqueInput
    /**
     * In case the ProviderUserGroups found by the `where` argument doesn't exist, create a new ProviderUserGroups with this data.
     */
    create: XOR<ProviderUserGroupsCreateInput, ProviderUserGroupsUncheckedCreateInput>
    /**
     * In case the ProviderUserGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUserGroupsUpdateInput, ProviderUserGroupsUncheckedUpdateInput>
  }


  /**
   * ProviderUserGroups delete
   */
  export type ProviderUserGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
    /**
     * Filter which ProviderUserGroups to delete.
     */
    where: ProviderUserGroupsWhereUniqueInput
  }


  /**
   * ProviderUserGroups deleteMany
   */
  export type ProviderUserGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderUserGroups to delete
     */
    where?: ProviderUserGroupsWhereInput
  }


  /**
   * ProviderUserGroups.ProviderStaff
   */
  export type ProviderUserGroups$ProviderStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    where?: ProviderStaffWhereInput
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    cursor?: ProviderStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderStaffScalarFieldEnum | ProviderStaffScalarFieldEnum[]
  }


  /**
   * ProviderUserGroups without action
   */
  export type ProviderUserGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderUserGroups
     */
    select?: ProviderUserGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderUserGroupsInclude<ExtArgs> | null
  }



  /**
   * Model StudentUsers
   */

  export type AggregateStudentUsers = {
    _count: StudentUsersCountAggregateOutputType | null
    _min: StudentUsersMinAggregateOutputType | null
    _max: StudentUsersMaxAggregateOutputType | null
  }

  export type StudentUsersMinAggregateOutputType = {
    studentUserId: string | null
    status: string | null
    created: string | null
    email: string | null
    referral: string | null
    units: string | null
    userType: string | null
  }

  export type StudentUsersMaxAggregateOutputType = {
    studentUserId: string | null
    status: string | null
    created: string | null
    email: string | null
    referral: string | null
    units: string | null
    userType: string | null
  }

  export type StudentUsersCountAggregateOutputType = {
    studentUserId: number
    status: number
    analytics: number
    created: number
    details: number
    email: number
    referral: number
    units: number
    userType: number
    _all: number
  }


  export type StudentUsersMinAggregateInputType = {
    studentUserId?: true
    status?: true
    created?: true
    email?: true
    referral?: true
    units?: true
    userType?: true
  }

  export type StudentUsersMaxAggregateInputType = {
    studentUserId?: true
    status?: true
    created?: true
    email?: true
    referral?: true
    units?: true
    userType?: true
  }

  export type StudentUsersCountAggregateInputType = {
    studentUserId?: true
    status?: true
    analytics?: true
    created?: true
    details?: true
    email?: true
    referral?: true
    units?: true
    userType?: true
    _all?: true
  }

  export type StudentUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentUsers to aggregate.
     */
    where?: StudentUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentUsers to fetch.
     */
    orderBy?: StudentUsersOrderByWithRelationInput | StudentUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentUsers
    **/
    _count?: true | StudentUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentUsersMaxAggregateInputType
  }

  export type GetStudentUsersAggregateType<T extends StudentUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentUsers[P]>
      : GetScalarType<T[P], AggregateStudentUsers[P]>
  }




  export type StudentUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentUsersWhereInput
    orderBy?: StudentUsersOrderByWithAggregationInput | StudentUsersOrderByWithAggregationInput[]
    by: StudentUsersScalarFieldEnum[] | StudentUsersScalarFieldEnum
    having?: StudentUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentUsersCountAggregateInputType | true
    _min?: StudentUsersMinAggregateInputType
    _max?: StudentUsersMaxAggregateInputType
  }

  export type StudentUsersGroupByOutputType = {
    studentUserId: string
    status: string
    analytics: JsonValue
    created: string
    details: JsonValue
    email: string
    referral: string
    units: string
    userType: string
    _count: StudentUsersCountAggregateOutputType | null
    _min: StudentUsersMinAggregateOutputType | null
    _max: StudentUsersMaxAggregateOutputType | null
  }

  type GetStudentUsersGroupByPayload<T extends StudentUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentUsersGroupByOutputType[P]>
            : GetScalarType<T[P], StudentUsersGroupByOutputType[P]>
        }
      >
    >


  export type StudentUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studentUserId?: boolean
    status?: boolean
    analytics?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    referral?: boolean
    units?: boolean
    userType?: boolean
    Contacts?: boolean | StudentUsers$ContactsArgs<ExtArgs>
    Placements?: boolean | StudentUsers$PlacementsArgs<ExtArgs>
    _count?: boolean | StudentUsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentUsers"]>

  export type StudentUsersSelectScalar = {
    studentUserId?: boolean
    status?: boolean
    analytics?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    referral?: boolean
    units?: boolean
    userType?: boolean
  }

  export type StudentUsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contacts?: boolean | StudentUsers$ContactsArgs<ExtArgs>
    Placements?: boolean | StudentUsers$PlacementsArgs<ExtArgs>
    _count?: boolean | StudentUsersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StudentUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentUsers"
    objects: {
      Contacts: Prisma.$ContactsPayload<ExtArgs>[]
      Placements: Prisma.$PlacementsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      studentUserId: string
      status: string
      analytics: Prisma.JsonValue
      created: string
      details: Prisma.JsonValue
      email: string
      referral: string
      units: string
      userType: string
    }, ExtArgs["result"]["studentUsers"]>
    composites: {}
  }


  type StudentUsersGetPayload<S extends boolean | null | undefined | StudentUsersDefaultArgs> = $Result.GetResult<Prisma.$StudentUsersPayload, S>

  type StudentUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentUsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentUsersCountAggregateInputType | true
    }

  export interface StudentUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentUsers'], meta: { name: 'StudentUsers' } }
    /**
     * Find zero or one StudentUsers that matches the filter.
     * @param {StudentUsersFindUniqueArgs} args - Arguments to find a StudentUsers
     * @example
     * // Get one StudentUsers
     * const studentUsers = await prisma.studentUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentUsersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentUsers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentUsersFindUniqueOrThrowArgs} args - Arguments to find a StudentUsers
     * @example
     * // Get one StudentUsers
     * const studentUsers = await prisma.studentUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentUsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersFindFirstArgs} args - Arguments to find a StudentUsers
     * @example
     * // Get one StudentUsers
     * const studentUsers = await prisma.studentUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentUsersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersFindFirstArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersFindFirstOrThrowArgs} args - Arguments to find a StudentUsers
     * @example
     * // Get one StudentUsers
     * const studentUsers = await prisma.studentUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentUsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentUsers
     * const studentUsers = await prisma.studentUsers.findMany()
     * 
     * // Get first 10 StudentUsers
     * const studentUsers = await prisma.studentUsers.findMany({ take: 10 })
     * 
     * // Only select the `studentUserId`
     * const studentUsersWithStudentUserIdOnly = await prisma.studentUsers.findMany({ select: { studentUserId: true } })
     * 
    **/
    findMany<T extends StudentUsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentUsers.
     * @param {StudentUsersCreateArgs} args - Arguments to create a StudentUsers.
     * @example
     * // Create one StudentUsers
     * const StudentUsers = await prisma.studentUsers.create({
     *   data: {
     *     // ... data to create a StudentUsers
     *   }
     * })
     * 
    **/
    create<T extends StudentUsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersCreateArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentUsers.
     *     @param {StudentUsersCreateManyArgs} args - Arguments to create many StudentUsers.
     *     @example
     *     // Create many StudentUsers
     *     const studentUsers = await prisma.studentUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentUsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentUsers.
     * @param {StudentUsersDeleteArgs} args - Arguments to delete one StudentUsers.
     * @example
     * // Delete one StudentUsers
     * const StudentUsers = await prisma.studentUsers.delete({
     *   where: {
     *     // ... filter to delete one StudentUsers
     *   }
     * })
     * 
    **/
    delete<T extends StudentUsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersDeleteArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentUsers.
     * @param {StudentUsersUpdateArgs} args - Arguments to update one StudentUsers.
     * @example
     * // Update one StudentUsers
     * const studentUsers = await prisma.studentUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersUpdateArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentUsers.
     * @param {StudentUsersDeleteManyArgs} args - Arguments to filter StudentUsers to delete.
     * @example
     * // Delete a few StudentUsers
     * const { count } = await prisma.studentUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentUsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentUsers
     * const studentUsers = await prisma.studentUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentUsers.
     * @param {StudentUsersUpsertArgs} args - Arguments to update or create a StudentUsers.
     * @example
     * // Update or create a StudentUsers
     * const studentUsers = await prisma.studentUsers.upsert({
     *   create: {
     *     // ... data to create a StudentUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentUsers we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersUpsertArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersCountArgs} args - Arguments to filter StudentUsers to count.
     * @example
     * // Count the number of StudentUsers
     * const count = await prisma.studentUsers.count({
     *   where: {
     *     // ... the filter for the StudentUsers we want to count
     *   }
     * })
    **/
    count<T extends StudentUsersCountArgs>(
      args?: Subset<T, StudentUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentUsersAggregateArgs>(args: Subset<T, StudentUsersAggregateArgs>): Prisma.PrismaPromise<GetStudentUsersAggregateType<T>>

    /**
     * Group by StudentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentUsersGroupByArgs['orderBy'] }
        : { orderBy?: StudentUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentUsers model
   */
  readonly fields: StudentUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Contacts<T extends StudentUsers$ContactsArgs<ExtArgs> = {}>(args?: Subset<T, StudentUsers$ContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Placements<T extends StudentUsers$PlacementsArgs<ExtArgs> = {}>(args?: Subset<T, StudentUsers$PlacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentUsers model
   */ 
  interface StudentUsersFieldRefs {
    readonly studentUserId: FieldRef<"StudentUsers", 'String'>
    readonly status: FieldRef<"StudentUsers", 'String'>
    readonly analytics: FieldRef<"StudentUsers", 'Json'>
    readonly created: FieldRef<"StudentUsers", 'String'>
    readonly details: FieldRef<"StudentUsers", 'Json'>
    readonly email: FieldRef<"StudentUsers", 'String'>
    readonly referral: FieldRef<"StudentUsers", 'String'>
    readonly units: FieldRef<"StudentUsers", 'String'>
    readonly userType: FieldRef<"StudentUsers", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StudentUsers findUnique
   */
  export type StudentUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where: StudentUsersWhereUniqueInput
  }


  /**
   * StudentUsers findUniqueOrThrow
   */
  export type StudentUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where: StudentUsersWhereUniqueInput
  }


  /**
   * StudentUsers findFirst
   */
  export type StudentUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where?: StudentUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentUsers to fetch.
     */
    orderBy?: StudentUsersOrderByWithRelationInput | StudentUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentUsers.
     */
    cursor?: StudentUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentUsers.
     */
    distinct?: StudentUsersScalarFieldEnum | StudentUsersScalarFieldEnum[]
  }


  /**
   * StudentUsers findFirstOrThrow
   */
  export type StudentUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where?: StudentUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentUsers to fetch.
     */
    orderBy?: StudentUsersOrderByWithRelationInput | StudentUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentUsers.
     */
    cursor?: StudentUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentUsers.
     */
    distinct?: StudentUsersScalarFieldEnum | StudentUsersScalarFieldEnum[]
  }


  /**
   * StudentUsers findMany
   */
  export type StudentUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where?: StudentUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentUsers to fetch.
     */
    orderBy?: StudentUsersOrderByWithRelationInput | StudentUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentUsers.
     */
    cursor?: StudentUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentUsers.
     */
    skip?: number
    distinct?: StudentUsersScalarFieldEnum | StudentUsersScalarFieldEnum[]
  }


  /**
   * StudentUsers create
   */
  export type StudentUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentUsers.
     */
    data: XOR<StudentUsersCreateInput, StudentUsersUncheckedCreateInput>
  }


  /**
   * StudentUsers createMany
   */
  export type StudentUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentUsers.
     */
    data: StudentUsersCreateManyInput | StudentUsersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentUsers update
   */
  export type StudentUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentUsers.
     */
    data: XOR<StudentUsersUpdateInput, StudentUsersUncheckedUpdateInput>
    /**
     * Choose, which StudentUsers to update.
     */
    where: StudentUsersWhereUniqueInput
  }


  /**
   * StudentUsers updateMany
   */
  export type StudentUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentUsers.
     */
    data: XOR<StudentUsersUpdateManyMutationInput, StudentUsersUncheckedUpdateManyInput>
    /**
     * Filter which StudentUsers to update
     */
    where?: StudentUsersWhereInput
  }


  /**
   * StudentUsers upsert
   */
  export type StudentUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentUsers to update in case it exists.
     */
    where: StudentUsersWhereUniqueInput
    /**
     * In case the StudentUsers found by the `where` argument doesn't exist, create a new StudentUsers with this data.
     */
    create: XOR<StudentUsersCreateInput, StudentUsersUncheckedCreateInput>
    /**
     * In case the StudentUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUsersUpdateInput, StudentUsersUncheckedUpdateInput>
  }


  /**
   * StudentUsers delete
   */
  export type StudentUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
    /**
     * Filter which StudentUsers to delete.
     */
    where: StudentUsersWhereUniqueInput
  }


  /**
   * StudentUsers deleteMany
   */
  export type StudentUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentUsers to delete
     */
    where?: StudentUsersWhereInput
  }


  /**
   * StudentUsers.Contacts
   */
  export type StudentUsers$ContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    cursor?: ContactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * StudentUsers.Placements
   */
  export type StudentUsers$PlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    where?: PlacementsWhereInput
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    cursor?: PlacementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * StudentUsers without action
   */
  export type StudentUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentUsersInclude<ExtArgs> | null
  }



  /**
   * Model InstituteStaff
   */

  export type AggregateInstituteStaff = {
    _count: InstituteStaffCountAggregateOutputType | null
    _min: InstituteStaffMinAggregateOutputType | null
    _max: InstituteStaffMaxAggregateOutputType | null
  }

  export type InstituteStaffMinAggregateOutputType = {
    instituteStaffId: string | null
    created: string | null
    email: string | null
    oId: string | null
    status: string | null
    userType: string | null
    instituteId: string | null
    userGroupId: string | null
  }

  export type InstituteStaffMaxAggregateOutputType = {
    instituteStaffId: string | null
    created: string | null
    email: string | null
    oId: string | null
    status: string | null
    userType: string | null
    instituteId: string | null
    userGroupId: string | null
  }

  export type InstituteStaffCountAggregateOutputType = {
    instituteStaffId: number
    created: number
    details: number
    email: number
    oId: number
    status: number
    userType: number
    instituteId: number
    userGroupId: number
    _all: number
  }


  export type InstituteStaffMinAggregateInputType = {
    instituteStaffId?: true
    created?: true
    email?: true
    oId?: true
    status?: true
    userType?: true
    instituteId?: true
    userGroupId?: true
  }

  export type InstituteStaffMaxAggregateInputType = {
    instituteStaffId?: true
    created?: true
    email?: true
    oId?: true
    status?: true
    userType?: true
    instituteId?: true
    userGroupId?: true
  }

  export type InstituteStaffCountAggregateInputType = {
    instituteStaffId?: true
    created?: true
    details?: true
    email?: true
    oId?: true
    status?: true
    userType?: true
    instituteId?: true
    userGroupId?: true
    _all?: true
  }

  export type InstituteStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStaff to aggregate.
     */
    where?: InstituteStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffs to fetch.
     */
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstituteStaffs
    **/
    _count?: true | InstituteStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteStaffMaxAggregateInputType
  }

  export type GetInstituteStaffAggregateType<T extends InstituteStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateInstituteStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstituteStaff[P]>
      : GetScalarType<T[P], AggregateInstituteStaff[P]>
  }




  export type InstituteStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStaffWhereInput
    orderBy?: InstituteStaffOrderByWithAggregationInput | InstituteStaffOrderByWithAggregationInput[]
    by: InstituteStaffScalarFieldEnum[] | InstituteStaffScalarFieldEnum
    having?: InstituteStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteStaffCountAggregateInputType | true
    _min?: InstituteStaffMinAggregateInputType
    _max?: InstituteStaffMaxAggregateInputType
  }

  export type InstituteStaffGroupByOutputType = {
    instituteStaffId: string
    created: string
    details: JsonValue
    email: string
    oId: string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
    _count: InstituteStaffCountAggregateOutputType | null
    _min: InstituteStaffMinAggregateOutputType | null
    _max: InstituteStaffMaxAggregateOutputType | null
  }

  type GetInstituteStaffGroupByPayload<T extends InstituteStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteStaffGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteStaffGroupByOutputType[P]>
        }
      >
    >


  export type InstituteStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instituteStaffId?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    oId?: boolean
    status?: boolean
    userType?: boolean
    instituteId?: boolean
    userGroupId?: boolean
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    userGroup?: boolean | InstituteStaffUserGroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instituteStaff"]>

  export type InstituteStaffSelectScalar = {
    instituteStaffId?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    oId?: boolean
    status?: boolean
    userType?: boolean
    instituteId?: boolean
    userGroupId?: boolean
  }

  export type InstituteStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    userGroup?: boolean | InstituteStaffUserGroupsDefaultArgs<ExtArgs>
  }


  export type $InstituteStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstituteStaff"
    objects: {
      institute: Prisma.$InstitutesPayload<ExtArgs>
      userGroup: Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      instituteStaffId: string
      created: string
      details: Prisma.JsonValue
      email: string
      oId: string
      status: string
      userType: string
      instituteId: string
      userGroupId: string
    }, ExtArgs["result"]["instituteStaff"]>
    composites: {}
  }


  type InstituteStaffGetPayload<S extends boolean | null | undefined | InstituteStaffDefaultArgs> = $Result.GetResult<Prisma.$InstituteStaffPayload, S>

  type InstituteStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstituteStaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstituteStaffCountAggregateInputType | true
    }

  export interface InstituteStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstituteStaff'], meta: { name: 'InstituteStaff' } }
    /**
     * Find zero or one InstituteStaff that matches the filter.
     * @param {InstituteStaffFindUniqueArgs} args - Arguments to find a InstituteStaff
     * @example
     * // Get one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstituteStaffFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffFindUniqueArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InstituteStaff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstituteStaffFindUniqueOrThrowArgs} args - Arguments to find a InstituteStaff
     * @example
     * // Get one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstituteStaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InstituteStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffFindFirstArgs} args - Arguments to find a InstituteStaff
     * @example
     * // Get one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstituteStaffFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffFindFirstArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InstituteStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffFindFirstOrThrowArgs} args - Arguments to find a InstituteStaff
     * @example
     * // Get one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstituteStaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InstituteStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstituteStaffs
     * const instituteStaffs = await prisma.instituteStaff.findMany()
     * 
     * // Get first 10 InstituteStaffs
     * const instituteStaffs = await prisma.instituteStaff.findMany({ take: 10 })
     * 
     * // Only select the `instituteStaffId`
     * const instituteStaffWithInstituteStaffIdOnly = await prisma.instituteStaff.findMany({ select: { instituteStaffId: true } })
     * 
    **/
    findMany<T extends InstituteStaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InstituteStaff.
     * @param {InstituteStaffCreateArgs} args - Arguments to create a InstituteStaff.
     * @example
     * // Create one InstituteStaff
     * const InstituteStaff = await prisma.instituteStaff.create({
     *   data: {
     *     // ... data to create a InstituteStaff
     *   }
     * })
     * 
    **/
    create<T extends InstituteStaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffCreateArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InstituteStaffs.
     *     @param {InstituteStaffCreateManyArgs} args - Arguments to create many InstituteStaffs.
     *     @example
     *     // Create many InstituteStaffs
     *     const instituteStaff = await prisma.instituteStaff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstituteStaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InstituteStaff.
     * @param {InstituteStaffDeleteArgs} args - Arguments to delete one InstituteStaff.
     * @example
     * // Delete one InstituteStaff
     * const InstituteStaff = await prisma.instituteStaff.delete({
     *   where: {
     *     // ... filter to delete one InstituteStaff
     *   }
     * })
     * 
    **/
    delete<T extends InstituteStaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffDeleteArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InstituteStaff.
     * @param {InstituteStaffUpdateArgs} args - Arguments to update one InstituteStaff.
     * @example
     * // Update one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstituteStaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUpdateArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InstituteStaffs.
     * @param {InstituteStaffDeleteManyArgs} args - Arguments to filter InstituteStaffs to delete.
     * @example
     * // Delete a few InstituteStaffs
     * const { count } = await prisma.instituteStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstituteStaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstituteStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstituteStaffs
     * const instituteStaff = await prisma.instituteStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstituteStaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstituteStaff.
     * @param {InstituteStaffUpsertArgs} args - Arguments to update or create a InstituteStaff.
     * @example
     * // Update or create a InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.upsert({
     *   create: {
     *     // ... data to create a InstituteStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstituteStaff we want to update
     *   }
     * })
    **/
    upsert<T extends InstituteStaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUpsertArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InstituteStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffCountArgs} args - Arguments to filter InstituteStaffs to count.
     * @example
     * // Count the number of InstituteStaffs
     * const count = await prisma.instituteStaff.count({
     *   where: {
     *     // ... the filter for the InstituteStaffs we want to count
     *   }
     * })
    **/
    count<T extends InstituteStaffCountArgs>(
      args?: Subset<T, InstituteStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstituteStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteStaffAggregateArgs>(args: Subset<T, InstituteStaffAggregateArgs>): Prisma.PrismaPromise<GetInstituteStaffAggregateType<T>>

    /**
     * Group by InstituteStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteStaffGroupByArgs['orderBy'] }
        : { orderBy?: InstituteStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstituteStaff model
   */
  readonly fields: InstituteStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstituteStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    institute<T extends InstitutesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutesDefaultArgs<ExtArgs>>): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    userGroup<T extends InstituteStaffUserGroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStaffUserGroupsDefaultArgs<ExtArgs>>): Prisma__InstituteStaffUserGroupsClient<$Result.GetResult<Prisma.$InstituteStaffUserGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InstituteStaff model
   */ 
  interface InstituteStaffFieldRefs {
    readonly instituteStaffId: FieldRef<"InstituteStaff", 'String'>
    readonly created: FieldRef<"InstituteStaff", 'String'>
    readonly details: FieldRef<"InstituteStaff", 'Json'>
    readonly email: FieldRef<"InstituteStaff", 'String'>
    readonly oId: FieldRef<"InstituteStaff", 'String'>
    readonly status: FieldRef<"InstituteStaff", 'String'>
    readonly userType: FieldRef<"InstituteStaff", 'String'>
    readonly instituteId: FieldRef<"InstituteStaff", 'String'>
    readonly userGroupId: FieldRef<"InstituteStaff", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InstituteStaff findUnique
   */
  export type InstituteStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaff to fetch.
     */
    where: InstituteStaffWhereUniqueInput
  }


  /**
   * InstituteStaff findUniqueOrThrow
   */
  export type InstituteStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaff to fetch.
     */
    where: InstituteStaffWhereUniqueInput
  }


  /**
   * InstituteStaff findFirst
   */
  export type InstituteStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaff to fetch.
     */
    where?: InstituteStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffs to fetch.
     */
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStaffs.
     */
    cursor?: InstituteStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStaffs.
     */
    distinct?: InstituteStaffScalarFieldEnum | InstituteStaffScalarFieldEnum[]
  }


  /**
   * InstituteStaff findFirstOrThrow
   */
  export type InstituteStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaff to fetch.
     */
    where?: InstituteStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffs to fetch.
     */
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStaffs.
     */
    cursor?: InstituteStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStaffs.
     */
    distinct?: InstituteStaffScalarFieldEnum | InstituteStaffScalarFieldEnum[]
  }


  /**
   * InstituteStaff findMany
   */
  export type InstituteStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStaffs to fetch.
     */
    where?: InstituteStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffs to fetch.
     */
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstituteStaffs.
     */
    cursor?: InstituteStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffs.
     */
    skip?: number
    distinct?: InstituteStaffScalarFieldEnum | InstituteStaffScalarFieldEnum[]
  }


  /**
   * InstituteStaff create
   */
  export type InstituteStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a InstituteStaff.
     */
    data: XOR<InstituteStaffCreateInput, InstituteStaffUncheckedCreateInput>
  }


  /**
   * InstituteStaff createMany
   */
  export type InstituteStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstituteStaffs.
     */
    data: InstituteStaffCreateManyInput | InstituteStaffCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InstituteStaff update
   */
  export type InstituteStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a InstituteStaff.
     */
    data: XOR<InstituteStaffUpdateInput, InstituteStaffUncheckedUpdateInput>
    /**
     * Choose, which InstituteStaff to update.
     */
    where: InstituteStaffWhereUniqueInput
  }


  /**
   * InstituteStaff updateMany
   */
  export type InstituteStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstituteStaffs.
     */
    data: XOR<InstituteStaffUpdateManyMutationInput, InstituteStaffUncheckedUpdateManyInput>
    /**
     * Filter which InstituteStaffs to update
     */
    where?: InstituteStaffWhereInput
  }


  /**
   * InstituteStaff upsert
   */
  export type InstituteStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the InstituteStaff to update in case it exists.
     */
    where: InstituteStaffWhereUniqueInput
    /**
     * In case the InstituteStaff found by the `where` argument doesn't exist, create a new InstituteStaff with this data.
     */
    create: XOR<InstituteStaffCreateInput, InstituteStaffUncheckedCreateInput>
    /**
     * In case the InstituteStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteStaffUpdateInput, InstituteStaffUncheckedUpdateInput>
  }


  /**
   * InstituteStaff delete
   */
  export type InstituteStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
    /**
     * Filter which InstituteStaff to delete.
     */
    where: InstituteStaffWhereUniqueInput
  }


  /**
   * InstituteStaff deleteMany
   */
  export type InstituteStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStaffs to delete
     */
    where?: InstituteStaffWhereInput
  }


  /**
   * InstituteStaff without action
   */
  export type InstituteStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStaffInclude<ExtArgs> | null
  }



  /**
   * Model InstituteStudents
   */

  export type AggregateInstituteStudents = {
    _count: InstituteStudentsCountAggregateOutputType | null
    _min: InstituteStudentsMinAggregateOutputType | null
    _max: InstituteStudentsMaxAggregateOutputType | null
  }

  export type InstituteStudentsMinAggregateOutputType = {
    instituteStudentId: string | null
    activated: string | null
    created: string | null
    cohortId: string | null
    email: string | null
    oId: string | null
    resetExpiry: Date | null
    status: string | null
    userType: string | null
    instituteId: string | null
    userGroupId: string | null
  }

  export type InstituteStudentsMaxAggregateOutputType = {
    instituteStudentId: string | null
    activated: string | null
    created: string | null
    cohortId: string | null
    email: string | null
    oId: string | null
    resetExpiry: Date | null
    status: string | null
    userType: string | null
    instituteId: string | null
    userGroupId: string | null
  }

  export type InstituteStudentsCountAggregateOutputType = {
    instituteStudentId: number
    activated: number
    created: number
    cohortId: number
    details: number
    email: number
    flags: number
    oId: number
    resetExpiry: number
    status: number
    userType: number
    instituteId: number
    userGroupId: number
    _all: number
  }


  export type InstituteStudentsMinAggregateInputType = {
    instituteStudentId?: true
    activated?: true
    created?: true
    cohortId?: true
    email?: true
    oId?: true
    resetExpiry?: true
    status?: true
    userType?: true
    instituteId?: true
    userGroupId?: true
  }

  export type InstituteStudentsMaxAggregateInputType = {
    instituteStudentId?: true
    activated?: true
    created?: true
    cohortId?: true
    email?: true
    oId?: true
    resetExpiry?: true
    status?: true
    userType?: true
    instituteId?: true
    userGroupId?: true
  }

  export type InstituteStudentsCountAggregateInputType = {
    instituteStudentId?: true
    activated?: true
    created?: true
    cohortId?: true
    details?: true
    email?: true
    flags?: true
    oId?: true
    resetExpiry?: true
    status?: true
    userType?: true
    instituteId?: true
    userGroupId?: true
    _all?: true
  }

  export type InstituteStudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStudents to aggregate.
     */
    where?: InstituteStudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudents to fetch.
     */
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteStudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstituteStudents
    **/
    _count?: true | InstituteStudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteStudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteStudentsMaxAggregateInputType
  }

  export type GetInstituteStudentsAggregateType<T extends InstituteStudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstituteStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstituteStudents[P]>
      : GetScalarType<T[P], AggregateInstituteStudents[P]>
  }




  export type InstituteStudentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStudentsWhereInput
    orderBy?: InstituteStudentsOrderByWithAggregationInput | InstituteStudentsOrderByWithAggregationInput[]
    by: InstituteStudentsScalarFieldEnum[] | InstituteStudentsScalarFieldEnum
    having?: InstituteStudentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteStudentsCountAggregateInputType | true
    _min?: InstituteStudentsMinAggregateInputType
    _max?: InstituteStudentsMaxAggregateInputType
  }

  export type InstituteStudentsGroupByOutputType = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonValue
    email: string
    flags: string[]
    oId: string
    resetExpiry: Date
    status: string
    userType: string
    instituteId: string
    userGroupId: string
    _count: InstituteStudentsCountAggregateOutputType | null
    _min: InstituteStudentsMinAggregateOutputType | null
    _max: InstituteStudentsMaxAggregateOutputType | null
  }

  type GetInstituteStudentsGroupByPayload<T extends InstituteStudentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteStudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteStudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteStudentsGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteStudentsGroupByOutputType[P]>
        }
      >
    >


  export type InstituteStudentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instituteStudentId?: boolean
    activated?: boolean
    created?: boolean
    cohortId?: boolean
    details?: boolean
    email?: boolean
    flags?: boolean
    oId?: boolean
    resetExpiry?: boolean
    status?: boolean
    userType?: boolean
    instituteId?: boolean
    userGroupId?: boolean
    Contacts?: boolean | InstituteStudents$ContactsArgs<ExtArgs>
    cohort?: boolean | CohortsDefaultArgs<ExtArgs>
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    userGroup?: boolean | InstituteStudentUserGroupsDefaultArgs<ExtArgs>
    Placements?: boolean | InstituteStudents$PlacementsArgs<ExtArgs>
    _count?: boolean | InstituteStudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instituteStudents"]>

  export type InstituteStudentsSelectScalar = {
    instituteStudentId?: boolean
    activated?: boolean
    created?: boolean
    cohortId?: boolean
    details?: boolean
    email?: boolean
    flags?: boolean
    oId?: boolean
    resetExpiry?: boolean
    status?: boolean
    userType?: boolean
    instituteId?: boolean
    userGroupId?: boolean
  }

  export type InstituteStudentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contacts?: boolean | InstituteStudents$ContactsArgs<ExtArgs>
    cohort?: boolean | CohortsDefaultArgs<ExtArgs>
    institute?: boolean | InstitutesDefaultArgs<ExtArgs>
    userGroup?: boolean | InstituteStudentUserGroupsDefaultArgs<ExtArgs>
    Placements?: boolean | InstituteStudents$PlacementsArgs<ExtArgs>
    _count?: boolean | InstituteStudentsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InstituteStudentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstituteStudents"
    objects: {
      Contacts: Prisma.$ContactsPayload<ExtArgs>[]
      cohort: Prisma.$CohortsPayload<ExtArgs>
      institute: Prisma.$InstitutesPayload<ExtArgs>
      userGroup: Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>
      Placements: Prisma.$PlacementsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      instituteStudentId: string
      activated: string
      created: string
      cohortId: string
      details: Prisma.JsonValue
      email: string
      flags: string[]
      oId: string
      resetExpiry: Date
      status: string
      userType: string
      instituteId: string
      userGroupId: string
    }, ExtArgs["result"]["instituteStudents"]>
    composites: {}
  }


  type InstituteStudentsGetPayload<S extends boolean | null | undefined | InstituteStudentsDefaultArgs> = $Result.GetResult<Prisma.$InstituteStudentsPayload, S>

  type InstituteStudentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstituteStudentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstituteStudentsCountAggregateInputType | true
    }

  export interface InstituteStudentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstituteStudents'], meta: { name: 'InstituteStudents' } }
    /**
     * Find zero or one InstituteStudents that matches the filter.
     * @param {InstituteStudentsFindUniqueArgs} args - Arguments to find a InstituteStudents
     * @example
     * // Get one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstituteStudentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsFindUniqueArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InstituteStudents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstituteStudentsFindUniqueOrThrowArgs} args - Arguments to find a InstituteStudents
     * @example
     * // Get one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstituteStudentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InstituteStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsFindFirstArgs} args - Arguments to find a InstituteStudents
     * @example
     * // Get one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstituteStudentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsFindFirstArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InstituteStudents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsFindFirstOrThrowArgs} args - Arguments to find a InstituteStudents
     * @example
     * // Get one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstituteStudentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InstituteStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findMany()
     * 
     * // Get first 10 InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findMany({ take: 10 })
     * 
     * // Only select the `instituteStudentId`
     * const instituteStudentsWithInstituteStudentIdOnly = await prisma.instituteStudents.findMany({ select: { instituteStudentId: true } })
     * 
    **/
    findMany<T extends InstituteStudentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InstituteStudents.
     * @param {InstituteStudentsCreateArgs} args - Arguments to create a InstituteStudents.
     * @example
     * // Create one InstituteStudents
     * const InstituteStudents = await prisma.instituteStudents.create({
     *   data: {
     *     // ... data to create a InstituteStudents
     *   }
     * })
     * 
    **/
    create<T extends InstituteStudentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsCreateArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InstituteStudents.
     *     @param {InstituteStudentsCreateManyArgs} args - Arguments to create many InstituteStudents.
     *     @example
     *     // Create many InstituteStudents
     *     const instituteStudents = await prisma.instituteStudents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstituteStudentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InstituteStudents.
     * @param {InstituteStudentsDeleteArgs} args - Arguments to delete one InstituteStudents.
     * @example
     * // Delete one InstituteStudents
     * const InstituteStudents = await prisma.instituteStudents.delete({
     *   where: {
     *     // ... filter to delete one InstituteStudents
     *   }
     * })
     * 
    **/
    delete<T extends InstituteStudentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsDeleteArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InstituteStudents.
     * @param {InstituteStudentsUpdateArgs} args - Arguments to update one InstituteStudents.
     * @example
     * // Update one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstituteStudentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsUpdateArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InstituteStudents.
     * @param {InstituteStudentsDeleteManyArgs} args - Arguments to filter InstituteStudents to delete.
     * @example
     * // Delete a few InstituteStudents
     * const { count } = await prisma.instituteStudents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstituteStudentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstituteStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstituteStudentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstituteStudents.
     * @param {InstituteStudentsUpsertArgs} args - Arguments to update or create a InstituteStudents.
     * @example
     * // Update or create a InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.upsert({
     *   create: {
     *     // ... data to create a InstituteStudents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstituteStudents we want to update
     *   }
     * })
    **/
    upsert<T extends InstituteStudentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsUpsertArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InstituteStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsCountArgs} args - Arguments to filter InstituteStudents to count.
     * @example
     * // Count the number of InstituteStudents
     * const count = await prisma.instituteStudents.count({
     *   where: {
     *     // ... the filter for the InstituteStudents we want to count
     *   }
     * })
    **/
    count<T extends InstituteStudentsCountArgs>(
      args?: Subset<T, InstituteStudentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteStudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstituteStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteStudentsAggregateArgs>(args: Subset<T, InstituteStudentsAggregateArgs>): Prisma.PrismaPromise<GetInstituteStudentsAggregateType<T>>

    /**
     * Group by InstituteStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteStudentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteStudentsGroupByArgs['orderBy'] }
        : { orderBy?: InstituteStudentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteStudentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstituteStudents model
   */
  readonly fields: InstituteStudentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstituteStudents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteStudentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Contacts<T extends InstituteStudents$ContactsArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStudents$ContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findMany'> | Null>;

    cohort<T extends CohortsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CohortsDefaultArgs<ExtArgs>>): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    institute<T extends InstitutesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutesDefaultArgs<ExtArgs>>): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    userGroup<T extends InstituteStudentUserGroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStudentUserGroupsDefaultArgs<ExtArgs>>): Prisma__InstituteStudentUserGroupsClient<$Result.GetResult<Prisma.$InstituteStudentUserGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Placements<T extends InstituteStudents$PlacementsArgs<ExtArgs> = {}>(args?: Subset<T, InstituteStudents$PlacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InstituteStudents model
   */ 
  interface InstituteStudentsFieldRefs {
    readonly instituteStudentId: FieldRef<"InstituteStudents", 'String'>
    readonly activated: FieldRef<"InstituteStudents", 'String'>
    readonly created: FieldRef<"InstituteStudents", 'String'>
    readonly cohortId: FieldRef<"InstituteStudents", 'String'>
    readonly details: FieldRef<"InstituteStudents", 'Json'>
    readonly email: FieldRef<"InstituteStudents", 'String'>
    readonly flags: FieldRef<"InstituteStudents", 'String[]'>
    readonly oId: FieldRef<"InstituteStudents", 'String'>
    readonly resetExpiry: FieldRef<"InstituteStudents", 'DateTime'>
    readonly status: FieldRef<"InstituteStudents", 'String'>
    readonly userType: FieldRef<"InstituteStudents", 'String'>
    readonly instituteId: FieldRef<"InstituteStudents", 'String'>
    readonly userGroupId: FieldRef<"InstituteStudents", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InstituteStudents findUnique
   */
  export type InstituteStudentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where: InstituteStudentsWhereUniqueInput
  }


  /**
   * InstituteStudents findUniqueOrThrow
   */
  export type InstituteStudentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where: InstituteStudentsWhereUniqueInput
  }


  /**
   * InstituteStudents findFirst
   */
  export type InstituteStudentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where?: InstituteStudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudents to fetch.
     */
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStudents.
     */
    cursor?: InstituteStudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStudents.
     */
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * InstituteStudents findFirstOrThrow
   */
  export type InstituteStudentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where?: InstituteStudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudents to fetch.
     */
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStudents.
     */
    cursor?: InstituteStudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStudents.
     */
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * InstituteStudents findMany
   */
  export type InstituteStudentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where?: InstituteStudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudents to fetch.
     */
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstituteStudents.
     */
    cursor?: InstituteStudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudents.
     */
    skip?: number
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * InstituteStudents create
   */
  export type InstituteStudentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * The data needed to create a InstituteStudents.
     */
    data: XOR<InstituteStudentsCreateInput, InstituteStudentsUncheckedCreateInput>
  }


  /**
   * InstituteStudents createMany
   */
  export type InstituteStudentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstituteStudents.
     */
    data: InstituteStudentsCreateManyInput | InstituteStudentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InstituteStudents update
   */
  export type InstituteStudentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * The data needed to update a InstituteStudents.
     */
    data: XOR<InstituteStudentsUpdateInput, InstituteStudentsUncheckedUpdateInput>
    /**
     * Choose, which InstituteStudents to update.
     */
    where: InstituteStudentsWhereUniqueInput
  }


  /**
   * InstituteStudents updateMany
   */
  export type InstituteStudentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstituteStudents.
     */
    data: XOR<InstituteStudentsUpdateManyMutationInput, InstituteStudentsUncheckedUpdateManyInput>
    /**
     * Filter which InstituteStudents to update
     */
    where?: InstituteStudentsWhereInput
  }


  /**
   * InstituteStudents upsert
   */
  export type InstituteStudentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * The filter to search for the InstituteStudents to update in case it exists.
     */
    where: InstituteStudentsWhereUniqueInput
    /**
     * In case the InstituteStudents found by the `where` argument doesn't exist, create a new InstituteStudents with this data.
     */
    create: XOR<InstituteStudentsCreateInput, InstituteStudentsUncheckedCreateInput>
    /**
     * In case the InstituteStudents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteStudentsUpdateInput, InstituteStudentsUncheckedUpdateInput>
  }


  /**
   * InstituteStudents delete
   */
  export type InstituteStudentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
    /**
     * Filter which InstituteStudents to delete.
     */
    where: InstituteStudentsWhereUniqueInput
  }


  /**
   * InstituteStudents deleteMany
   */
  export type InstituteStudentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStudents to delete
     */
    where?: InstituteStudentsWhereInput
  }


  /**
   * InstituteStudents.Contacts
   */
  export type InstituteStudents$ContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactsInclude<ExtArgs> | null
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    cursor?: ContactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * InstituteStudents.Placements
   */
  export type InstituteStudents$PlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlacementsInclude<ExtArgs> | null
    where?: PlacementsWhereInput
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    cursor?: PlacementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * InstituteStudents without action
   */
  export type InstituteStudentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstituteStudentsInclude<ExtArgs> | null
  }



  /**
   * Model ProviderStaff
   */

  export type AggregateProviderStaff = {
    _count: ProviderStaffCountAggregateOutputType | null
    _min: ProviderStaffMinAggregateOutputType | null
    _max: ProviderStaffMaxAggregateOutputType | null
  }

  export type ProviderStaffMinAggregateOutputType = {
    providerStaffId: string | null
    created: string | null
    email: string | null
    status: string | null
    providerId: string | null
    userGroupId: string | null
  }

  export type ProviderStaffMaxAggregateOutputType = {
    providerStaffId: string | null
    created: string | null
    email: string | null
    status: string | null
    providerId: string | null
    userGroupId: string | null
  }

  export type ProviderStaffCountAggregateOutputType = {
    providerStaffId: number
    created: number
    details: number
    email: number
    notes: number
    status: number
    providerId: number
    userGroupId: number
    _all: number
  }


  export type ProviderStaffMinAggregateInputType = {
    providerStaffId?: true
    created?: true
    email?: true
    status?: true
    providerId?: true
    userGroupId?: true
  }

  export type ProviderStaffMaxAggregateInputType = {
    providerStaffId?: true
    created?: true
    email?: true
    status?: true
    providerId?: true
    userGroupId?: true
  }

  export type ProviderStaffCountAggregateInputType = {
    providerStaffId?: true
    created?: true
    details?: true
    email?: true
    notes?: true
    status?: true
    providerId?: true
    userGroupId?: true
    _all?: true
  }

  export type ProviderStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderStaff to aggregate.
     */
    where?: ProviderStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStaffs to fetch.
     */
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderStaffs
    **/
    _count?: true | ProviderStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderStaffMaxAggregateInputType
  }

  export type GetProviderStaffAggregateType<T extends ProviderStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderStaff[P]>
      : GetScalarType<T[P], AggregateProviderStaff[P]>
  }




  export type ProviderStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderStaffWhereInput
    orderBy?: ProviderStaffOrderByWithAggregationInput | ProviderStaffOrderByWithAggregationInput[]
    by: ProviderStaffScalarFieldEnum[] | ProviderStaffScalarFieldEnum
    having?: ProviderStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderStaffCountAggregateInputType | true
    _min?: ProviderStaffMinAggregateInputType
    _max?: ProviderStaffMaxAggregateInputType
  }

  export type ProviderStaffGroupByOutputType = {
    providerStaffId: string
    created: string
    details: JsonValue
    email: string
    notes: JsonValue | null
    status: string
    providerId: string
    userGroupId: string
    _count: ProviderStaffCountAggregateOutputType | null
    _min: ProviderStaffMinAggregateOutputType | null
    _max: ProviderStaffMaxAggregateOutputType | null
  }

  type GetProviderStaffGroupByPayload<T extends ProviderStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderStaffGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderStaffGroupByOutputType[P]>
        }
      >
    >


  export type ProviderStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    providerStaffId?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    notes?: boolean
    status?: boolean
    providerId?: boolean
    userGroupId?: boolean
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
    userGroup?: boolean | ProviderUserGroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerStaff"]>

  export type ProviderStaffSelectScalar = {
    providerStaffId?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    notes?: boolean
    status?: boolean
    providerId?: boolean
    userGroupId?: boolean
  }

  export type ProviderStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProvidersDefaultArgs<ExtArgs>
    userGroup?: boolean | ProviderUserGroupsDefaultArgs<ExtArgs>
  }


  export type $ProviderStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderStaff"
    objects: {
      provider: Prisma.$ProvidersPayload<ExtArgs>
      userGroup: Prisma.$ProviderUserGroupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      providerStaffId: string
      created: string
      details: Prisma.JsonValue
      email: string
      notes: Prisma.JsonValue | null
      status: string
      providerId: string
      userGroupId: string
    }, ExtArgs["result"]["providerStaff"]>
    composites: {}
  }


  type ProviderStaffGetPayload<S extends boolean | null | undefined | ProviderStaffDefaultArgs> = $Result.GetResult<Prisma.$ProviderStaffPayload, S>

  type ProviderStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProviderStaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProviderStaffCountAggregateInputType | true
    }

  export interface ProviderStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderStaff'], meta: { name: 'ProviderStaff' } }
    /**
     * Find zero or one ProviderStaff that matches the filter.
     * @param {ProviderStaffFindUniqueArgs} args - Arguments to find a ProviderStaff
     * @example
     * // Get one ProviderStaff
     * const providerStaff = await prisma.providerStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderStaffFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffFindUniqueArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProviderStaff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProviderStaffFindUniqueOrThrowArgs} args - Arguments to find a ProviderStaff
     * @example
     * // Get one ProviderStaff
     * const providerStaff = await prisma.providerStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProviderStaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProviderStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffFindFirstArgs} args - Arguments to find a ProviderStaff
     * @example
     * // Get one ProviderStaff
     * const providerStaff = await prisma.providerStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderStaffFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffFindFirstArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProviderStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffFindFirstOrThrowArgs} args - Arguments to find a ProviderStaff
     * @example
     * // Get one ProviderStaff
     * const providerStaff = await prisma.providerStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProviderStaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProviderStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderStaffs
     * const providerStaffs = await prisma.providerStaff.findMany()
     * 
     * // Get first 10 ProviderStaffs
     * const providerStaffs = await prisma.providerStaff.findMany({ take: 10 })
     * 
     * // Only select the `providerStaffId`
     * const providerStaffWithProviderStaffIdOnly = await prisma.providerStaff.findMany({ select: { providerStaffId: true } })
     * 
    **/
    findMany<T extends ProviderStaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProviderStaff.
     * @param {ProviderStaffCreateArgs} args - Arguments to create a ProviderStaff.
     * @example
     * // Create one ProviderStaff
     * const ProviderStaff = await prisma.providerStaff.create({
     *   data: {
     *     // ... data to create a ProviderStaff
     *   }
     * })
     * 
    **/
    create<T extends ProviderStaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffCreateArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProviderStaffs.
     *     @param {ProviderStaffCreateManyArgs} args - Arguments to create many ProviderStaffs.
     *     @example
     *     // Create many ProviderStaffs
     *     const providerStaff = await prisma.providerStaff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProviderStaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProviderStaff.
     * @param {ProviderStaffDeleteArgs} args - Arguments to delete one ProviderStaff.
     * @example
     * // Delete one ProviderStaff
     * const ProviderStaff = await prisma.providerStaff.delete({
     *   where: {
     *     // ... filter to delete one ProviderStaff
     *   }
     * })
     * 
    **/
    delete<T extends ProviderStaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffDeleteArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProviderStaff.
     * @param {ProviderStaffUpdateArgs} args - Arguments to update one ProviderStaff.
     * @example
     * // Update one ProviderStaff
     * const providerStaff = await prisma.providerStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderStaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffUpdateArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProviderStaffs.
     * @param {ProviderStaffDeleteManyArgs} args - Arguments to filter ProviderStaffs to delete.
     * @example
     * // Delete a few ProviderStaffs
     * const { count } = await prisma.providerStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderStaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderStaffs
     * const providerStaff = await prisma.providerStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderStaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProviderStaff.
     * @param {ProviderStaffUpsertArgs} args - Arguments to update or create a ProviderStaff.
     * @example
     * // Update or create a ProviderStaff
     * const providerStaff = await prisma.providerStaff.upsert({
     *   create: {
     *     // ... data to create a ProviderStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderStaff we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderStaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffUpsertArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProviderStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffCountArgs} args - Arguments to filter ProviderStaffs to count.
     * @example
     * // Count the number of ProviderStaffs
     * const count = await prisma.providerStaff.count({
     *   where: {
     *     // ... the filter for the ProviderStaffs we want to count
     *   }
     * })
    **/
    count<T extends ProviderStaffCountArgs>(
      args?: Subset<T, ProviderStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderStaffAggregateArgs>(args: Subset<T, ProviderStaffAggregateArgs>): Prisma.PrismaPromise<GetProviderStaffAggregateType<T>>

    /**
     * Group by ProviderStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderStaffGroupByArgs['orderBy'] }
        : { orderBy?: ProviderStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderStaff model
   */
  readonly fields: ProviderStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    provider<T extends ProvidersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvidersDefaultArgs<ExtArgs>>): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    userGroup<T extends ProviderUserGroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderUserGroupsDefaultArgs<ExtArgs>>): Prisma__ProviderUserGroupsClient<$Result.GetResult<Prisma.$ProviderUserGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProviderStaff model
   */ 
  interface ProviderStaffFieldRefs {
    readonly providerStaffId: FieldRef<"ProviderStaff", 'String'>
    readonly created: FieldRef<"ProviderStaff", 'String'>
    readonly details: FieldRef<"ProviderStaff", 'Json'>
    readonly email: FieldRef<"ProviderStaff", 'String'>
    readonly notes: FieldRef<"ProviderStaff", 'Json'>
    readonly status: FieldRef<"ProviderStaff", 'String'>
    readonly providerId: FieldRef<"ProviderStaff", 'String'>
    readonly userGroupId: FieldRef<"ProviderStaff", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ProviderStaff findUnique
   */
  export type ProviderStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStaff to fetch.
     */
    where: ProviderStaffWhereUniqueInput
  }


  /**
   * ProviderStaff findUniqueOrThrow
   */
  export type ProviderStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStaff to fetch.
     */
    where: ProviderStaffWhereUniqueInput
  }


  /**
   * ProviderStaff findFirst
   */
  export type ProviderStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStaff to fetch.
     */
    where?: ProviderStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStaffs to fetch.
     */
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderStaffs.
     */
    cursor?: ProviderStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderStaffs.
     */
    distinct?: ProviderStaffScalarFieldEnum | ProviderStaffScalarFieldEnum[]
  }


  /**
   * ProviderStaff findFirstOrThrow
   */
  export type ProviderStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStaff to fetch.
     */
    where?: ProviderStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStaffs to fetch.
     */
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderStaffs.
     */
    cursor?: ProviderStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderStaffs.
     */
    distinct?: ProviderStaffScalarFieldEnum | ProviderStaffScalarFieldEnum[]
  }


  /**
   * ProviderStaff findMany
   */
  export type ProviderStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStaffs to fetch.
     */
    where?: ProviderStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStaffs to fetch.
     */
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderStaffs.
     */
    cursor?: ProviderStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStaffs.
     */
    skip?: number
    distinct?: ProviderStaffScalarFieldEnum | ProviderStaffScalarFieldEnum[]
  }


  /**
   * ProviderStaff create
   */
  export type ProviderStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderStaff.
     */
    data: XOR<ProviderStaffCreateInput, ProviderStaffUncheckedCreateInput>
  }


  /**
   * ProviderStaff createMany
   */
  export type ProviderStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderStaffs.
     */
    data: ProviderStaffCreateManyInput | ProviderStaffCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProviderStaff update
   */
  export type ProviderStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderStaff.
     */
    data: XOR<ProviderStaffUpdateInput, ProviderStaffUncheckedUpdateInput>
    /**
     * Choose, which ProviderStaff to update.
     */
    where: ProviderStaffWhereUniqueInput
  }


  /**
   * ProviderStaff updateMany
   */
  export type ProviderStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderStaffs.
     */
    data: XOR<ProviderStaffUpdateManyMutationInput, ProviderStaffUncheckedUpdateManyInput>
    /**
     * Filter which ProviderStaffs to update
     */
    where?: ProviderStaffWhereInput
  }


  /**
   * ProviderStaff upsert
   */
  export type ProviderStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderStaff to update in case it exists.
     */
    where: ProviderStaffWhereUniqueInput
    /**
     * In case the ProviderStaff found by the `where` argument doesn't exist, create a new ProviderStaff with this data.
     */
    create: XOR<ProviderStaffCreateInput, ProviderStaffUncheckedCreateInput>
    /**
     * In case the ProviderStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderStaffUpdateInput, ProviderStaffUncheckedUpdateInput>
  }


  /**
   * ProviderStaff delete
   */
  export type ProviderStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
    /**
     * Filter which ProviderStaff to delete.
     */
    where: ProviderStaffWhereUniqueInput
  }


  /**
   * ProviderStaff deleteMany
   */
  export type ProviderStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderStaffs to delete
     */
    where?: ProviderStaffWhereInput
  }


  /**
   * ProviderStaff without action
   */
  export type ProviderStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderStaffInclude<ExtArgs> | null
  }



  /**
   * Model Potentialproviders
   */

  export type AggregatePotentialproviders = {
    _count: PotentialprovidersCountAggregateOutputType | null
    _min: PotentialprovidersMinAggregateOutputType | null
    _max: PotentialprovidersMaxAggregateOutputType | null
  }

  export type PotentialprovidersMinAggregateOutputType = {
    id: string | null
    geoHash: string | null
    nationalPhoneNumber: string | null
    formattedAddress: string | null
    websiteUri: string | null
    name: string | null
    poid: string | null
  }

  export type PotentialprovidersMaxAggregateOutputType = {
    id: string | null
    geoHash: string | null
    nationalPhoneNumber: string | null
    formattedAddress: string | null
    websiteUri: string | null
    name: string | null
    poid: string | null
  }

  export type PotentialprovidersCountAggregateOutputType = {
    id: number
    types: number
    geoHash: number
    nationalPhoneNumber: number
    email: number
    formattedAddress: number
    websiteUri: number
    name: number
    poid: number
    _all: number
  }


  export type PotentialprovidersMinAggregateInputType = {
    id?: true
    geoHash?: true
    nationalPhoneNumber?: true
    formattedAddress?: true
    websiteUri?: true
    name?: true
    poid?: true
  }

  export type PotentialprovidersMaxAggregateInputType = {
    id?: true
    geoHash?: true
    nationalPhoneNumber?: true
    formattedAddress?: true
    websiteUri?: true
    name?: true
    poid?: true
  }

  export type PotentialprovidersCountAggregateInputType = {
    id?: true
    types?: true
    geoHash?: true
    nationalPhoneNumber?: true
    email?: true
    formattedAddress?: true
    websiteUri?: true
    name?: true
    poid?: true
    _all?: true
  }

  export type PotentialprovidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Potentialproviders to aggregate.
     */
    where?: PotentialprovidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potentialproviders to fetch.
     */
    orderBy?: PotentialprovidersOrderByWithRelationInput | PotentialprovidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PotentialprovidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potentialproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potentialproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Potentialproviders
    **/
    _count?: true | PotentialprovidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PotentialprovidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PotentialprovidersMaxAggregateInputType
  }

  export type GetPotentialprovidersAggregateType<T extends PotentialprovidersAggregateArgs> = {
        [P in keyof T & keyof AggregatePotentialproviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePotentialproviders[P]>
      : GetScalarType<T[P], AggregatePotentialproviders[P]>
  }




  export type PotentialprovidersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PotentialprovidersWhereInput
    orderBy?: PotentialprovidersOrderByWithAggregationInput | PotentialprovidersOrderByWithAggregationInput[]
    by: PotentialprovidersScalarFieldEnum[] | PotentialprovidersScalarFieldEnum
    having?: PotentialprovidersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PotentialprovidersCountAggregateInputType | true
    _min?: PotentialprovidersMinAggregateInputType
    _max?: PotentialprovidersMaxAggregateInputType
  }

  export type PotentialprovidersGroupByOutputType = {
    id: string
    types: string[]
    geoHash: string
    nationalPhoneNumber: string
    email: string[]
    formattedAddress: string
    websiteUri: string
    name: string
    poid: string
    _count: PotentialprovidersCountAggregateOutputType | null
    _min: PotentialprovidersMinAggregateOutputType | null
    _max: PotentialprovidersMaxAggregateOutputType | null
  }

  type GetPotentialprovidersGroupByPayload<T extends PotentialprovidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PotentialprovidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PotentialprovidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PotentialprovidersGroupByOutputType[P]>
            : GetScalarType<T[P], PotentialprovidersGroupByOutputType[P]>
        }
      >
    >


  export type PotentialprovidersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    types?: boolean
    geoHash?: boolean
    nationalPhoneNumber?: boolean
    email?: boolean
    formattedAddress?: boolean
    websiteUri?: boolean
    name?: boolean
    poid?: boolean
    pointOfOrigin?: boolean | pointOfOriginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["potentialproviders"]>

  export type PotentialprovidersSelectScalar = {
    id?: boolean
    types?: boolean
    geoHash?: boolean
    nationalPhoneNumber?: boolean
    email?: boolean
    formattedAddress?: boolean
    websiteUri?: boolean
    name?: boolean
    poid?: boolean
  }

  export type PotentialprovidersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointOfOrigin?: boolean | pointOfOriginDefaultArgs<ExtArgs>
  }


  export type $PotentialprovidersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Potentialproviders"
    objects: {
      pointOfOrigin: Prisma.$pointOfOriginPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      types: string[]
      geoHash: string
      nationalPhoneNumber: string
      email: string[]
      formattedAddress: string
      websiteUri: string
      name: string
      poid: string
    }, ExtArgs["result"]["potentialproviders"]>
    composites: {}
  }


  type PotentialprovidersGetPayload<S extends boolean | null | undefined | PotentialprovidersDefaultArgs> = $Result.GetResult<Prisma.$PotentialprovidersPayload, S>

  type PotentialprovidersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PotentialprovidersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PotentialprovidersCountAggregateInputType | true
    }

  export interface PotentialprovidersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Potentialproviders'], meta: { name: 'Potentialproviders' } }
    /**
     * Find zero or one Potentialproviders that matches the filter.
     * @param {PotentialprovidersFindUniqueArgs} args - Arguments to find a Potentialproviders
     * @example
     * // Get one Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PotentialprovidersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PotentialprovidersFindUniqueArgs<ExtArgs>>
    ): Prisma__PotentialprovidersClient<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Potentialproviders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PotentialprovidersFindUniqueOrThrowArgs} args - Arguments to find a Potentialproviders
     * @example
     * // Get one Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PotentialprovidersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PotentialprovidersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PotentialprovidersClient<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Potentialproviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotentialprovidersFindFirstArgs} args - Arguments to find a Potentialproviders
     * @example
     * // Get one Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PotentialprovidersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PotentialprovidersFindFirstArgs<ExtArgs>>
    ): Prisma__PotentialprovidersClient<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Potentialproviders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotentialprovidersFindFirstOrThrowArgs} args - Arguments to find a Potentialproviders
     * @example
     * // Get one Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PotentialprovidersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PotentialprovidersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PotentialprovidersClient<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Potentialproviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotentialprovidersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.findMany()
     * 
     * // Get first 10 Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const potentialprovidersWithIdOnly = await prisma.potentialproviders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PotentialprovidersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PotentialprovidersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Potentialproviders.
     * @param {PotentialprovidersCreateArgs} args - Arguments to create a Potentialproviders.
     * @example
     * // Create one Potentialproviders
     * const Potentialproviders = await prisma.potentialproviders.create({
     *   data: {
     *     // ... data to create a Potentialproviders
     *   }
     * })
     * 
    **/
    create<T extends PotentialprovidersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PotentialprovidersCreateArgs<ExtArgs>>
    ): Prisma__PotentialprovidersClient<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Potentialproviders.
     *     @param {PotentialprovidersCreateManyArgs} args - Arguments to create many Potentialproviders.
     *     @example
     *     // Create many Potentialproviders
     *     const potentialproviders = await prisma.potentialproviders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PotentialprovidersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PotentialprovidersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Potentialproviders.
     * @param {PotentialprovidersDeleteArgs} args - Arguments to delete one Potentialproviders.
     * @example
     * // Delete one Potentialproviders
     * const Potentialproviders = await prisma.potentialproviders.delete({
     *   where: {
     *     // ... filter to delete one Potentialproviders
     *   }
     * })
     * 
    **/
    delete<T extends PotentialprovidersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PotentialprovidersDeleteArgs<ExtArgs>>
    ): Prisma__PotentialprovidersClient<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Potentialproviders.
     * @param {PotentialprovidersUpdateArgs} args - Arguments to update one Potentialproviders.
     * @example
     * // Update one Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PotentialprovidersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PotentialprovidersUpdateArgs<ExtArgs>>
    ): Prisma__PotentialprovidersClient<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Potentialproviders.
     * @param {PotentialprovidersDeleteManyArgs} args - Arguments to filter Potentialproviders to delete.
     * @example
     * // Delete a few Potentialproviders
     * const { count } = await prisma.potentialproviders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PotentialprovidersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PotentialprovidersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Potentialproviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotentialprovidersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PotentialprovidersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PotentialprovidersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Potentialproviders.
     * @param {PotentialprovidersUpsertArgs} args - Arguments to update or create a Potentialproviders.
     * @example
     * // Update or create a Potentialproviders
     * const potentialproviders = await prisma.potentialproviders.upsert({
     *   create: {
     *     // ... data to create a Potentialproviders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Potentialproviders we want to update
     *   }
     * })
    **/
    upsert<T extends PotentialprovidersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PotentialprovidersUpsertArgs<ExtArgs>>
    ): Prisma__PotentialprovidersClient<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Potentialproviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotentialprovidersCountArgs} args - Arguments to filter Potentialproviders to count.
     * @example
     * // Count the number of Potentialproviders
     * const count = await prisma.potentialproviders.count({
     *   where: {
     *     // ... the filter for the Potentialproviders we want to count
     *   }
     * })
    **/
    count<T extends PotentialprovidersCountArgs>(
      args?: Subset<T, PotentialprovidersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PotentialprovidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Potentialproviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotentialprovidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PotentialprovidersAggregateArgs>(args: Subset<T, PotentialprovidersAggregateArgs>): Prisma.PrismaPromise<GetPotentialprovidersAggregateType<T>>

    /**
     * Group by Potentialproviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotentialprovidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PotentialprovidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PotentialprovidersGroupByArgs['orderBy'] }
        : { orderBy?: PotentialprovidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PotentialprovidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPotentialprovidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Potentialproviders model
   */
  readonly fields: PotentialprovidersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Potentialproviders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PotentialprovidersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pointOfOrigin<T extends pointOfOriginDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pointOfOriginDefaultArgs<ExtArgs>>): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Potentialproviders model
   */ 
  interface PotentialprovidersFieldRefs {
    readonly id: FieldRef<"Potentialproviders", 'String'>
    readonly types: FieldRef<"Potentialproviders", 'String[]'>
    readonly geoHash: FieldRef<"Potentialproviders", 'String'>
    readonly nationalPhoneNumber: FieldRef<"Potentialproviders", 'String'>
    readonly email: FieldRef<"Potentialproviders", 'String[]'>
    readonly formattedAddress: FieldRef<"Potentialproviders", 'String'>
    readonly websiteUri: FieldRef<"Potentialproviders", 'String'>
    readonly name: FieldRef<"Potentialproviders", 'String'>
    readonly poid: FieldRef<"Potentialproviders", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Potentialproviders findUnique
   */
  export type PotentialprovidersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * Filter, which Potentialproviders to fetch.
     */
    where: PotentialprovidersWhereUniqueInput
  }


  /**
   * Potentialproviders findUniqueOrThrow
   */
  export type PotentialprovidersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * Filter, which Potentialproviders to fetch.
     */
    where: PotentialprovidersWhereUniqueInput
  }


  /**
   * Potentialproviders findFirst
   */
  export type PotentialprovidersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * Filter, which Potentialproviders to fetch.
     */
    where?: PotentialprovidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potentialproviders to fetch.
     */
    orderBy?: PotentialprovidersOrderByWithRelationInput | PotentialprovidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Potentialproviders.
     */
    cursor?: PotentialprovidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potentialproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potentialproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Potentialproviders.
     */
    distinct?: PotentialprovidersScalarFieldEnum | PotentialprovidersScalarFieldEnum[]
  }


  /**
   * Potentialproviders findFirstOrThrow
   */
  export type PotentialprovidersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * Filter, which Potentialproviders to fetch.
     */
    where?: PotentialprovidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potentialproviders to fetch.
     */
    orderBy?: PotentialprovidersOrderByWithRelationInput | PotentialprovidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Potentialproviders.
     */
    cursor?: PotentialprovidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potentialproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potentialproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Potentialproviders.
     */
    distinct?: PotentialprovidersScalarFieldEnum | PotentialprovidersScalarFieldEnum[]
  }


  /**
   * Potentialproviders findMany
   */
  export type PotentialprovidersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * Filter, which Potentialproviders to fetch.
     */
    where?: PotentialprovidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potentialproviders to fetch.
     */
    orderBy?: PotentialprovidersOrderByWithRelationInput | PotentialprovidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Potentialproviders.
     */
    cursor?: PotentialprovidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potentialproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potentialproviders.
     */
    skip?: number
    distinct?: PotentialprovidersScalarFieldEnum | PotentialprovidersScalarFieldEnum[]
  }


  /**
   * Potentialproviders create
   */
  export type PotentialprovidersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * The data needed to create a Potentialproviders.
     */
    data: XOR<PotentialprovidersCreateInput, PotentialprovidersUncheckedCreateInput>
  }


  /**
   * Potentialproviders createMany
   */
  export type PotentialprovidersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Potentialproviders.
     */
    data: PotentialprovidersCreateManyInput | PotentialprovidersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Potentialproviders update
   */
  export type PotentialprovidersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * The data needed to update a Potentialproviders.
     */
    data: XOR<PotentialprovidersUpdateInput, PotentialprovidersUncheckedUpdateInput>
    /**
     * Choose, which Potentialproviders to update.
     */
    where: PotentialprovidersWhereUniqueInput
  }


  /**
   * Potentialproviders updateMany
   */
  export type PotentialprovidersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Potentialproviders.
     */
    data: XOR<PotentialprovidersUpdateManyMutationInput, PotentialprovidersUncheckedUpdateManyInput>
    /**
     * Filter which Potentialproviders to update
     */
    where?: PotentialprovidersWhereInput
  }


  /**
   * Potentialproviders upsert
   */
  export type PotentialprovidersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * The filter to search for the Potentialproviders to update in case it exists.
     */
    where: PotentialprovidersWhereUniqueInput
    /**
     * In case the Potentialproviders found by the `where` argument doesn't exist, create a new Potentialproviders with this data.
     */
    create: XOR<PotentialprovidersCreateInput, PotentialprovidersUncheckedCreateInput>
    /**
     * In case the Potentialproviders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PotentialprovidersUpdateInput, PotentialprovidersUncheckedUpdateInput>
  }


  /**
   * Potentialproviders delete
   */
  export type PotentialprovidersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    /**
     * Filter which Potentialproviders to delete.
     */
    where: PotentialprovidersWhereUniqueInput
  }


  /**
   * Potentialproviders deleteMany
   */
  export type PotentialprovidersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Potentialproviders to delete
     */
    where?: PotentialprovidersWhereInput
  }


  /**
   * Potentialproviders without action
   */
  export type PotentialprovidersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
  }



  /**
   * Model pointOfOrigin
   */

  export type AggregatePointOfOrigin = {
    _count: PointOfOriginCountAggregateOutputType | null
    _min: PointOfOriginMinAggregateOutputType | null
    _max: PointOfOriginMaxAggregateOutputType | null
  }

  export type PointOfOriginMinAggregateOutputType = {
    poid: string | null
    Name: string | null
    geoHash: string | null
  }

  export type PointOfOriginMaxAggregateOutputType = {
    poid: string | null
    Name: string | null
    geoHash: string | null
  }

  export type PointOfOriginCountAggregateOutputType = {
    poid: number
    Name: number
    geoHash: number
    _all: number
  }


  export type PointOfOriginMinAggregateInputType = {
    poid?: true
    Name?: true
    geoHash?: true
  }

  export type PointOfOriginMaxAggregateInputType = {
    poid?: true
    Name?: true
    geoHash?: true
  }

  export type PointOfOriginCountAggregateInputType = {
    poid?: true
    Name?: true
    geoHash?: true
    _all?: true
  }

  export type PointOfOriginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pointOfOrigin to aggregate.
     */
    where?: pointOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pointOfOrigins to fetch.
     */
    orderBy?: pointOfOriginOrderByWithRelationInput | pointOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pointOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pointOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pointOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pointOfOrigins
    **/
    _count?: true | PointOfOriginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointOfOriginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointOfOriginMaxAggregateInputType
  }

  export type GetPointOfOriginAggregateType<T extends PointOfOriginAggregateArgs> = {
        [P in keyof T & keyof AggregatePointOfOrigin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointOfOrigin[P]>
      : GetScalarType<T[P], AggregatePointOfOrigin[P]>
  }




  export type pointOfOriginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pointOfOriginWhereInput
    orderBy?: pointOfOriginOrderByWithAggregationInput | pointOfOriginOrderByWithAggregationInput[]
    by: PointOfOriginScalarFieldEnum[] | PointOfOriginScalarFieldEnum
    having?: pointOfOriginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointOfOriginCountAggregateInputType | true
    _min?: PointOfOriginMinAggregateInputType
    _max?: PointOfOriginMaxAggregateInputType
  }

  export type PointOfOriginGroupByOutputType = {
    poid: string
    Name: string
    geoHash: string
    _count: PointOfOriginCountAggregateOutputType | null
    _min: PointOfOriginMinAggregateOutputType | null
    _max: PointOfOriginMaxAggregateOutputType | null
  }

  type GetPointOfOriginGroupByPayload<T extends pointOfOriginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointOfOriginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointOfOriginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointOfOriginGroupByOutputType[P]>
            : GetScalarType<T[P], PointOfOriginGroupByOutputType[P]>
        }
      >
    >


  export type pointOfOriginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    poid?: boolean
    Name?: boolean
    geoHash?: boolean
    Potentialproviders?: boolean | pointOfOrigin$PotentialprovidersArgs<ExtArgs>
    _count?: boolean | PointOfOriginCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointOfOrigin"]>

  export type pointOfOriginSelectScalar = {
    poid?: boolean
    Name?: boolean
    geoHash?: boolean
  }

  export type pointOfOriginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Potentialproviders?: boolean | pointOfOrigin$PotentialprovidersArgs<ExtArgs>
    _count?: boolean | PointOfOriginCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $pointOfOriginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pointOfOrigin"
    objects: {
      Potentialproviders: Prisma.$PotentialprovidersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      poid: string
      Name: string
      geoHash: string
    }, ExtArgs["result"]["pointOfOrigin"]>
    composites: {}
  }


  type pointOfOriginGetPayload<S extends boolean | null | undefined | pointOfOriginDefaultArgs> = $Result.GetResult<Prisma.$pointOfOriginPayload, S>

  type pointOfOriginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pointOfOriginFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PointOfOriginCountAggregateInputType | true
    }

  export interface pointOfOriginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pointOfOrigin'], meta: { name: 'pointOfOrigin' } }
    /**
     * Find zero or one PointOfOrigin that matches the filter.
     * @param {pointOfOriginFindUniqueArgs} args - Arguments to find a PointOfOrigin
     * @example
     * // Get one PointOfOrigin
     * const pointOfOrigin = await prisma.pointOfOrigin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pointOfOriginFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, pointOfOriginFindUniqueArgs<ExtArgs>>
    ): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PointOfOrigin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pointOfOriginFindUniqueOrThrowArgs} args - Arguments to find a PointOfOrigin
     * @example
     * // Get one PointOfOrigin
     * const pointOfOrigin = await prisma.pointOfOrigin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pointOfOriginFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pointOfOriginFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PointOfOrigin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pointOfOriginFindFirstArgs} args - Arguments to find a PointOfOrigin
     * @example
     * // Get one PointOfOrigin
     * const pointOfOrigin = await prisma.pointOfOrigin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pointOfOriginFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, pointOfOriginFindFirstArgs<ExtArgs>>
    ): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PointOfOrigin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pointOfOriginFindFirstOrThrowArgs} args - Arguments to find a PointOfOrigin
     * @example
     * // Get one PointOfOrigin
     * const pointOfOrigin = await prisma.pointOfOrigin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pointOfOriginFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, pointOfOriginFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PointOfOrigins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pointOfOriginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointOfOrigins
     * const pointOfOrigins = await prisma.pointOfOrigin.findMany()
     * 
     * // Get first 10 PointOfOrigins
     * const pointOfOrigins = await prisma.pointOfOrigin.findMany({ take: 10 })
     * 
     * // Only select the `poid`
     * const pointOfOriginWithPoidOnly = await prisma.pointOfOrigin.findMany({ select: { poid: true } })
     * 
    **/
    findMany<T extends pointOfOriginFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pointOfOriginFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PointOfOrigin.
     * @param {pointOfOriginCreateArgs} args - Arguments to create a PointOfOrigin.
     * @example
     * // Create one PointOfOrigin
     * const PointOfOrigin = await prisma.pointOfOrigin.create({
     *   data: {
     *     // ... data to create a PointOfOrigin
     *   }
     * })
     * 
    **/
    create<T extends pointOfOriginCreateArgs<ExtArgs>>(
      args: SelectSubset<T, pointOfOriginCreateArgs<ExtArgs>>
    ): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PointOfOrigins.
     *     @param {pointOfOriginCreateManyArgs} args - Arguments to create many PointOfOrigins.
     *     @example
     *     // Create many PointOfOrigins
     *     const pointOfOrigin = await prisma.pointOfOrigin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pointOfOriginCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pointOfOriginCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PointOfOrigin.
     * @param {pointOfOriginDeleteArgs} args - Arguments to delete one PointOfOrigin.
     * @example
     * // Delete one PointOfOrigin
     * const PointOfOrigin = await prisma.pointOfOrigin.delete({
     *   where: {
     *     // ... filter to delete one PointOfOrigin
     *   }
     * })
     * 
    **/
    delete<T extends pointOfOriginDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, pointOfOriginDeleteArgs<ExtArgs>>
    ): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PointOfOrigin.
     * @param {pointOfOriginUpdateArgs} args - Arguments to update one PointOfOrigin.
     * @example
     * // Update one PointOfOrigin
     * const pointOfOrigin = await prisma.pointOfOrigin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pointOfOriginUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, pointOfOriginUpdateArgs<ExtArgs>>
    ): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PointOfOrigins.
     * @param {pointOfOriginDeleteManyArgs} args - Arguments to filter PointOfOrigins to delete.
     * @example
     * // Delete a few PointOfOrigins
     * const { count } = await prisma.pointOfOrigin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pointOfOriginDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, pointOfOriginDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointOfOrigins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pointOfOriginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointOfOrigins
     * const pointOfOrigin = await prisma.pointOfOrigin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pointOfOriginUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, pointOfOriginUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PointOfOrigin.
     * @param {pointOfOriginUpsertArgs} args - Arguments to update or create a PointOfOrigin.
     * @example
     * // Update or create a PointOfOrigin
     * const pointOfOrigin = await prisma.pointOfOrigin.upsert({
     *   create: {
     *     // ... data to create a PointOfOrigin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointOfOrigin we want to update
     *   }
     * })
    **/
    upsert<T extends pointOfOriginUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, pointOfOriginUpsertArgs<ExtArgs>>
    ): Prisma__pointOfOriginClient<$Result.GetResult<Prisma.$pointOfOriginPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PointOfOrigins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pointOfOriginCountArgs} args - Arguments to filter PointOfOrigins to count.
     * @example
     * // Count the number of PointOfOrigins
     * const count = await prisma.pointOfOrigin.count({
     *   where: {
     *     // ... the filter for the PointOfOrigins we want to count
     *   }
     * })
    **/
    count<T extends pointOfOriginCountArgs>(
      args?: Subset<T, pointOfOriginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointOfOriginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointOfOrigin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointOfOriginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointOfOriginAggregateArgs>(args: Subset<T, PointOfOriginAggregateArgs>): Prisma.PrismaPromise<GetPointOfOriginAggregateType<T>>

    /**
     * Group by PointOfOrigin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pointOfOriginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pointOfOriginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pointOfOriginGroupByArgs['orderBy'] }
        : { orderBy?: pointOfOriginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pointOfOriginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointOfOriginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pointOfOrigin model
   */
  readonly fields: pointOfOriginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pointOfOrigin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pointOfOriginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Potentialproviders<T extends pointOfOrigin$PotentialprovidersArgs<ExtArgs> = {}>(args?: Subset<T, pointOfOrigin$PotentialprovidersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PotentialprovidersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the pointOfOrigin model
   */ 
  interface pointOfOriginFieldRefs {
    readonly poid: FieldRef<"pointOfOrigin", 'String'>
    readonly Name: FieldRef<"pointOfOrigin", 'String'>
    readonly geoHash: FieldRef<"pointOfOrigin", 'String'>
  }
    

  // Custom InputTypes

  /**
   * pointOfOrigin findUnique
   */
  export type pointOfOriginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which pointOfOrigin to fetch.
     */
    where: pointOfOriginWhereUniqueInput
  }


  /**
   * pointOfOrigin findUniqueOrThrow
   */
  export type pointOfOriginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which pointOfOrigin to fetch.
     */
    where: pointOfOriginWhereUniqueInput
  }


  /**
   * pointOfOrigin findFirst
   */
  export type pointOfOriginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which pointOfOrigin to fetch.
     */
    where?: pointOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pointOfOrigins to fetch.
     */
    orderBy?: pointOfOriginOrderByWithRelationInput | pointOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pointOfOrigins.
     */
    cursor?: pointOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pointOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pointOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pointOfOrigins.
     */
    distinct?: PointOfOriginScalarFieldEnum | PointOfOriginScalarFieldEnum[]
  }


  /**
   * pointOfOrigin findFirstOrThrow
   */
  export type pointOfOriginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which pointOfOrigin to fetch.
     */
    where?: pointOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pointOfOrigins to fetch.
     */
    orderBy?: pointOfOriginOrderByWithRelationInput | pointOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pointOfOrigins.
     */
    cursor?: pointOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pointOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pointOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pointOfOrigins.
     */
    distinct?: PointOfOriginScalarFieldEnum | PointOfOriginScalarFieldEnum[]
  }


  /**
   * pointOfOrigin findMany
   */
  export type pointOfOriginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which pointOfOrigins to fetch.
     */
    where?: pointOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pointOfOrigins to fetch.
     */
    orderBy?: pointOfOriginOrderByWithRelationInput | pointOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pointOfOrigins.
     */
    cursor?: pointOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pointOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pointOfOrigins.
     */
    skip?: number
    distinct?: PointOfOriginScalarFieldEnum | PointOfOriginScalarFieldEnum[]
  }


  /**
   * pointOfOrigin create
   */
  export type pointOfOriginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * The data needed to create a pointOfOrigin.
     */
    data: XOR<pointOfOriginCreateInput, pointOfOriginUncheckedCreateInput>
  }


  /**
   * pointOfOrigin createMany
   */
  export type pointOfOriginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pointOfOrigins.
     */
    data: pointOfOriginCreateManyInput | pointOfOriginCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * pointOfOrigin update
   */
  export type pointOfOriginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * The data needed to update a pointOfOrigin.
     */
    data: XOR<pointOfOriginUpdateInput, pointOfOriginUncheckedUpdateInput>
    /**
     * Choose, which pointOfOrigin to update.
     */
    where: pointOfOriginWhereUniqueInput
  }


  /**
   * pointOfOrigin updateMany
   */
  export type pointOfOriginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pointOfOrigins.
     */
    data: XOR<pointOfOriginUpdateManyMutationInput, pointOfOriginUncheckedUpdateManyInput>
    /**
     * Filter which pointOfOrigins to update
     */
    where?: pointOfOriginWhereInput
  }


  /**
   * pointOfOrigin upsert
   */
  export type pointOfOriginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * The filter to search for the pointOfOrigin to update in case it exists.
     */
    where: pointOfOriginWhereUniqueInput
    /**
     * In case the pointOfOrigin found by the `where` argument doesn't exist, create a new pointOfOrigin with this data.
     */
    create: XOR<pointOfOriginCreateInput, pointOfOriginUncheckedCreateInput>
    /**
     * In case the pointOfOrigin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pointOfOriginUpdateInput, pointOfOriginUncheckedUpdateInput>
  }


  /**
   * pointOfOrigin delete
   */
  export type pointOfOriginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
    /**
     * Filter which pointOfOrigin to delete.
     */
    where: pointOfOriginWhereUniqueInput
  }


  /**
   * pointOfOrigin deleteMany
   */
  export type pointOfOriginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pointOfOrigins to delete
     */
    where?: pointOfOriginWhereInput
  }


  /**
   * pointOfOrigin.Potentialproviders
   */
  export type pointOfOrigin$PotentialprovidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Potentialproviders
     */
    select?: PotentialprovidersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PotentialprovidersInclude<ExtArgs> | null
    where?: PotentialprovidersWhereInput
    orderBy?: PotentialprovidersOrderByWithRelationInput | PotentialprovidersOrderByWithRelationInput[]
    cursor?: PotentialprovidersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PotentialprovidersScalarFieldEnum | PotentialprovidersScalarFieldEnum[]
  }


  /**
   * pointOfOrigin without action
   */
  export type pointOfOriginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pointOfOrigin
     */
    select?: pointOfOriginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pointOfOriginInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AddressesScalarFieldEnum: {
    addressId: 'addressId',
    name: 'name',
    stage: 'stage',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    country: 'country',
    email: 'email',
    geoHash: 'geoHash',
    locality: 'locality',
    phone: 'phone',
    postal_code: 'postal_code',
    instituteId: 'instituteId',
    providerId: 'providerId'
  };

  export type AddressesScalarFieldEnum = (typeof AddressesScalarFieldEnum)[keyof typeof AddressesScalarFieldEnum]


  export const CohortsScalarFieldEnum: {
    cohortId: 'cohortId',
    designatedStaff: 'designatedStaff',
    stage: 'stage',
    placementType: 'placementType',
    name: 'name',
    startPlacements: 'startPlacements',
    endPlacements: 'endPlacements',
    startSubmission: 'startSubmission',
    endSubmission: 'endSubmission',
    includedFiles: 'includedFiles',
    includedForms: 'includedForms',
    workflow: 'workflow',
    instituteId: 'instituteId'
  };

  export type CohortsScalarFieldEnum = (typeof CohortsScalarFieldEnum)[keyof typeof CohortsScalarFieldEnum]


  export const ProviderCohortsScalarFieldEnum: {
    cohortId: 'cohortId',
    stage: 'stage',
    name: 'name',
    addressId: 'addressId',
    providerId: 'providerId'
  };

  export type ProviderCohortsScalarFieldEnum = (typeof ProviderCohortsScalarFieldEnum)[keyof typeof ProviderCohortsScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    contactId: 'contactId',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    created: 'created',
    name: 'name',
    providerPhone: 'providerPhone',
    InstituteStudentUserId: 'InstituteStudentUserId',
    addressId: 'addressId',
    studentUserId: 'studentUserId'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const InstituteFormsScalarFieldEnum: {
    formId: 'formId',
    form: 'form',
    updated: 'updated',
    instituteId: 'instituteId'
  };

  export type InstituteFormsScalarFieldEnum = (typeof InstituteFormsScalarFieldEnum)[keyof typeof InstituteFormsScalarFieldEnum]


  export const InstitutesScalarFieldEnum: {
    instituteId: 'instituteId',
    admin: 'admin',
    externalProviderUploads: 'externalProviderUploads',
    name: 'name',
    referral: 'referral',
    status: 'status',
    studentsFields: 'studentsFields',
    staff: 'staff',
    staffActive: 'staffActive',
    students: 'students',
    studentsActive: 'studentsActive',
    staffFields: 'staffFields',
    staffGuidance: 'staffGuidance',
    studentsGuidance: 'studentsGuidance',
    verifiedProviders: 'verifiedProviders'
  };

  export type InstitutesScalarFieldEnum = (typeof InstitutesScalarFieldEnum)[keyof typeof InstitutesScalarFieldEnum]


  export const LogsScalarFieldEnum: {
    logId: 'logId',
    provider: 'provider',
    students: 'students',
    staff: 'staff',
    uid: 'uid',
    placementId: 'placementId'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const PlacementListingsScalarFieldEnum: {
    placementListingId: 'placementListingId',
    addressId: 'addressId',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    created: 'created',
    mapConsent: 'mapConsent',
    mapConsentDate: 'mapConsentDate',
    providerEmail: 'providerEmail',
    providerId: 'providerId',
    providerPhone: 'providerPhone',
    savedBy: 'savedBy',
    questions: 'questions',
    title: 'title',
    uploadedBy: 'uploadedBy'
  };

  export type PlacementListingsScalarFieldEnum = (typeof PlacementListingsScalarFieldEnum)[keyof typeof PlacementListingsScalarFieldEnum]


  export const PlacementsScalarFieldEnum: {
    placementId: 'placementId',
    activeDates: 'activeDates',
    cohortId: 'cohortId',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    created: 'created',
    draft: 'draft',
    endDate: 'endDate',
    flags: 'flags',
    geoHash: 'geoHash',
    inProgress: 'inProgress',
    leadTimes: 'leadTimes',
    name: 'name',
    parentEmailed: 'parentEmailed',
    parentExpiry: 'parentExpiry',
    parentKey: 'parentKey',
    product: 'product',
    providerEmail: 'providerEmail',
    providerEmailed: 'providerEmailed',
    providerExpiry: 'providerExpiry',
    providerKey: 'providerKey',
    providerName: 'providerName',
    providerPhone: 'providerPhone',
    nextStatus: 'nextStatus',
    status: 'status',
    startDate: 'startDate',
    title: 'title',
    forms: 'forms',
    questions: 'questions',
    uploadedBy: 'uploadedBy',
    addressId: 'addressId',
    instituteId: 'instituteId',
    instituteStudentId: 'instituteStudentId',
    providerId: 'providerId',
    studentId: 'studentId',
    userGroupId: 'userGroupId'
  };

  export type PlacementsScalarFieldEnum = (typeof PlacementsScalarFieldEnum)[keyof typeof PlacementsScalarFieldEnum]


  export const ProvidersScalarFieldEnum: {
    providerId: 'providerId',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    email: 'email',
    mapConsent: 'mapConsent',
    insurance: 'insurance',
    mapConsentDate: 'mapConsentDate',
    name: 'name',
    phone: 'phone',
    rememberConsent: 'rememberConsent',
    rememberConsentDate: 'rememberConsentDate',
    savedBy: 'savedBy',
    sector: 'sector',
    referral: 'referral',
    subsector: 'subsector',
    uploadedBy: 'uploadedBy',
    website: 'website',
    activationCode: 'activationCode',
    status: 'status'
  };

  export type ProvidersScalarFieldEnum = (typeof ProvidersScalarFieldEnum)[keyof typeof ProvidersScalarFieldEnum]


  export const InstituteStudentUserGroupsScalarFieldEnum: {
    userGroupId: 'userGroupId',
    default: 'default',
    name: 'name',
    updated: 'updated',
    instituteId: 'instituteId'
  };

  export type InstituteStudentUserGroupsScalarFieldEnum = (typeof InstituteStudentUserGroupsScalarFieldEnum)[keyof typeof InstituteStudentUserGroupsScalarFieldEnum]


  export const InstituteStaffUserGroupsScalarFieldEnum: {
    userGroupId: 'userGroupId',
    default: 'default',
    name: 'name',
    updated: 'updated',
    instituteId: 'instituteId'
  };

  export type InstituteStaffUserGroupsScalarFieldEnum = (typeof InstituteStaffUserGroupsScalarFieldEnum)[keyof typeof InstituteStaffUserGroupsScalarFieldEnum]


  export const ProviderUserGroupsScalarFieldEnum: {
    userGroupId: 'userGroupId',
    default: 'default',
    name: 'name',
    updated: 'updated',
    providerId: 'providerId'
  };

  export type ProviderUserGroupsScalarFieldEnum = (typeof ProviderUserGroupsScalarFieldEnum)[keyof typeof ProviderUserGroupsScalarFieldEnum]


  export const StudentUsersScalarFieldEnum: {
    studentUserId: 'studentUserId',
    status: 'status',
    analytics: 'analytics',
    created: 'created',
    details: 'details',
    email: 'email',
    referral: 'referral',
    units: 'units',
    userType: 'userType'
  };

  export type StudentUsersScalarFieldEnum = (typeof StudentUsersScalarFieldEnum)[keyof typeof StudentUsersScalarFieldEnum]


  export const InstituteStaffScalarFieldEnum: {
    instituteStaffId: 'instituteStaffId',
    created: 'created',
    details: 'details',
    email: 'email',
    oId: 'oId',
    status: 'status',
    userType: 'userType',
    instituteId: 'instituteId',
    userGroupId: 'userGroupId'
  };

  export type InstituteStaffScalarFieldEnum = (typeof InstituteStaffScalarFieldEnum)[keyof typeof InstituteStaffScalarFieldEnum]


  export const InstituteStudentsScalarFieldEnum: {
    instituteStudentId: 'instituteStudentId',
    activated: 'activated',
    created: 'created',
    cohortId: 'cohortId',
    details: 'details',
    email: 'email',
    flags: 'flags',
    oId: 'oId',
    resetExpiry: 'resetExpiry',
    status: 'status',
    userType: 'userType',
    instituteId: 'instituteId',
    userGroupId: 'userGroupId'
  };

  export type InstituteStudentsScalarFieldEnum = (typeof InstituteStudentsScalarFieldEnum)[keyof typeof InstituteStudentsScalarFieldEnum]


  export const ProviderStaffScalarFieldEnum: {
    providerStaffId: 'providerStaffId',
    created: 'created',
    details: 'details',
    email: 'email',
    notes: 'notes',
    status: 'status',
    providerId: 'providerId',
    userGroupId: 'userGroupId'
  };

  export type ProviderStaffScalarFieldEnum = (typeof ProviderStaffScalarFieldEnum)[keyof typeof ProviderStaffScalarFieldEnum]


  export const PotentialprovidersScalarFieldEnum: {
    id: 'id',
    types: 'types',
    geoHash: 'geoHash',
    nationalPhoneNumber: 'nationalPhoneNumber',
    email: 'email',
    formattedAddress: 'formattedAddress',
    websiteUri: 'websiteUri',
    name: 'name',
    poid: 'poid'
  };

  export type PotentialprovidersScalarFieldEnum = (typeof PotentialprovidersScalarFieldEnum)[keyof typeof PotentialprovidersScalarFieldEnum]


  export const PointOfOriginScalarFieldEnum: {
    poid: 'poid',
    Name: 'Name',
    geoHash: 'geoHash'
  };

  export type PointOfOriginScalarFieldEnum = (typeof PointOfOriginScalarFieldEnum)[keyof typeof PointOfOriginScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AddressesWhereInput = {
    AND?: AddressesWhereInput | AddressesWhereInput[]
    OR?: AddressesWhereInput[]
    NOT?: AddressesWhereInput | AddressesWhereInput[]
    addressId?: StringFilter<"Addresses"> | string
    name?: StringFilter<"Addresses"> | string
    stage?: StringNullableFilter<"Addresses"> | string | null
    addressLine1?: StringNullableFilter<"Addresses"> | string | null
    addressLine2?: StringNullableFilter<"Addresses"> | string | null
    contactForename?: StringNullableFilter<"Addresses"> | string | null
    contactSurname?: StringNullableFilter<"Addresses"> | string | null
    country?: StringNullableFilter<"Addresses"> | string | null
    email?: StringNullableFilter<"Addresses"> | string | null
    geoHash?: StringNullableFilter<"Addresses"> | string | null
    locality?: StringNullableFilter<"Addresses"> | string | null
    phone?: StringNullableFilter<"Addresses"> | string | null
    postal_code?: StringNullableFilter<"Addresses"> | string | null
    instituteId?: StringNullableFilter<"Addresses"> | string | null
    providerId?: StringNullableFilter<"Addresses"> | string | null
    institute?: XOR<InstitutesNullableRelationFilter, InstitutesWhereInput> | null
    provider?: XOR<ProvidersNullableRelationFilter, ProvidersWhereInput> | null
    Contacts?: ContactsListRelationFilter
    PlacementListings?: PlacementListingsListRelationFilter
    Placements?: PlacementsListRelationFilter
    ProviderCohorts?: ProviderCohortsListRelationFilter
  }

  export type AddressesOrderByWithRelationInput = {
    addressId?: SortOrder
    name?: SortOrder
    stage?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    contactForename?: SortOrderInput | SortOrder
    contactSurname?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    geoHash?: SortOrderInput | SortOrder
    locality?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    instituteId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    institute?: InstitutesOrderByWithRelationInput
    provider?: ProvidersOrderByWithRelationInput
    Contacts?: ContactsOrderByRelationAggregateInput
    PlacementListings?: PlacementListingsOrderByRelationAggregateInput
    Placements?: PlacementsOrderByRelationAggregateInput
    ProviderCohorts?: ProviderCohortsOrderByRelationAggregateInput
  }

  export type AddressesWhereUniqueInput = Prisma.AtLeast<{
    addressId?: string
    AND?: AddressesWhereInput | AddressesWhereInput[]
    OR?: AddressesWhereInput[]
    NOT?: AddressesWhereInput | AddressesWhereInput[]
    name?: StringFilter<"Addresses"> | string
    stage?: StringNullableFilter<"Addresses"> | string | null
    addressLine1?: StringNullableFilter<"Addresses"> | string | null
    addressLine2?: StringNullableFilter<"Addresses"> | string | null
    contactForename?: StringNullableFilter<"Addresses"> | string | null
    contactSurname?: StringNullableFilter<"Addresses"> | string | null
    country?: StringNullableFilter<"Addresses"> | string | null
    email?: StringNullableFilter<"Addresses"> | string | null
    geoHash?: StringNullableFilter<"Addresses"> | string | null
    locality?: StringNullableFilter<"Addresses"> | string | null
    phone?: StringNullableFilter<"Addresses"> | string | null
    postal_code?: StringNullableFilter<"Addresses"> | string | null
    instituteId?: StringNullableFilter<"Addresses"> | string | null
    providerId?: StringNullableFilter<"Addresses"> | string | null
    institute?: XOR<InstitutesNullableRelationFilter, InstitutesWhereInput> | null
    provider?: XOR<ProvidersNullableRelationFilter, ProvidersWhereInput> | null
    Contacts?: ContactsListRelationFilter
    PlacementListings?: PlacementListingsListRelationFilter
    Placements?: PlacementsListRelationFilter
    ProviderCohorts?: ProviderCohortsListRelationFilter
  }, "addressId" | "addressId">

  export type AddressesOrderByWithAggregationInput = {
    addressId?: SortOrder
    name?: SortOrder
    stage?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    contactForename?: SortOrderInput | SortOrder
    contactSurname?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    geoHash?: SortOrderInput | SortOrder
    locality?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    instituteId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    _count?: AddressesCountOrderByAggregateInput
    _max?: AddressesMaxOrderByAggregateInput
    _min?: AddressesMinOrderByAggregateInput
  }

  export type AddressesScalarWhereWithAggregatesInput = {
    AND?: AddressesScalarWhereWithAggregatesInput | AddressesScalarWhereWithAggregatesInput[]
    OR?: AddressesScalarWhereWithAggregatesInput[]
    NOT?: AddressesScalarWhereWithAggregatesInput | AddressesScalarWhereWithAggregatesInput[]
    addressId?: StringWithAggregatesFilter<"Addresses"> | string
    name?: StringWithAggregatesFilter<"Addresses"> | string
    stage?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    contactForename?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    contactSurname?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    country?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    email?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    geoHash?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    locality?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    instituteId?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
    providerId?: StringNullableWithAggregatesFilter<"Addresses"> | string | null
  }

  export type CohortsWhereInput = {
    AND?: CohortsWhereInput | CohortsWhereInput[]
    OR?: CohortsWhereInput[]
    NOT?: CohortsWhereInput | CohortsWhereInput[]
    cohortId?: StringFilter<"Cohorts"> | string
    designatedStaff?: StringFilter<"Cohorts"> | string
    stage?: StringFilter<"Cohorts"> | string
    placementType?: StringFilter<"Cohorts"> | string
    name?: StringFilter<"Cohorts"> | string
    startPlacements?: StringFilter<"Cohorts"> | string
    endPlacements?: StringFilter<"Cohorts"> | string
    startSubmission?: StringFilter<"Cohorts"> | string
    endSubmission?: StringFilter<"Cohorts"> | string
    includedFiles?: StringNullableListFilter<"Cohorts">
    includedForms?: StringNullableListFilter<"Cohorts">
    workflow?: StringFilter<"Cohorts"> | string
    instituteId?: StringFilter<"Cohorts"> | string
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    InstituteStudents?: InstituteStudentsListRelationFilter
  }

  export type CohortsOrderByWithRelationInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    includedFiles?: SortOrder
    includedForms?: SortOrder
    workflow?: SortOrder
    instituteId?: SortOrder
    institute?: InstitutesOrderByWithRelationInput
    InstituteStudents?: InstituteStudentsOrderByRelationAggregateInput
  }

  export type CohortsWhereUniqueInput = Prisma.AtLeast<{
    cohortId?: string
    AND?: CohortsWhereInput | CohortsWhereInput[]
    OR?: CohortsWhereInput[]
    NOT?: CohortsWhereInput | CohortsWhereInput[]
    designatedStaff?: StringFilter<"Cohorts"> | string
    stage?: StringFilter<"Cohorts"> | string
    placementType?: StringFilter<"Cohorts"> | string
    name?: StringFilter<"Cohorts"> | string
    startPlacements?: StringFilter<"Cohorts"> | string
    endPlacements?: StringFilter<"Cohorts"> | string
    startSubmission?: StringFilter<"Cohorts"> | string
    endSubmission?: StringFilter<"Cohorts"> | string
    includedFiles?: StringNullableListFilter<"Cohorts">
    includedForms?: StringNullableListFilter<"Cohorts">
    workflow?: StringFilter<"Cohorts"> | string
    instituteId?: StringFilter<"Cohorts"> | string
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    InstituteStudents?: InstituteStudentsListRelationFilter
  }, "cohortId" | "cohortId">

  export type CohortsOrderByWithAggregationInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    includedFiles?: SortOrder
    includedForms?: SortOrder
    workflow?: SortOrder
    instituteId?: SortOrder
    _count?: CohortsCountOrderByAggregateInput
    _max?: CohortsMaxOrderByAggregateInput
    _min?: CohortsMinOrderByAggregateInput
  }

  export type CohortsScalarWhereWithAggregatesInput = {
    AND?: CohortsScalarWhereWithAggregatesInput | CohortsScalarWhereWithAggregatesInput[]
    OR?: CohortsScalarWhereWithAggregatesInput[]
    NOT?: CohortsScalarWhereWithAggregatesInput | CohortsScalarWhereWithAggregatesInput[]
    cohortId?: StringWithAggregatesFilter<"Cohorts"> | string
    designatedStaff?: StringWithAggregatesFilter<"Cohorts"> | string
    stage?: StringWithAggregatesFilter<"Cohorts"> | string
    placementType?: StringWithAggregatesFilter<"Cohorts"> | string
    name?: StringWithAggregatesFilter<"Cohorts"> | string
    startPlacements?: StringWithAggregatesFilter<"Cohorts"> | string
    endPlacements?: StringWithAggregatesFilter<"Cohorts"> | string
    startSubmission?: StringWithAggregatesFilter<"Cohorts"> | string
    endSubmission?: StringWithAggregatesFilter<"Cohorts"> | string
    includedFiles?: StringNullableListFilter<"Cohorts">
    includedForms?: StringNullableListFilter<"Cohorts">
    workflow?: StringWithAggregatesFilter<"Cohorts"> | string
    instituteId?: StringWithAggregatesFilter<"Cohorts"> | string
  }

  export type ProviderCohortsWhereInput = {
    AND?: ProviderCohortsWhereInput | ProviderCohortsWhereInput[]
    OR?: ProviderCohortsWhereInput[]
    NOT?: ProviderCohortsWhereInput | ProviderCohortsWhereInput[]
    cohortId?: StringFilter<"ProviderCohorts"> | string
    stage?: StringFilter<"ProviderCohorts"> | string
    name?: StringFilter<"ProviderCohorts"> | string
    addressId?: StringFilter<"ProviderCohorts"> | string
    providerId?: StringFilter<"ProviderCohorts"> | string
    address?: XOR<AddressesRelationFilter, AddressesWhereInput>
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
  }

  export type ProviderCohortsOrderByWithRelationInput = {
    cohortId?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    providerId?: SortOrder
    address?: AddressesOrderByWithRelationInput
    provider?: ProvidersOrderByWithRelationInput
  }

  export type ProviderCohortsWhereUniqueInput = Prisma.AtLeast<{
    cohortId?: string
    AND?: ProviderCohortsWhereInput | ProviderCohortsWhereInput[]
    OR?: ProviderCohortsWhereInput[]
    NOT?: ProviderCohortsWhereInput | ProviderCohortsWhereInput[]
    stage?: StringFilter<"ProviderCohorts"> | string
    name?: StringFilter<"ProviderCohorts"> | string
    addressId?: StringFilter<"ProviderCohorts"> | string
    providerId?: StringFilter<"ProviderCohorts"> | string
    address?: XOR<AddressesRelationFilter, AddressesWhereInput>
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
  }, "cohortId" | "cohortId">

  export type ProviderCohortsOrderByWithAggregationInput = {
    cohortId?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    providerId?: SortOrder
    _count?: ProviderCohortsCountOrderByAggregateInput
    _max?: ProviderCohortsMaxOrderByAggregateInput
    _min?: ProviderCohortsMinOrderByAggregateInput
  }

  export type ProviderCohortsScalarWhereWithAggregatesInput = {
    AND?: ProviderCohortsScalarWhereWithAggregatesInput | ProviderCohortsScalarWhereWithAggregatesInput[]
    OR?: ProviderCohortsScalarWhereWithAggregatesInput[]
    NOT?: ProviderCohortsScalarWhereWithAggregatesInput | ProviderCohortsScalarWhereWithAggregatesInput[]
    cohortId?: StringWithAggregatesFilter<"ProviderCohorts"> | string
    stage?: StringWithAggregatesFilter<"ProviderCohorts"> | string
    name?: StringWithAggregatesFilter<"ProviderCohorts"> | string
    addressId?: StringWithAggregatesFilter<"ProviderCohorts"> | string
    providerId?: StringWithAggregatesFilter<"ProviderCohorts"> | string
  }

  export type ContactsWhereInput = {
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    contactId?: StringFilter<"Contacts"> | string
    contactForename?: StringFilter<"Contacts"> | string
    contactSurname?: StringFilter<"Contacts"> | string
    created?: StringFilter<"Contacts"> | string
    name?: StringFilter<"Contacts"> | string
    providerPhone?: StringFilter<"Contacts"> | string
    InstituteStudentUserId?: StringFilter<"Contacts"> | string
    addressId?: StringFilter<"Contacts"> | string
    studentUserId?: StringFilter<"Contacts"> | string
    InstitutestudentUser?: XOR<InstituteStudentsRelationFilter, InstituteStudentsWhereInput>
    address?: XOR<AddressesRelationFilter, AddressesWhereInput>
    studentUser?: XOR<StudentUsersRelationFilter, StudentUsersWhereInput>
  }

  export type ContactsOrderByWithRelationInput = {
    contactId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    name?: SortOrder
    providerPhone?: SortOrder
    InstituteStudentUserId?: SortOrder
    addressId?: SortOrder
    studentUserId?: SortOrder
    InstitutestudentUser?: InstituteStudentsOrderByWithRelationInput
    address?: AddressesOrderByWithRelationInput
    studentUser?: StudentUsersOrderByWithRelationInput
  }

  export type ContactsWhereUniqueInput = Prisma.AtLeast<{
    contactId?: string
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    contactForename?: StringFilter<"Contacts"> | string
    contactSurname?: StringFilter<"Contacts"> | string
    created?: StringFilter<"Contacts"> | string
    name?: StringFilter<"Contacts"> | string
    providerPhone?: StringFilter<"Contacts"> | string
    InstituteStudentUserId?: StringFilter<"Contacts"> | string
    addressId?: StringFilter<"Contacts"> | string
    studentUserId?: StringFilter<"Contacts"> | string
    InstitutestudentUser?: XOR<InstituteStudentsRelationFilter, InstituteStudentsWhereInput>
    address?: XOR<AddressesRelationFilter, AddressesWhereInput>
    studentUser?: XOR<StudentUsersRelationFilter, StudentUsersWhereInput>
  }, "contactId" | "contactId">

  export type ContactsOrderByWithAggregationInput = {
    contactId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    name?: SortOrder
    providerPhone?: SortOrder
    InstituteStudentUserId?: SortOrder
    addressId?: SortOrder
    studentUserId?: SortOrder
    _count?: ContactsCountOrderByAggregateInput
    _max?: ContactsMaxOrderByAggregateInput
    _min?: ContactsMinOrderByAggregateInput
  }

  export type ContactsScalarWhereWithAggregatesInput = {
    AND?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    OR?: ContactsScalarWhereWithAggregatesInput[]
    NOT?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    contactId?: StringWithAggregatesFilter<"Contacts"> | string
    contactForename?: StringWithAggregatesFilter<"Contacts"> | string
    contactSurname?: StringWithAggregatesFilter<"Contacts"> | string
    created?: StringWithAggregatesFilter<"Contacts"> | string
    name?: StringWithAggregatesFilter<"Contacts"> | string
    providerPhone?: StringWithAggregatesFilter<"Contacts"> | string
    InstituteStudentUserId?: StringWithAggregatesFilter<"Contacts"> | string
    addressId?: StringWithAggregatesFilter<"Contacts"> | string
    studentUserId?: StringWithAggregatesFilter<"Contacts"> | string
  }

  export type InstituteFormsWhereInput = {
    AND?: InstituteFormsWhereInput | InstituteFormsWhereInput[]
    OR?: InstituteFormsWhereInput[]
    NOT?: InstituteFormsWhereInput | InstituteFormsWhereInput[]
    formId?: StringFilter<"InstituteForms"> | string
    form?: JsonFilter<"InstituteForms">
    updated?: StringFilter<"InstituteForms"> | string
    instituteId?: StringFilter<"InstituteForms"> | string
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
  }

  export type InstituteFormsOrderByWithRelationInput = {
    formId?: SortOrder
    form?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
    institute?: InstitutesOrderByWithRelationInput
  }

  export type InstituteFormsWhereUniqueInput = Prisma.AtLeast<{
    formId?: string
    AND?: InstituteFormsWhereInput | InstituteFormsWhereInput[]
    OR?: InstituteFormsWhereInput[]
    NOT?: InstituteFormsWhereInput | InstituteFormsWhereInput[]
    form?: JsonFilter<"InstituteForms">
    updated?: StringFilter<"InstituteForms"> | string
    instituteId?: StringFilter<"InstituteForms"> | string
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
  }, "formId" | "formId">

  export type InstituteFormsOrderByWithAggregationInput = {
    formId?: SortOrder
    form?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
    _count?: InstituteFormsCountOrderByAggregateInput
    _max?: InstituteFormsMaxOrderByAggregateInput
    _min?: InstituteFormsMinOrderByAggregateInput
  }

  export type InstituteFormsScalarWhereWithAggregatesInput = {
    AND?: InstituteFormsScalarWhereWithAggregatesInput | InstituteFormsScalarWhereWithAggregatesInput[]
    OR?: InstituteFormsScalarWhereWithAggregatesInput[]
    NOT?: InstituteFormsScalarWhereWithAggregatesInput | InstituteFormsScalarWhereWithAggregatesInput[]
    formId?: StringWithAggregatesFilter<"InstituteForms"> | string
    form?: JsonWithAggregatesFilter<"InstituteForms">
    updated?: StringWithAggregatesFilter<"InstituteForms"> | string
    instituteId?: StringWithAggregatesFilter<"InstituteForms"> | string
  }

  export type InstitutesWhereInput = {
    AND?: InstitutesWhereInput | InstitutesWhereInput[]
    OR?: InstitutesWhereInput[]
    NOT?: InstitutesWhereInput | InstitutesWhereInput[]
    instituteId?: StringFilter<"Institutes"> | string
    admin?: StringFilter<"Institutes"> | string
    externalProviderUploads?: BoolFilter<"Institutes"> | boolean
    name?: StringFilter<"Institutes"> | string
    referral?: StringNullableFilter<"Institutes"> | string | null
    status?: StringFilter<"Institutes"> | string
    studentsFields?: StringNullableListFilter<"Institutes">
    staff?: IntFilter<"Institutes"> | number
    staffActive?: IntFilter<"Institutes"> | number
    students?: IntFilter<"Institutes"> | number
    studentsActive?: IntFilter<"Institutes"> | number
    staffFields?: StringNullableListFilter<"Institutes">
    staffGuidance?: JsonFilter<"Institutes">
    studentsGuidance?: JsonFilter<"Institutes">
    verifiedProviders?: StringNullableListFilter<"Institutes">
    Addresses?: AddressesListRelationFilter
    Cohorts?: CohortsListRelationFilter
    Forms?: InstituteFormsListRelationFilter
    InstituteStaff?: InstituteStaffListRelationFilter
    StaffUserGroups?: InstituteStaffUserGroupsListRelationFilter
    StudentUserGroups?: InstituteStudentUserGroupsListRelationFilter
    InstituteStudents?: InstituteStudentsListRelationFilter
    Placements?: PlacementsListRelationFilter
  }

  export type InstitutesOrderByWithRelationInput = {
    instituteId?: SortOrder
    admin?: SortOrder
    externalProviderUploads?: SortOrder
    name?: SortOrder
    referral?: SortOrderInput | SortOrder
    status?: SortOrder
    studentsFields?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
    staffFields?: SortOrder
    staffGuidance?: SortOrder
    studentsGuidance?: SortOrder
    verifiedProviders?: SortOrder
    Addresses?: AddressesOrderByRelationAggregateInput
    Cohorts?: CohortsOrderByRelationAggregateInput
    Forms?: InstituteFormsOrderByRelationAggregateInput
    InstituteStaff?: InstituteStaffOrderByRelationAggregateInput
    StaffUserGroups?: InstituteStaffUserGroupsOrderByRelationAggregateInput
    StudentUserGroups?: InstituteStudentUserGroupsOrderByRelationAggregateInput
    InstituteStudents?: InstituteStudentsOrderByRelationAggregateInput
    Placements?: PlacementsOrderByRelationAggregateInput
  }

  export type InstitutesWhereUniqueInput = Prisma.AtLeast<{
    instituteId?: string
    AND?: InstitutesWhereInput | InstitutesWhereInput[]
    OR?: InstitutesWhereInput[]
    NOT?: InstitutesWhereInput | InstitutesWhereInput[]
    admin?: StringFilter<"Institutes"> | string
    externalProviderUploads?: BoolFilter<"Institutes"> | boolean
    name?: StringFilter<"Institutes"> | string
    referral?: StringNullableFilter<"Institutes"> | string | null
    status?: StringFilter<"Institutes"> | string
    studentsFields?: StringNullableListFilter<"Institutes">
    staff?: IntFilter<"Institutes"> | number
    staffActive?: IntFilter<"Institutes"> | number
    students?: IntFilter<"Institutes"> | number
    studentsActive?: IntFilter<"Institutes"> | number
    staffFields?: StringNullableListFilter<"Institutes">
    staffGuidance?: JsonFilter<"Institutes">
    studentsGuidance?: JsonFilter<"Institutes">
    verifiedProviders?: StringNullableListFilter<"Institutes">
    Addresses?: AddressesListRelationFilter
    Cohorts?: CohortsListRelationFilter
    Forms?: InstituteFormsListRelationFilter
    InstituteStaff?: InstituteStaffListRelationFilter
    StaffUserGroups?: InstituteStaffUserGroupsListRelationFilter
    StudentUserGroups?: InstituteStudentUserGroupsListRelationFilter
    InstituteStudents?: InstituteStudentsListRelationFilter
    Placements?: PlacementsListRelationFilter
  }, "instituteId" | "instituteId">

  export type InstitutesOrderByWithAggregationInput = {
    instituteId?: SortOrder
    admin?: SortOrder
    externalProviderUploads?: SortOrder
    name?: SortOrder
    referral?: SortOrderInput | SortOrder
    status?: SortOrder
    studentsFields?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
    staffFields?: SortOrder
    staffGuidance?: SortOrder
    studentsGuidance?: SortOrder
    verifiedProviders?: SortOrder
    _count?: InstitutesCountOrderByAggregateInput
    _avg?: InstitutesAvgOrderByAggregateInput
    _max?: InstitutesMaxOrderByAggregateInput
    _min?: InstitutesMinOrderByAggregateInput
    _sum?: InstitutesSumOrderByAggregateInput
  }

  export type InstitutesScalarWhereWithAggregatesInput = {
    AND?: InstitutesScalarWhereWithAggregatesInput | InstitutesScalarWhereWithAggregatesInput[]
    OR?: InstitutesScalarWhereWithAggregatesInput[]
    NOT?: InstitutesScalarWhereWithAggregatesInput | InstitutesScalarWhereWithAggregatesInput[]
    instituteId?: StringWithAggregatesFilter<"Institutes"> | string
    admin?: StringWithAggregatesFilter<"Institutes"> | string
    externalProviderUploads?: BoolWithAggregatesFilter<"Institutes"> | boolean
    name?: StringWithAggregatesFilter<"Institutes"> | string
    referral?: StringNullableWithAggregatesFilter<"Institutes"> | string | null
    status?: StringWithAggregatesFilter<"Institutes"> | string
    studentsFields?: StringNullableListFilter<"Institutes">
    staff?: IntWithAggregatesFilter<"Institutes"> | number
    staffActive?: IntWithAggregatesFilter<"Institutes"> | number
    students?: IntWithAggregatesFilter<"Institutes"> | number
    studentsActive?: IntWithAggregatesFilter<"Institutes"> | number
    staffFields?: StringNullableListFilter<"Institutes">
    staffGuidance?: JsonWithAggregatesFilter<"Institutes">
    studentsGuidance?: JsonWithAggregatesFilter<"Institutes">
    verifiedProviders?: StringNullableListFilter<"Institutes">
  }

  export type LogsWhereInput = {
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    logId?: StringFilter<"Logs"> | string
    provider?: JsonFilter<"Logs">
    students?: JsonFilter<"Logs">
    staff?: JsonFilter<"Logs">
    uid?: StringFilter<"Logs"> | string
    placementId?: StringFilter<"Logs"> | string
    placement?: XOR<PlacementsRelationFilter, PlacementsWhereInput>
  }

  export type LogsOrderByWithRelationInput = {
    logId?: SortOrder
    provider?: SortOrder
    students?: SortOrder
    staff?: SortOrder
    uid?: SortOrder
    placementId?: SortOrder
    placement?: PlacementsOrderByWithRelationInput
  }

  export type LogsWhereUniqueInput = Prisma.AtLeast<{
    logId?: string
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    provider?: JsonFilter<"Logs">
    students?: JsonFilter<"Logs">
    staff?: JsonFilter<"Logs">
    uid?: StringFilter<"Logs"> | string
    placementId?: StringFilter<"Logs"> | string
    placement?: XOR<PlacementsRelationFilter, PlacementsWhereInput>
  }, "logId" | "logId">

  export type LogsOrderByWithAggregationInput = {
    logId?: SortOrder
    provider?: SortOrder
    students?: SortOrder
    staff?: SortOrder
    uid?: SortOrder
    placementId?: SortOrder
    _count?: LogsCountOrderByAggregateInput
    _max?: LogsMaxOrderByAggregateInput
    _min?: LogsMinOrderByAggregateInput
  }

  export type LogsScalarWhereWithAggregatesInput = {
    AND?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    OR?: LogsScalarWhereWithAggregatesInput[]
    NOT?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    logId?: StringWithAggregatesFilter<"Logs"> | string
    provider?: JsonWithAggregatesFilter<"Logs">
    students?: JsonWithAggregatesFilter<"Logs">
    staff?: JsonWithAggregatesFilter<"Logs">
    uid?: StringWithAggregatesFilter<"Logs"> | string
    placementId?: StringWithAggregatesFilter<"Logs"> | string
  }

  export type PlacementListingsWhereInput = {
    AND?: PlacementListingsWhereInput | PlacementListingsWhereInput[]
    OR?: PlacementListingsWhereInput[]
    NOT?: PlacementListingsWhereInput | PlacementListingsWhereInput[]
    placementListingId?: StringFilter<"PlacementListings"> | string
    addressId?: StringFilter<"PlacementListings"> | string
    contactForename?: StringFilter<"PlacementListings"> | string
    contactSurname?: StringFilter<"PlacementListings"> | string
    created?: DateTimeFilter<"PlacementListings"> | Date | string
    mapConsent?: BoolFilter<"PlacementListings"> | boolean
    mapConsentDate?: StringFilter<"PlacementListings"> | string
    providerEmail?: StringFilter<"PlacementListings"> | string
    providerId?: StringFilter<"PlacementListings"> | string
    providerPhone?: StringFilter<"PlacementListings"> | string
    savedBy?: JsonFilter<"PlacementListings">
    questions?: JsonFilter<"PlacementListings">
    title?: StringFilter<"PlacementListings"> | string
    uploadedBy?: StringFilter<"PlacementListings"> | string
    address?: XOR<AddressesRelationFilter, AddressesWhereInput>
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
  }

  export type PlacementListingsOrderByWithRelationInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    savedBy?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
    address?: AddressesOrderByWithRelationInput
    provider?: ProvidersOrderByWithRelationInput
  }

  export type PlacementListingsWhereUniqueInput = Prisma.AtLeast<{
    placementListingId?: string
    AND?: PlacementListingsWhereInput | PlacementListingsWhereInput[]
    OR?: PlacementListingsWhereInput[]
    NOT?: PlacementListingsWhereInput | PlacementListingsWhereInput[]
    addressId?: StringFilter<"PlacementListings"> | string
    contactForename?: StringFilter<"PlacementListings"> | string
    contactSurname?: StringFilter<"PlacementListings"> | string
    created?: DateTimeFilter<"PlacementListings"> | Date | string
    mapConsent?: BoolFilter<"PlacementListings"> | boolean
    mapConsentDate?: StringFilter<"PlacementListings"> | string
    providerEmail?: StringFilter<"PlacementListings"> | string
    providerId?: StringFilter<"PlacementListings"> | string
    providerPhone?: StringFilter<"PlacementListings"> | string
    savedBy?: JsonFilter<"PlacementListings">
    questions?: JsonFilter<"PlacementListings">
    title?: StringFilter<"PlacementListings"> | string
    uploadedBy?: StringFilter<"PlacementListings"> | string
    address?: XOR<AddressesRelationFilter, AddressesWhereInput>
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
  }, "placementListingId" | "placementListingId">

  export type PlacementListingsOrderByWithAggregationInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    savedBy?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
    _count?: PlacementListingsCountOrderByAggregateInput
    _max?: PlacementListingsMaxOrderByAggregateInput
    _min?: PlacementListingsMinOrderByAggregateInput
  }

  export type PlacementListingsScalarWhereWithAggregatesInput = {
    AND?: PlacementListingsScalarWhereWithAggregatesInput | PlacementListingsScalarWhereWithAggregatesInput[]
    OR?: PlacementListingsScalarWhereWithAggregatesInput[]
    NOT?: PlacementListingsScalarWhereWithAggregatesInput | PlacementListingsScalarWhereWithAggregatesInput[]
    placementListingId?: StringWithAggregatesFilter<"PlacementListings"> | string
    addressId?: StringWithAggregatesFilter<"PlacementListings"> | string
    contactForename?: StringWithAggregatesFilter<"PlacementListings"> | string
    contactSurname?: StringWithAggregatesFilter<"PlacementListings"> | string
    created?: DateTimeWithAggregatesFilter<"PlacementListings"> | Date | string
    mapConsent?: BoolWithAggregatesFilter<"PlacementListings"> | boolean
    mapConsentDate?: StringWithAggregatesFilter<"PlacementListings"> | string
    providerEmail?: StringWithAggregatesFilter<"PlacementListings"> | string
    providerId?: StringWithAggregatesFilter<"PlacementListings"> | string
    providerPhone?: StringWithAggregatesFilter<"PlacementListings"> | string
    savedBy?: JsonWithAggregatesFilter<"PlacementListings">
    questions?: JsonWithAggregatesFilter<"PlacementListings">
    title?: StringWithAggregatesFilter<"PlacementListings"> | string
    uploadedBy?: StringWithAggregatesFilter<"PlacementListings"> | string
  }

  export type PlacementsWhereInput = {
    AND?: PlacementsWhereInput | PlacementsWhereInput[]
    OR?: PlacementsWhereInput[]
    NOT?: PlacementsWhereInput | PlacementsWhereInput[]
    placementId?: StringFilter<"Placements"> | string
    activeDates?: StringNullableListFilter<"Placements">
    cohortId?: StringFilter<"Placements"> | string
    contactForename?: StringFilter<"Placements"> | string
    contactSurname?: StringFilter<"Placements"> | string
    created?: StringFilter<"Placements"> | string
    draft?: BoolFilter<"Placements"> | boolean
    endDate?: StringFilter<"Placements"> | string
    flags?: StringNullableListFilter<"Placements">
    geoHash?: StringFilter<"Placements"> | string
    inProgress?: BoolFilter<"Placements"> | boolean
    leadTimes?: StringNullableListFilter<"Placements">
    name?: StringFilter<"Placements"> | string
    parentEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    parentExpiry?: StringNullableFilter<"Placements"> | string | null
    parentKey?: StringNullableFilter<"Placements"> | string | null
    product?: StringNullableFilter<"Placements"> | string | null
    providerEmail?: StringNullableFilter<"Placements"> | string | null
    providerEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    providerExpiry?: StringNullableFilter<"Placements"> | string | null
    providerKey?: StringNullableFilter<"Placements"> | string | null
    providerName?: StringNullableFilter<"Placements"> | string | null
    providerPhone?: StringFilter<"Placements"> | string
    nextStatus?: IntNullableFilter<"Placements"> | number | null
    status?: IntFilter<"Placements"> | number
    startDate?: StringFilter<"Placements"> | string
    title?: StringFilter<"Placements"> | string
    forms?: JsonFilter<"Placements">
    questions?: JsonFilter<"Placements">
    uploadedBy?: StringFilter<"Placements"> | string
    addressId?: StringFilter<"Placements"> | string
    instituteId?: StringFilter<"Placements"> | string
    instituteStudentId?: StringFilter<"Placements"> | string
    providerId?: StringFilter<"Placements"> | string
    studentId?: StringFilter<"Placements"> | string
    userGroupId?: StringFilter<"Placements"> | string
    Logs?: LogsListRelationFilter
    address?: XOR<AddressesRelationFilter, AddressesWhereInput>
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    instituteStudent?: XOR<InstituteStudentsRelationFilter, InstituteStudentsWhereInput>
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
    student?: XOR<StudentUsersRelationFilter, StudentUsersWhereInput>
    userGroup?: XOR<InstituteStudentUserGroupsRelationFilter, InstituteStudentUserGroupsWhereInput>
  }

  export type PlacementsOrderByWithRelationInput = {
    placementId?: SortOrder
    activeDates?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    flags?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    leadTimes?: SortOrder
    name?: SortOrder
    parentEmailed?: SortOrderInput | SortOrder
    parentExpiry?: SortOrderInput | SortOrder
    parentKey?: SortOrderInput | SortOrder
    product?: SortOrderInput | SortOrder
    providerEmail?: SortOrderInput | SortOrder
    providerEmailed?: SortOrderInput | SortOrder
    providerExpiry?: SortOrderInput | SortOrder
    providerKey?: SortOrderInput | SortOrder
    providerName?: SortOrderInput | SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    forms?: SortOrder
    questions?: SortOrder
    uploadedBy?: SortOrder
    addressId?: SortOrder
    instituteId?: SortOrder
    instituteStudentId?: SortOrder
    providerId?: SortOrder
    studentId?: SortOrder
    userGroupId?: SortOrder
    Logs?: LogsOrderByRelationAggregateInput
    address?: AddressesOrderByWithRelationInput
    institute?: InstitutesOrderByWithRelationInput
    instituteStudent?: InstituteStudentsOrderByWithRelationInput
    provider?: ProvidersOrderByWithRelationInput
    student?: StudentUsersOrderByWithRelationInput
    userGroup?: InstituteStudentUserGroupsOrderByWithRelationInput
  }

  export type PlacementsWhereUniqueInput = Prisma.AtLeast<{
    placementId?: string
    AND?: PlacementsWhereInput | PlacementsWhereInput[]
    OR?: PlacementsWhereInput[]
    NOT?: PlacementsWhereInput | PlacementsWhereInput[]
    activeDates?: StringNullableListFilter<"Placements">
    cohortId?: StringFilter<"Placements"> | string
    contactForename?: StringFilter<"Placements"> | string
    contactSurname?: StringFilter<"Placements"> | string
    created?: StringFilter<"Placements"> | string
    draft?: BoolFilter<"Placements"> | boolean
    endDate?: StringFilter<"Placements"> | string
    flags?: StringNullableListFilter<"Placements">
    geoHash?: StringFilter<"Placements"> | string
    inProgress?: BoolFilter<"Placements"> | boolean
    leadTimes?: StringNullableListFilter<"Placements">
    name?: StringFilter<"Placements"> | string
    parentEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    parentExpiry?: StringNullableFilter<"Placements"> | string | null
    parentKey?: StringNullableFilter<"Placements"> | string | null
    product?: StringNullableFilter<"Placements"> | string | null
    providerEmail?: StringNullableFilter<"Placements"> | string | null
    providerEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    providerExpiry?: StringNullableFilter<"Placements"> | string | null
    providerKey?: StringNullableFilter<"Placements"> | string | null
    providerName?: StringNullableFilter<"Placements"> | string | null
    providerPhone?: StringFilter<"Placements"> | string
    nextStatus?: IntNullableFilter<"Placements"> | number | null
    status?: IntFilter<"Placements"> | number
    startDate?: StringFilter<"Placements"> | string
    title?: StringFilter<"Placements"> | string
    forms?: JsonFilter<"Placements">
    questions?: JsonFilter<"Placements">
    uploadedBy?: StringFilter<"Placements"> | string
    addressId?: StringFilter<"Placements"> | string
    instituteId?: StringFilter<"Placements"> | string
    instituteStudentId?: StringFilter<"Placements"> | string
    providerId?: StringFilter<"Placements"> | string
    studentId?: StringFilter<"Placements"> | string
    userGroupId?: StringFilter<"Placements"> | string
    Logs?: LogsListRelationFilter
    address?: XOR<AddressesRelationFilter, AddressesWhereInput>
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    instituteStudent?: XOR<InstituteStudentsRelationFilter, InstituteStudentsWhereInput>
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
    student?: XOR<StudentUsersRelationFilter, StudentUsersWhereInput>
    userGroup?: XOR<InstituteStudentUserGroupsRelationFilter, InstituteStudentUserGroupsWhereInput>
  }, "placementId" | "placementId">

  export type PlacementsOrderByWithAggregationInput = {
    placementId?: SortOrder
    activeDates?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    flags?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    leadTimes?: SortOrder
    name?: SortOrder
    parentEmailed?: SortOrderInput | SortOrder
    parentExpiry?: SortOrderInput | SortOrder
    parentKey?: SortOrderInput | SortOrder
    product?: SortOrderInput | SortOrder
    providerEmail?: SortOrderInput | SortOrder
    providerEmailed?: SortOrderInput | SortOrder
    providerExpiry?: SortOrderInput | SortOrder
    providerKey?: SortOrderInput | SortOrder
    providerName?: SortOrderInput | SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    forms?: SortOrder
    questions?: SortOrder
    uploadedBy?: SortOrder
    addressId?: SortOrder
    instituteId?: SortOrder
    instituteStudentId?: SortOrder
    providerId?: SortOrder
    studentId?: SortOrder
    userGroupId?: SortOrder
    _count?: PlacementsCountOrderByAggregateInput
    _avg?: PlacementsAvgOrderByAggregateInput
    _max?: PlacementsMaxOrderByAggregateInput
    _min?: PlacementsMinOrderByAggregateInput
    _sum?: PlacementsSumOrderByAggregateInput
  }

  export type PlacementsScalarWhereWithAggregatesInput = {
    AND?: PlacementsScalarWhereWithAggregatesInput | PlacementsScalarWhereWithAggregatesInput[]
    OR?: PlacementsScalarWhereWithAggregatesInput[]
    NOT?: PlacementsScalarWhereWithAggregatesInput | PlacementsScalarWhereWithAggregatesInput[]
    placementId?: StringWithAggregatesFilter<"Placements"> | string
    activeDates?: StringNullableListFilter<"Placements">
    cohortId?: StringWithAggregatesFilter<"Placements"> | string
    contactForename?: StringWithAggregatesFilter<"Placements"> | string
    contactSurname?: StringWithAggregatesFilter<"Placements"> | string
    created?: StringWithAggregatesFilter<"Placements"> | string
    draft?: BoolWithAggregatesFilter<"Placements"> | boolean
    endDate?: StringWithAggregatesFilter<"Placements"> | string
    flags?: StringNullableListFilter<"Placements">
    geoHash?: StringWithAggregatesFilter<"Placements"> | string
    inProgress?: BoolWithAggregatesFilter<"Placements"> | boolean
    leadTimes?: StringNullableListFilter<"Placements">
    name?: StringWithAggregatesFilter<"Placements"> | string
    parentEmailed?: DateTimeNullableWithAggregatesFilter<"Placements"> | Date | string | null
    parentExpiry?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    parentKey?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    product?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerEmail?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerEmailed?: DateTimeNullableWithAggregatesFilter<"Placements"> | Date | string | null
    providerExpiry?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerKey?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerName?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerPhone?: StringWithAggregatesFilter<"Placements"> | string
    nextStatus?: IntNullableWithAggregatesFilter<"Placements"> | number | null
    status?: IntWithAggregatesFilter<"Placements"> | number
    startDate?: StringWithAggregatesFilter<"Placements"> | string
    title?: StringWithAggregatesFilter<"Placements"> | string
    forms?: JsonWithAggregatesFilter<"Placements">
    questions?: JsonWithAggregatesFilter<"Placements">
    uploadedBy?: StringWithAggregatesFilter<"Placements"> | string
    addressId?: StringWithAggregatesFilter<"Placements"> | string
    instituteId?: StringWithAggregatesFilter<"Placements"> | string
    instituteStudentId?: StringWithAggregatesFilter<"Placements"> | string
    providerId?: StringWithAggregatesFilter<"Placements"> | string
    studentId?: StringWithAggregatesFilter<"Placements"> | string
    userGroupId?: StringWithAggregatesFilter<"Placements"> | string
  }

  export type ProvidersWhereInput = {
    AND?: ProvidersWhereInput | ProvidersWhereInput[]
    OR?: ProvidersWhereInput[]
    NOT?: ProvidersWhereInput | ProvidersWhereInput[]
    providerId?: StringFilter<"Providers"> | string
    contactForename?: StringFilter<"Providers"> | string
    contactSurname?: StringFilter<"Providers"> | string
    email?: StringFilter<"Providers"> | string
    mapConsent?: BoolNullableFilter<"Providers"> | boolean | null
    insurance?: BoolNullableFilter<"Providers"> | boolean | null
    mapConsentDate?: StringNullableFilter<"Providers"> | string | null
    name?: StringFilter<"Providers"> | string
    phone?: StringFilter<"Providers"> | string
    rememberConsent?: BoolNullableFilter<"Providers"> | boolean | null
    rememberConsentDate?: StringNullableFilter<"Providers"> | string | null
    savedBy?: JsonNullableFilter<"Providers">
    sector?: StringFilter<"Providers"> | string
    referral?: StringNullableFilter<"Providers"> | string | null
    subsector?: StringFilter<"Providers"> | string
    uploadedBy?: StringFilter<"Providers"> | string
    website?: StringNullableFilter<"Providers"> | string | null
    activationCode?: IntFilter<"Providers"> | number
    status?: StringFilter<"Providers"> | string
    Addresses?: AddressesListRelationFilter
    PlacementListings?: PlacementListingsListRelationFilter
    Placements?: PlacementsListRelationFilter
    ProviderStaff?: ProviderStaffListRelationFilter
    ProviderUserGroups?: ProviderUserGroupsListRelationFilter
    ProviderCohorts?: ProviderCohortsListRelationFilter
  }

  export type ProvidersOrderByWithRelationInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrderInput | SortOrder
    insurance?: SortOrderInput | SortOrder
    mapConsentDate?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrderInput | SortOrder
    rememberConsentDate?: SortOrderInput | SortOrder
    savedBy?: SortOrderInput | SortOrder
    sector?: SortOrder
    referral?: SortOrderInput | SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrderInput | SortOrder
    activationCode?: SortOrder
    status?: SortOrder
    Addresses?: AddressesOrderByRelationAggregateInput
    PlacementListings?: PlacementListingsOrderByRelationAggregateInput
    Placements?: PlacementsOrderByRelationAggregateInput
    ProviderStaff?: ProviderStaffOrderByRelationAggregateInput
    ProviderUserGroups?: ProviderUserGroupsOrderByRelationAggregateInput
    ProviderCohorts?: ProviderCohortsOrderByRelationAggregateInput
  }

  export type ProvidersWhereUniqueInput = Prisma.AtLeast<{
    providerId?: string
    AND?: ProvidersWhereInput | ProvidersWhereInput[]
    OR?: ProvidersWhereInput[]
    NOT?: ProvidersWhereInput | ProvidersWhereInput[]
    contactForename?: StringFilter<"Providers"> | string
    contactSurname?: StringFilter<"Providers"> | string
    email?: StringFilter<"Providers"> | string
    mapConsent?: BoolNullableFilter<"Providers"> | boolean | null
    insurance?: BoolNullableFilter<"Providers"> | boolean | null
    mapConsentDate?: StringNullableFilter<"Providers"> | string | null
    name?: StringFilter<"Providers"> | string
    phone?: StringFilter<"Providers"> | string
    rememberConsent?: BoolNullableFilter<"Providers"> | boolean | null
    rememberConsentDate?: StringNullableFilter<"Providers"> | string | null
    savedBy?: JsonNullableFilter<"Providers">
    sector?: StringFilter<"Providers"> | string
    referral?: StringNullableFilter<"Providers"> | string | null
    subsector?: StringFilter<"Providers"> | string
    uploadedBy?: StringFilter<"Providers"> | string
    website?: StringNullableFilter<"Providers"> | string | null
    activationCode?: IntFilter<"Providers"> | number
    status?: StringFilter<"Providers"> | string
    Addresses?: AddressesListRelationFilter
    PlacementListings?: PlacementListingsListRelationFilter
    Placements?: PlacementsListRelationFilter
    ProviderStaff?: ProviderStaffListRelationFilter
    ProviderUserGroups?: ProviderUserGroupsListRelationFilter
    ProviderCohorts?: ProviderCohortsListRelationFilter
  }, "providerId" | "providerId">

  export type ProvidersOrderByWithAggregationInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrderInput | SortOrder
    insurance?: SortOrderInput | SortOrder
    mapConsentDate?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrderInput | SortOrder
    rememberConsentDate?: SortOrderInput | SortOrder
    savedBy?: SortOrderInput | SortOrder
    sector?: SortOrder
    referral?: SortOrderInput | SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrderInput | SortOrder
    activationCode?: SortOrder
    status?: SortOrder
    _count?: ProvidersCountOrderByAggregateInput
    _avg?: ProvidersAvgOrderByAggregateInput
    _max?: ProvidersMaxOrderByAggregateInput
    _min?: ProvidersMinOrderByAggregateInput
    _sum?: ProvidersSumOrderByAggregateInput
  }

  export type ProvidersScalarWhereWithAggregatesInput = {
    AND?: ProvidersScalarWhereWithAggregatesInput | ProvidersScalarWhereWithAggregatesInput[]
    OR?: ProvidersScalarWhereWithAggregatesInput[]
    NOT?: ProvidersScalarWhereWithAggregatesInput | ProvidersScalarWhereWithAggregatesInput[]
    providerId?: StringWithAggregatesFilter<"Providers"> | string
    contactForename?: StringWithAggregatesFilter<"Providers"> | string
    contactSurname?: StringWithAggregatesFilter<"Providers"> | string
    email?: StringWithAggregatesFilter<"Providers"> | string
    mapConsent?: BoolNullableWithAggregatesFilter<"Providers"> | boolean | null
    insurance?: BoolNullableWithAggregatesFilter<"Providers"> | boolean | null
    mapConsentDate?: StringNullableWithAggregatesFilter<"Providers"> | string | null
    name?: StringWithAggregatesFilter<"Providers"> | string
    phone?: StringWithAggregatesFilter<"Providers"> | string
    rememberConsent?: BoolNullableWithAggregatesFilter<"Providers"> | boolean | null
    rememberConsentDate?: StringNullableWithAggregatesFilter<"Providers"> | string | null
    savedBy?: JsonNullableWithAggregatesFilter<"Providers">
    sector?: StringWithAggregatesFilter<"Providers"> | string
    referral?: StringNullableWithAggregatesFilter<"Providers"> | string | null
    subsector?: StringWithAggregatesFilter<"Providers"> | string
    uploadedBy?: StringWithAggregatesFilter<"Providers"> | string
    website?: StringNullableWithAggregatesFilter<"Providers"> | string | null
    activationCode?: IntWithAggregatesFilter<"Providers"> | number
    status?: StringWithAggregatesFilter<"Providers"> | string
  }

  export type InstituteStudentUserGroupsWhereInput = {
    AND?: InstituteStudentUserGroupsWhereInput | InstituteStudentUserGroupsWhereInput[]
    OR?: InstituteStudentUserGroupsWhereInput[]
    NOT?: InstituteStudentUserGroupsWhereInput | InstituteStudentUserGroupsWhereInput[]
    userGroupId?: StringFilter<"InstituteStudentUserGroups"> | string
    default?: BoolFilter<"InstituteStudentUserGroups"> | boolean
    name?: StringFilter<"InstituteStudentUserGroups"> | string
    updated?: StringFilter<"InstituteStudentUserGroups"> | string
    instituteId?: StringFilter<"InstituteStudentUserGroups"> | string
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    InstituteStudents?: InstituteStudentsListRelationFilter
    Placements?: PlacementsListRelationFilter
  }

  export type InstituteStudentUserGroupsOrderByWithRelationInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
    institute?: InstitutesOrderByWithRelationInput
    InstituteStudents?: InstituteStudentsOrderByRelationAggregateInput
    Placements?: PlacementsOrderByRelationAggregateInput
  }

  export type InstituteStudentUserGroupsWhereUniqueInput = Prisma.AtLeast<{
    userGroupId?: string
    AND?: InstituteStudentUserGroupsWhereInput | InstituteStudentUserGroupsWhereInput[]
    OR?: InstituteStudentUserGroupsWhereInput[]
    NOT?: InstituteStudentUserGroupsWhereInput | InstituteStudentUserGroupsWhereInput[]
    default?: BoolFilter<"InstituteStudentUserGroups"> | boolean
    name?: StringFilter<"InstituteStudentUserGroups"> | string
    updated?: StringFilter<"InstituteStudentUserGroups"> | string
    instituteId?: StringFilter<"InstituteStudentUserGroups"> | string
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    InstituteStudents?: InstituteStudentsListRelationFilter
    Placements?: PlacementsListRelationFilter
  }, "userGroupId" | "userGroupId">

  export type InstituteStudentUserGroupsOrderByWithAggregationInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
    _count?: InstituteStudentUserGroupsCountOrderByAggregateInput
    _max?: InstituteStudentUserGroupsMaxOrderByAggregateInput
    _min?: InstituteStudentUserGroupsMinOrderByAggregateInput
  }

  export type InstituteStudentUserGroupsScalarWhereWithAggregatesInput = {
    AND?: InstituteStudentUserGroupsScalarWhereWithAggregatesInput | InstituteStudentUserGroupsScalarWhereWithAggregatesInput[]
    OR?: InstituteStudentUserGroupsScalarWhereWithAggregatesInput[]
    NOT?: InstituteStudentUserGroupsScalarWhereWithAggregatesInput | InstituteStudentUserGroupsScalarWhereWithAggregatesInput[]
    userGroupId?: StringWithAggregatesFilter<"InstituteStudentUserGroups"> | string
    default?: BoolWithAggregatesFilter<"InstituteStudentUserGroups"> | boolean
    name?: StringWithAggregatesFilter<"InstituteStudentUserGroups"> | string
    updated?: StringWithAggregatesFilter<"InstituteStudentUserGroups"> | string
    instituteId?: StringWithAggregatesFilter<"InstituteStudentUserGroups"> | string
  }

  export type InstituteStaffUserGroupsWhereInput = {
    AND?: InstituteStaffUserGroupsWhereInput | InstituteStaffUserGroupsWhereInput[]
    OR?: InstituteStaffUserGroupsWhereInput[]
    NOT?: InstituteStaffUserGroupsWhereInput | InstituteStaffUserGroupsWhereInput[]
    userGroupId?: StringFilter<"InstituteStaffUserGroups"> | string
    default?: BoolFilter<"InstituteStaffUserGroups"> | boolean
    name?: StringFilter<"InstituteStaffUserGroups"> | string
    updated?: StringFilter<"InstituteStaffUserGroups"> | string
    instituteId?: StringFilter<"InstituteStaffUserGroups"> | string
    InstituteStaff?: InstituteStaffListRelationFilter
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
  }

  export type InstituteStaffUserGroupsOrderByWithRelationInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
    InstituteStaff?: InstituteStaffOrderByRelationAggregateInput
    institute?: InstitutesOrderByWithRelationInput
  }

  export type InstituteStaffUserGroupsWhereUniqueInput = Prisma.AtLeast<{
    userGroupId?: string
    AND?: InstituteStaffUserGroupsWhereInput | InstituteStaffUserGroupsWhereInput[]
    OR?: InstituteStaffUserGroupsWhereInput[]
    NOT?: InstituteStaffUserGroupsWhereInput | InstituteStaffUserGroupsWhereInput[]
    default?: BoolFilter<"InstituteStaffUserGroups"> | boolean
    name?: StringFilter<"InstituteStaffUserGroups"> | string
    updated?: StringFilter<"InstituteStaffUserGroups"> | string
    instituteId?: StringFilter<"InstituteStaffUserGroups"> | string
    InstituteStaff?: InstituteStaffListRelationFilter
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
  }, "userGroupId" | "userGroupId">

  export type InstituteStaffUserGroupsOrderByWithAggregationInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
    _count?: InstituteStaffUserGroupsCountOrderByAggregateInput
    _max?: InstituteStaffUserGroupsMaxOrderByAggregateInput
    _min?: InstituteStaffUserGroupsMinOrderByAggregateInput
  }

  export type InstituteStaffUserGroupsScalarWhereWithAggregatesInput = {
    AND?: InstituteStaffUserGroupsScalarWhereWithAggregatesInput | InstituteStaffUserGroupsScalarWhereWithAggregatesInput[]
    OR?: InstituteStaffUserGroupsScalarWhereWithAggregatesInput[]
    NOT?: InstituteStaffUserGroupsScalarWhereWithAggregatesInput | InstituteStaffUserGroupsScalarWhereWithAggregatesInput[]
    userGroupId?: StringWithAggregatesFilter<"InstituteStaffUserGroups"> | string
    default?: BoolWithAggregatesFilter<"InstituteStaffUserGroups"> | boolean
    name?: StringWithAggregatesFilter<"InstituteStaffUserGroups"> | string
    updated?: StringWithAggregatesFilter<"InstituteStaffUserGroups"> | string
    instituteId?: StringWithAggregatesFilter<"InstituteStaffUserGroups"> | string
  }

  export type ProviderUserGroupsWhereInput = {
    AND?: ProviderUserGroupsWhereInput | ProviderUserGroupsWhereInput[]
    OR?: ProviderUserGroupsWhereInput[]
    NOT?: ProviderUserGroupsWhereInput | ProviderUserGroupsWhereInput[]
    userGroupId?: StringFilter<"ProviderUserGroups"> | string
    default?: BoolFilter<"ProviderUserGroups"> | boolean
    name?: StringFilter<"ProviderUserGroups"> | string
    updated?: StringFilter<"ProviderUserGroups"> | string
    providerId?: StringFilter<"ProviderUserGroups"> | string
    ProviderStaff?: ProviderStaffListRelationFilter
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
  }

  export type ProviderUserGroupsOrderByWithRelationInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    providerId?: SortOrder
    ProviderStaff?: ProviderStaffOrderByRelationAggregateInput
    provider?: ProvidersOrderByWithRelationInput
  }

  export type ProviderUserGroupsWhereUniqueInput = Prisma.AtLeast<{
    userGroupId?: string
    AND?: ProviderUserGroupsWhereInput | ProviderUserGroupsWhereInput[]
    OR?: ProviderUserGroupsWhereInput[]
    NOT?: ProviderUserGroupsWhereInput | ProviderUserGroupsWhereInput[]
    default?: BoolFilter<"ProviderUserGroups"> | boolean
    name?: StringFilter<"ProviderUserGroups"> | string
    updated?: StringFilter<"ProviderUserGroups"> | string
    providerId?: StringFilter<"ProviderUserGroups"> | string
    ProviderStaff?: ProviderStaffListRelationFilter
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
  }, "userGroupId" | "userGroupId">

  export type ProviderUserGroupsOrderByWithAggregationInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    providerId?: SortOrder
    _count?: ProviderUserGroupsCountOrderByAggregateInput
    _max?: ProviderUserGroupsMaxOrderByAggregateInput
    _min?: ProviderUserGroupsMinOrderByAggregateInput
  }

  export type ProviderUserGroupsScalarWhereWithAggregatesInput = {
    AND?: ProviderUserGroupsScalarWhereWithAggregatesInput | ProviderUserGroupsScalarWhereWithAggregatesInput[]
    OR?: ProviderUserGroupsScalarWhereWithAggregatesInput[]
    NOT?: ProviderUserGroupsScalarWhereWithAggregatesInput | ProviderUserGroupsScalarWhereWithAggregatesInput[]
    userGroupId?: StringWithAggregatesFilter<"ProviderUserGroups"> | string
    default?: BoolWithAggregatesFilter<"ProviderUserGroups"> | boolean
    name?: StringWithAggregatesFilter<"ProviderUserGroups"> | string
    updated?: StringWithAggregatesFilter<"ProviderUserGroups"> | string
    providerId?: StringWithAggregatesFilter<"ProviderUserGroups"> | string
  }

  export type StudentUsersWhereInput = {
    AND?: StudentUsersWhereInput | StudentUsersWhereInput[]
    OR?: StudentUsersWhereInput[]
    NOT?: StudentUsersWhereInput | StudentUsersWhereInput[]
    studentUserId?: StringFilter<"StudentUsers"> | string
    status?: StringFilter<"StudentUsers"> | string
    analytics?: JsonFilter<"StudentUsers">
    created?: StringFilter<"StudentUsers"> | string
    details?: JsonFilter<"StudentUsers">
    email?: StringFilter<"StudentUsers"> | string
    referral?: StringFilter<"StudentUsers"> | string
    units?: StringFilter<"StudentUsers"> | string
    userType?: StringFilter<"StudentUsers"> | string
    Contacts?: ContactsListRelationFilter
    Placements?: PlacementsListRelationFilter
  }

  export type StudentUsersOrderByWithRelationInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    analytics?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
    Contacts?: ContactsOrderByRelationAggregateInput
    Placements?: PlacementsOrderByRelationAggregateInput
  }

  export type StudentUsersWhereUniqueInput = Prisma.AtLeast<{
    studentUserId?: string
    AND?: StudentUsersWhereInput | StudentUsersWhereInput[]
    OR?: StudentUsersWhereInput[]
    NOT?: StudentUsersWhereInput | StudentUsersWhereInput[]
    status?: StringFilter<"StudentUsers"> | string
    analytics?: JsonFilter<"StudentUsers">
    created?: StringFilter<"StudentUsers"> | string
    details?: JsonFilter<"StudentUsers">
    email?: StringFilter<"StudentUsers"> | string
    referral?: StringFilter<"StudentUsers"> | string
    units?: StringFilter<"StudentUsers"> | string
    userType?: StringFilter<"StudentUsers"> | string
    Contacts?: ContactsListRelationFilter
    Placements?: PlacementsListRelationFilter
  }, "studentUserId">

  export type StudentUsersOrderByWithAggregationInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    analytics?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
    _count?: StudentUsersCountOrderByAggregateInput
    _max?: StudentUsersMaxOrderByAggregateInput
    _min?: StudentUsersMinOrderByAggregateInput
  }

  export type StudentUsersScalarWhereWithAggregatesInput = {
    AND?: StudentUsersScalarWhereWithAggregatesInput | StudentUsersScalarWhereWithAggregatesInput[]
    OR?: StudentUsersScalarWhereWithAggregatesInput[]
    NOT?: StudentUsersScalarWhereWithAggregatesInput | StudentUsersScalarWhereWithAggregatesInput[]
    studentUserId?: StringWithAggregatesFilter<"StudentUsers"> | string
    status?: StringWithAggregatesFilter<"StudentUsers"> | string
    analytics?: JsonWithAggregatesFilter<"StudentUsers">
    created?: StringWithAggregatesFilter<"StudentUsers"> | string
    details?: JsonWithAggregatesFilter<"StudentUsers">
    email?: StringWithAggregatesFilter<"StudentUsers"> | string
    referral?: StringWithAggregatesFilter<"StudentUsers"> | string
    units?: StringWithAggregatesFilter<"StudentUsers"> | string
    userType?: StringWithAggregatesFilter<"StudentUsers"> | string
  }

  export type InstituteStaffWhereInput = {
    AND?: InstituteStaffWhereInput | InstituteStaffWhereInput[]
    OR?: InstituteStaffWhereInput[]
    NOT?: InstituteStaffWhereInput | InstituteStaffWhereInput[]
    instituteStaffId?: StringFilter<"InstituteStaff"> | string
    created?: StringFilter<"InstituteStaff"> | string
    details?: JsonFilter<"InstituteStaff">
    email?: StringFilter<"InstituteStaff"> | string
    oId?: StringFilter<"InstituteStaff"> | string
    status?: StringFilter<"InstituteStaff"> | string
    userType?: StringFilter<"InstituteStaff"> | string
    instituteId?: StringFilter<"InstituteStaff"> | string
    userGroupId?: StringFilter<"InstituteStaff"> | string
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    userGroup?: XOR<InstituteStaffUserGroupsRelationFilter, InstituteStaffUserGroupsWhereInput>
  }

  export type InstituteStaffOrderByWithRelationInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
    institute?: InstitutesOrderByWithRelationInput
    userGroup?: InstituteStaffUserGroupsOrderByWithRelationInput
  }

  export type InstituteStaffWhereUniqueInput = Prisma.AtLeast<{
    instituteStaffId?: string
    AND?: InstituteStaffWhereInput | InstituteStaffWhereInput[]
    OR?: InstituteStaffWhereInput[]
    NOT?: InstituteStaffWhereInput | InstituteStaffWhereInput[]
    created?: StringFilter<"InstituteStaff"> | string
    details?: JsonFilter<"InstituteStaff">
    email?: StringFilter<"InstituteStaff"> | string
    oId?: StringFilter<"InstituteStaff"> | string
    status?: StringFilter<"InstituteStaff"> | string
    userType?: StringFilter<"InstituteStaff"> | string
    instituteId?: StringFilter<"InstituteStaff"> | string
    userGroupId?: StringFilter<"InstituteStaff"> | string
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    userGroup?: XOR<InstituteStaffUserGroupsRelationFilter, InstituteStaffUserGroupsWhereInput>
  }, "instituteStaffId">

  export type InstituteStaffOrderByWithAggregationInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
    _count?: InstituteStaffCountOrderByAggregateInput
    _max?: InstituteStaffMaxOrderByAggregateInput
    _min?: InstituteStaffMinOrderByAggregateInput
  }

  export type InstituteStaffScalarWhereWithAggregatesInput = {
    AND?: InstituteStaffScalarWhereWithAggregatesInput | InstituteStaffScalarWhereWithAggregatesInput[]
    OR?: InstituteStaffScalarWhereWithAggregatesInput[]
    NOT?: InstituteStaffScalarWhereWithAggregatesInput | InstituteStaffScalarWhereWithAggregatesInput[]
    instituteStaffId?: StringWithAggregatesFilter<"InstituteStaff"> | string
    created?: StringWithAggregatesFilter<"InstituteStaff"> | string
    details?: JsonWithAggregatesFilter<"InstituteStaff">
    email?: StringWithAggregatesFilter<"InstituteStaff"> | string
    oId?: StringWithAggregatesFilter<"InstituteStaff"> | string
    status?: StringWithAggregatesFilter<"InstituteStaff"> | string
    userType?: StringWithAggregatesFilter<"InstituteStaff"> | string
    instituteId?: StringWithAggregatesFilter<"InstituteStaff"> | string
    userGroupId?: StringWithAggregatesFilter<"InstituteStaff"> | string
  }

  export type InstituteStudentsWhereInput = {
    AND?: InstituteStudentsWhereInput | InstituteStudentsWhereInput[]
    OR?: InstituteStudentsWhereInput[]
    NOT?: InstituteStudentsWhereInput | InstituteStudentsWhereInput[]
    instituteStudentId?: StringFilter<"InstituteStudents"> | string
    activated?: StringFilter<"InstituteStudents"> | string
    created?: StringFilter<"InstituteStudents"> | string
    cohortId?: StringFilter<"InstituteStudents"> | string
    details?: JsonFilter<"InstituteStudents">
    email?: StringFilter<"InstituteStudents"> | string
    flags?: StringNullableListFilter<"InstituteStudents">
    oId?: StringFilter<"InstituteStudents"> | string
    resetExpiry?: DateTimeFilter<"InstituteStudents"> | Date | string
    status?: StringFilter<"InstituteStudents"> | string
    userType?: StringFilter<"InstituteStudents"> | string
    instituteId?: StringFilter<"InstituteStudents"> | string
    userGroupId?: StringFilter<"InstituteStudents"> | string
    Contacts?: ContactsListRelationFilter
    cohort?: XOR<CohortsRelationFilter, CohortsWhereInput>
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    userGroup?: XOR<InstituteStudentUserGroupsRelationFilter, InstituteStudentUserGroupsWhereInput>
    Placements?: PlacementsListRelationFilter
  }

  export type InstituteStudentsOrderByWithRelationInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    details?: SortOrder
    email?: SortOrder
    flags?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
    Contacts?: ContactsOrderByRelationAggregateInput
    cohort?: CohortsOrderByWithRelationInput
    institute?: InstitutesOrderByWithRelationInput
    userGroup?: InstituteStudentUserGroupsOrderByWithRelationInput
    Placements?: PlacementsOrderByRelationAggregateInput
  }

  export type InstituteStudentsWhereUniqueInput = Prisma.AtLeast<{
    instituteStudentId?: string
    AND?: InstituteStudentsWhereInput | InstituteStudentsWhereInput[]
    OR?: InstituteStudentsWhereInput[]
    NOT?: InstituteStudentsWhereInput | InstituteStudentsWhereInput[]
    activated?: StringFilter<"InstituteStudents"> | string
    created?: StringFilter<"InstituteStudents"> | string
    cohortId?: StringFilter<"InstituteStudents"> | string
    details?: JsonFilter<"InstituteStudents">
    email?: StringFilter<"InstituteStudents"> | string
    flags?: StringNullableListFilter<"InstituteStudents">
    oId?: StringFilter<"InstituteStudents"> | string
    resetExpiry?: DateTimeFilter<"InstituteStudents"> | Date | string
    status?: StringFilter<"InstituteStudents"> | string
    userType?: StringFilter<"InstituteStudents"> | string
    instituteId?: StringFilter<"InstituteStudents"> | string
    userGroupId?: StringFilter<"InstituteStudents"> | string
    Contacts?: ContactsListRelationFilter
    cohort?: XOR<CohortsRelationFilter, CohortsWhereInput>
    institute?: XOR<InstitutesRelationFilter, InstitutesWhereInput>
    userGroup?: XOR<InstituteStudentUserGroupsRelationFilter, InstituteStudentUserGroupsWhereInput>
    Placements?: PlacementsListRelationFilter
  }, "instituteStudentId">

  export type InstituteStudentsOrderByWithAggregationInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    details?: SortOrder
    email?: SortOrder
    flags?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
    _count?: InstituteStudentsCountOrderByAggregateInput
    _max?: InstituteStudentsMaxOrderByAggregateInput
    _min?: InstituteStudentsMinOrderByAggregateInput
  }

  export type InstituteStudentsScalarWhereWithAggregatesInput = {
    AND?: InstituteStudentsScalarWhereWithAggregatesInput | InstituteStudentsScalarWhereWithAggregatesInput[]
    OR?: InstituteStudentsScalarWhereWithAggregatesInput[]
    NOT?: InstituteStudentsScalarWhereWithAggregatesInput | InstituteStudentsScalarWhereWithAggregatesInput[]
    instituteStudentId?: StringWithAggregatesFilter<"InstituteStudents"> | string
    activated?: StringWithAggregatesFilter<"InstituteStudents"> | string
    created?: StringWithAggregatesFilter<"InstituteStudents"> | string
    cohortId?: StringWithAggregatesFilter<"InstituteStudents"> | string
    details?: JsonWithAggregatesFilter<"InstituteStudents">
    email?: StringWithAggregatesFilter<"InstituteStudents"> | string
    flags?: StringNullableListFilter<"InstituteStudents">
    oId?: StringWithAggregatesFilter<"InstituteStudents"> | string
    resetExpiry?: DateTimeWithAggregatesFilter<"InstituteStudents"> | Date | string
    status?: StringWithAggregatesFilter<"InstituteStudents"> | string
    userType?: StringWithAggregatesFilter<"InstituteStudents"> | string
    instituteId?: StringWithAggregatesFilter<"InstituteStudents"> | string
    userGroupId?: StringWithAggregatesFilter<"InstituteStudents"> | string
  }

  export type ProviderStaffWhereInput = {
    AND?: ProviderStaffWhereInput | ProviderStaffWhereInput[]
    OR?: ProviderStaffWhereInput[]
    NOT?: ProviderStaffWhereInput | ProviderStaffWhereInput[]
    providerStaffId?: StringFilter<"ProviderStaff"> | string
    created?: StringFilter<"ProviderStaff"> | string
    details?: JsonFilter<"ProviderStaff">
    email?: StringFilter<"ProviderStaff"> | string
    notes?: JsonNullableFilter<"ProviderStaff">
    status?: StringFilter<"ProviderStaff"> | string
    providerId?: StringFilter<"ProviderStaff"> | string
    userGroupId?: StringFilter<"ProviderStaff"> | string
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
    userGroup?: XOR<ProviderUserGroupsRelationFilter, ProviderUserGroupsWhereInput>
  }

  export type ProviderStaffOrderByWithRelationInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    providerId?: SortOrder
    userGroupId?: SortOrder
    provider?: ProvidersOrderByWithRelationInput
    userGroup?: ProviderUserGroupsOrderByWithRelationInput
  }

  export type ProviderStaffWhereUniqueInput = Prisma.AtLeast<{
    providerStaffId?: string
    AND?: ProviderStaffWhereInput | ProviderStaffWhereInput[]
    OR?: ProviderStaffWhereInput[]
    NOT?: ProviderStaffWhereInput | ProviderStaffWhereInput[]
    created?: StringFilter<"ProviderStaff"> | string
    details?: JsonFilter<"ProviderStaff">
    email?: StringFilter<"ProviderStaff"> | string
    notes?: JsonNullableFilter<"ProviderStaff">
    status?: StringFilter<"ProviderStaff"> | string
    providerId?: StringFilter<"ProviderStaff"> | string
    userGroupId?: StringFilter<"ProviderStaff"> | string
    provider?: XOR<ProvidersRelationFilter, ProvidersWhereInput>
    userGroup?: XOR<ProviderUserGroupsRelationFilter, ProviderUserGroupsWhereInput>
  }, "providerStaffId">

  export type ProviderStaffOrderByWithAggregationInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    providerId?: SortOrder
    userGroupId?: SortOrder
    _count?: ProviderStaffCountOrderByAggregateInput
    _max?: ProviderStaffMaxOrderByAggregateInput
    _min?: ProviderStaffMinOrderByAggregateInput
  }

  export type ProviderStaffScalarWhereWithAggregatesInput = {
    AND?: ProviderStaffScalarWhereWithAggregatesInput | ProviderStaffScalarWhereWithAggregatesInput[]
    OR?: ProviderStaffScalarWhereWithAggregatesInput[]
    NOT?: ProviderStaffScalarWhereWithAggregatesInput | ProviderStaffScalarWhereWithAggregatesInput[]
    providerStaffId?: StringWithAggregatesFilter<"ProviderStaff"> | string
    created?: StringWithAggregatesFilter<"ProviderStaff"> | string
    details?: JsonWithAggregatesFilter<"ProviderStaff">
    email?: StringWithAggregatesFilter<"ProviderStaff"> | string
    notes?: JsonNullableWithAggregatesFilter<"ProviderStaff">
    status?: StringWithAggregatesFilter<"ProviderStaff"> | string
    providerId?: StringWithAggregatesFilter<"ProviderStaff"> | string
    userGroupId?: StringWithAggregatesFilter<"ProviderStaff"> | string
  }

  export type PotentialprovidersWhereInput = {
    AND?: PotentialprovidersWhereInput | PotentialprovidersWhereInput[]
    OR?: PotentialprovidersWhereInput[]
    NOT?: PotentialprovidersWhereInput | PotentialprovidersWhereInput[]
    id?: StringFilter<"Potentialproviders"> | string
    types?: StringNullableListFilter<"Potentialproviders">
    geoHash?: StringFilter<"Potentialproviders"> | string
    nationalPhoneNumber?: StringFilter<"Potentialproviders"> | string
    email?: StringNullableListFilter<"Potentialproviders">
    formattedAddress?: StringFilter<"Potentialproviders"> | string
    websiteUri?: StringFilter<"Potentialproviders"> | string
    name?: StringFilter<"Potentialproviders"> | string
    poid?: StringFilter<"Potentialproviders"> | string
    pointOfOrigin?: XOR<PointOfOriginRelationFilter, pointOfOriginWhereInput>
  }

  export type PotentialprovidersOrderByWithRelationInput = {
    id?: SortOrder
    types?: SortOrder
    geoHash?: SortOrder
    nationalPhoneNumber?: SortOrder
    email?: SortOrder
    formattedAddress?: SortOrder
    websiteUri?: SortOrder
    name?: SortOrder
    poid?: SortOrder
    pointOfOrigin?: pointOfOriginOrderByWithRelationInput
  }

  export type PotentialprovidersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PotentialprovidersWhereInput | PotentialprovidersWhereInput[]
    OR?: PotentialprovidersWhereInput[]
    NOT?: PotentialprovidersWhereInput | PotentialprovidersWhereInput[]
    types?: StringNullableListFilter<"Potentialproviders">
    geoHash?: StringFilter<"Potentialproviders"> | string
    nationalPhoneNumber?: StringFilter<"Potentialproviders"> | string
    email?: StringNullableListFilter<"Potentialproviders">
    formattedAddress?: StringFilter<"Potentialproviders"> | string
    websiteUri?: StringFilter<"Potentialproviders"> | string
    name?: StringFilter<"Potentialproviders"> | string
    poid?: StringFilter<"Potentialproviders"> | string
    pointOfOrigin?: XOR<PointOfOriginRelationFilter, pointOfOriginWhereInput>
  }, "id" | "id">

  export type PotentialprovidersOrderByWithAggregationInput = {
    id?: SortOrder
    types?: SortOrder
    geoHash?: SortOrder
    nationalPhoneNumber?: SortOrder
    email?: SortOrder
    formattedAddress?: SortOrder
    websiteUri?: SortOrder
    name?: SortOrder
    poid?: SortOrder
    _count?: PotentialprovidersCountOrderByAggregateInput
    _max?: PotentialprovidersMaxOrderByAggregateInput
    _min?: PotentialprovidersMinOrderByAggregateInput
  }

  export type PotentialprovidersScalarWhereWithAggregatesInput = {
    AND?: PotentialprovidersScalarWhereWithAggregatesInput | PotentialprovidersScalarWhereWithAggregatesInput[]
    OR?: PotentialprovidersScalarWhereWithAggregatesInput[]
    NOT?: PotentialprovidersScalarWhereWithAggregatesInput | PotentialprovidersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Potentialproviders"> | string
    types?: StringNullableListFilter<"Potentialproviders">
    geoHash?: StringWithAggregatesFilter<"Potentialproviders"> | string
    nationalPhoneNumber?: StringWithAggregatesFilter<"Potentialproviders"> | string
    email?: StringNullableListFilter<"Potentialproviders">
    formattedAddress?: StringWithAggregatesFilter<"Potentialproviders"> | string
    websiteUri?: StringWithAggregatesFilter<"Potentialproviders"> | string
    name?: StringWithAggregatesFilter<"Potentialproviders"> | string
    poid?: StringWithAggregatesFilter<"Potentialproviders"> | string
  }

  export type pointOfOriginWhereInput = {
    AND?: pointOfOriginWhereInput | pointOfOriginWhereInput[]
    OR?: pointOfOriginWhereInput[]
    NOT?: pointOfOriginWhereInput | pointOfOriginWhereInput[]
    poid?: StringFilter<"pointOfOrigin"> | string
    Name?: StringFilter<"pointOfOrigin"> | string
    geoHash?: StringFilter<"pointOfOrigin"> | string
    Potentialproviders?: PotentialprovidersListRelationFilter
  }

  export type pointOfOriginOrderByWithRelationInput = {
    poid?: SortOrder
    Name?: SortOrder
    geoHash?: SortOrder
    Potentialproviders?: PotentialprovidersOrderByRelationAggregateInput
  }

  export type pointOfOriginWhereUniqueInput = Prisma.AtLeast<{
    poid?: string
    AND?: pointOfOriginWhereInput | pointOfOriginWhereInput[]
    OR?: pointOfOriginWhereInput[]
    NOT?: pointOfOriginWhereInput | pointOfOriginWhereInput[]
    Name?: StringFilter<"pointOfOrigin"> | string
    geoHash?: StringFilter<"pointOfOrigin"> | string
    Potentialproviders?: PotentialprovidersListRelationFilter
  }, "poid" | "poid">

  export type pointOfOriginOrderByWithAggregationInput = {
    poid?: SortOrder
    Name?: SortOrder
    geoHash?: SortOrder
    _count?: pointOfOriginCountOrderByAggregateInput
    _max?: pointOfOriginMaxOrderByAggregateInput
    _min?: pointOfOriginMinOrderByAggregateInput
  }

  export type pointOfOriginScalarWhereWithAggregatesInput = {
    AND?: pointOfOriginScalarWhereWithAggregatesInput | pointOfOriginScalarWhereWithAggregatesInput[]
    OR?: pointOfOriginScalarWhereWithAggregatesInput[]
    NOT?: pointOfOriginScalarWhereWithAggregatesInput | pointOfOriginScalarWhereWithAggregatesInput[]
    poid?: StringWithAggregatesFilter<"pointOfOrigin"> | string
    Name?: StringWithAggregatesFilter<"pointOfOrigin"> | string
    geoHash?: StringWithAggregatesFilter<"pointOfOrigin"> | string
  }

  export type AddressesCreateInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    institute?: InstitutesCreateNestedOneWithoutAddressesInput
    provider?: ProvidersCreateNestedOneWithoutAddressesInput
    Contacts?: ContactsCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutAddressInput
    Placements?: PlacementsCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutAddressInput
  }

  export type AddressesUncheckedCreateInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    instituteId?: string | null
    providerId?: string | null
    Contacts?: ContactsUncheckedCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutAddressInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressesUpdateInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    institute?: InstitutesUpdateOneWithoutAddressesNestedInput
    provider?: ProvidersUpdateOneWithoutAddressesNestedInput
    Contacts?: ContactsUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    Contacts?: ContactsUncheckedUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressesCreateManyInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    instituteId?: string | null
    providerId?: string | null
  }

  export type AddressesUpdateManyMutationInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressesUncheckedUpdateManyInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CohortsCreateInput = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
    institute: InstitutesCreateNestedOneWithoutCohortsInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutCohortInput
  }

  export type CohortsUncheckedCreateInput = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
    instituteId: string
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutCohortInput
  }

  export type CohortsUpdateInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutCohortsNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutCohortNestedInput
  }

  export type CohortsUncheckedUpdateInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutCohortNestedInput
  }

  export type CohortsCreateManyInput = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
    instituteId: string
  }

  export type CohortsUpdateManyMutationInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
  }

  export type CohortsUncheckedUpdateManyInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCohortsCreateInput = {
    cohortId: string
    stage: string
    name: string
    address: AddressesCreateNestedOneWithoutProviderCohortsInput
    provider: ProvidersCreateNestedOneWithoutProviderCohortsInput
  }

  export type ProviderCohortsUncheckedCreateInput = {
    cohortId: string
    stage: string
    name: string
    addressId: string
    providerId: string
  }

  export type ProviderCohortsUpdateInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressesUpdateOneRequiredWithoutProviderCohortsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutProviderCohortsNestedInput
  }

  export type ProviderCohortsUncheckedUpdateInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCohortsCreateManyInput = {
    cohortId: string
    stage: string
    name: string
    addressId: string
    providerId: string
  }

  export type ProviderCohortsUpdateManyMutationInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCohortsUncheckedUpdateManyInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsCreateInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstitutestudentUser: InstituteStudentsCreateNestedOneWithoutContactsInput
    address: AddressesCreateNestedOneWithoutContactsInput
    studentUser: StudentUsersCreateNestedOneWithoutContactsInput
  }

  export type ContactsUncheckedCreateInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstituteStudentUserId: string
    addressId: string
    studentUserId: string
  }

  export type ContactsUpdateInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstitutestudentUser?: InstituteStudentsUpdateOneRequiredWithoutContactsNestedInput
    address?: AddressesUpdateOneRequiredWithoutContactsNestedInput
    studentUser?: StudentUsersUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactsUncheckedUpdateInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstituteStudentUserId?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    studentUserId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsCreateManyInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstituteStudentUserId: string
    addressId: string
    studentUserId: string
  }

  export type ContactsUpdateManyMutationInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsUncheckedUpdateManyInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstituteStudentUserId?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    studentUserId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteFormsCreateInput = {
    formId: string
    form: JsonNullValueInput | InputJsonValue
    updated: string
    institute: InstitutesCreateNestedOneWithoutFormsInput
  }

  export type InstituteFormsUncheckedCreateInput = {
    formId: string
    form: JsonNullValueInput | InputJsonValue
    updated: string
    instituteId: string
  }

  export type InstituteFormsUpdateInput = {
    formId?: StringFieldUpdateOperationsInput | string
    form?: JsonNullValueInput | InputJsonValue
    updated?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutFormsNestedInput
  }

  export type InstituteFormsUncheckedUpdateInput = {
    formId?: StringFieldUpdateOperationsInput | string
    form?: JsonNullValueInput | InputJsonValue
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteFormsCreateManyInput = {
    formId: string
    form: JsonNullValueInput | InputJsonValue
    updated: string
    instituteId: string
  }

  export type InstituteFormsUpdateManyMutationInput = {
    formId?: StringFieldUpdateOperationsInput | string
    form?: JsonNullValueInput | InputJsonValue
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteFormsUncheckedUpdateManyInput = {
    formId?: StringFieldUpdateOperationsInput | string
    form?: JsonNullValueInput | InputJsonValue
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type InstitutesCreateInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsUncheckedCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUpdateInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUncheckedUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesCreateManyInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
  }

  export type InstitutesUpdateManyMutationInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
  }

  export type InstitutesUncheckedUpdateManyInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
  }

  export type LogsCreateInput = {
    logId: string
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
    placement: PlacementsCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateInput = {
    logId: string
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
    placementId: string
  }

  export type LogsUpdateInput = {
    logId?: StringFieldUpdateOperationsInput | string
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
    placement?: PlacementsUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateInput = {
    logId?: StringFieldUpdateOperationsInput | string
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
    placementId?: StringFieldUpdateOperationsInput | string
  }

  export type LogsCreateManyInput = {
    logId: string
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
    placementId: string
  }

  export type LogsUpdateManyMutationInput = {
    logId?: StringFieldUpdateOperationsInput | string
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type LogsUncheckedUpdateManyInput = {
    logId?: StringFieldUpdateOperationsInput | string
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
    placementId?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsCreateInput = {
    placementListingId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
    address: AddressesCreateNestedOneWithoutPlacementListingsInput
    provider: ProvidersCreateNestedOneWithoutPlacementListingsInput
  }

  export type PlacementListingsUncheckedCreateInput = {
    placementListingId: string
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementListingsUpdateInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    address?: AddressesUpdateOneRequiredWithoutPlacementListingsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutPlacementListingsNestedInput
  }

  export type PlacementListingsUncheckedUpdateInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsCreateManyInput = {
    placementListingId: string
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementListingsUpdateManyMutationInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsUncheckedUpdateManyInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsCreateInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    Logs?: LogsCreateNestedManyWithoutPlacementInput
    address: AddressesCreateNestedOneWithoutPlacementsInput
    institute: InstitutesCreateNestedOneWithoutPlacementsInput
    instituteStudent: InstituteStudentsCreateNestedOneWithoutPlacementsInput
    provider: ProvidersCreateNestedOneWithoutPlacementsInput
    student: StudentUsersCreateNestedOneWithoutPlacementsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementsUncheckedCreateInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    userGroupId: string
    Logs?: LogsUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementsUpdateInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUpdateManyWithoutPlacementNestedInput
    address?: AddressesUpdateOneRequiredWithoutPlacementsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutPlacementsNestedInput
    instituteStudent?: InstituteStudentsUpdateOneRequiredWithoutPlacementsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutPlacementsNestedInput
    student?: StudentUsersUpdateOneRequiredWithoutPlacementsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementsUncheckedUpdateInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementsCreateManyInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    userGroupId: string
  }

  export type PlacementsUpdateManyMutationInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsUncheckedUpdateManyInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type ProvidersCreateInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutProviderInput
    Placements?: PlacementsCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutProviderInput
  }

  export type ProvidersUncheckedCreateInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesUncheckedCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutProviderInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffUncheckedCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProvidersUpdateInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutProviderNestedInput
  }

  export type ProvidersUncheckedUpdateInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUncheckedUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUncheckedUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProvidersCreateManyInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
  }

  export type ProvidersUpdateManyMutationInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProvidersUncheckedUpdateManyInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentUserGroupsCreateInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    institute: InstitutesCreateNestedOneWithoutStudentUserGroupsInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutUserGroupInput
    Placements?: PlacementsCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStudentUserGroupsUncheckedCreateInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutUserGroupInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStudentUserGroupsUpdateInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutStudentUserGroupsNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutUserGroupNestedInput
    Placements?: PlacementsUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStudentUserGroupsUncheckedUpdateInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutUserGroupNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStudentUserGroupsCreateManyInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
  }

  export type InstituteStudentUserGroupsUpdateManyMutationInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentUserGroupsUncheckedUpdateManyInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUserGroupsCreateInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutUserGroupInput
    institute: InstitutesCreateNestedOneWithoutStaffUserGroupsInput
  }

  export type InstituteStaffUserGroupsUncheckedCreateInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStaffUserGroupsUpdateInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    InstituteStaff?: InstituteStaffUpdateManyWithoutUserGroupNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutStaffUserGroupsNestedInput
  }

  export type InstituteStaffUserGroupsUncheckedUpdateInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStaffUserGroupsCreateManyInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
  }

  export type InstituteStaffUserGroupsUpdateManyMutationInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUserGroupsUncheckedUpdateManyInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderUserGroupsCreateInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    ProviderStaff?: ProviderStaffCreateNestedManyWithoutUserGroupInput
    provider: ProvidersCreateNestedOneWithoutProviderUserGroupsInput
  }

  export type ProviderUserGroupsUncheckedCreateInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    providerId: string
    ProviderStaff?: ProviderStaffUncheckedCreateNestedManyWithoutUserGroupInput
  }

  export type ProviderUserGroupsUpdateInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    ProviderStaff?: ProviderStaffUpdateManyWithoutUserGroupNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutProviderUserGroupsNestedInput
  }

  export type ProviderUserGroupsUncheckedUpdateInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    ProviderStaff?: ProviderStaffUncheckedUpdateManyWithoutUserGroupNestedInput
  }

  export type ProviderUserGroupsCreateManyInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    providerId: string
  }

  export type ProviderUserGroupsUpdateManyMutationInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderUserGroupsUncheckedUpdateManyInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUsersCreateInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
    Contacts?: ContactsCreateNestedManyWithoutStudentUserInput
    Placements?: PlacementsCreateNestedManyWithoutStudentInput
  }

  export type StudentUsersUncheckedCreateInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
    Contacts?: ContactsUncheckedCreateNestedManyWithoutStudentUserInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUsersUpdateInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUpdateManyWithoutStudentUserNestedInput
    Placements?: PlacementsUpdateManyWithoutStudentNestedInput
  }

  export type StudentUsersUncheckedUpdateInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUncheckedUpdateManyWithoutStudentUserNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUsersCreateManyInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
  }

  export type StudentUsersUpdateManyMutationInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUsersUncheckedUpdateManyInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffCreateInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    institute: InstitutesCreateNestedOneWithoutInstituteStaffInput
    userGroup: InstituteStaffUserGroupsCreateNestedOneWithoutInstituteStaffInput
  }

  export type InstituteStaffUncheckedCreateInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
  }

  export type InstituteStaffUpdateInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutInstituteStaffNestedInput
    userGroup?: InstituteStaffUserGroupsUpdateOneRequiredWithoutInstituteStaffNestedInput
  }

  export type InstituteStaffUncheckedUpdateInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffCreateManyInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
  }

  export type InstituteStaffUpdateManyMutationInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUncheckedUpdateManyInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsCreateInput = {
    instituteStudentId: string
    activated: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    Contacts?: ContactsCreateNestedManyWithoutInstitutestudentUserInput
    cohort: CohortsCreateNestedOneWithoutInstituteStudentsInput
    institute: InstitutesCreateNestedOneWithoutInstituteStudentsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutInstituteStudentsInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsUncheckedCreateInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
    Contacts?: ContactsUncheckedCreateNestedManyWithoutInstitutestudentUserInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsUpdateInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUpdateManyWithoutInstitutestudentUserNestedInput
    cohort?: CohortsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutInstituteStudentsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsUncheckedUpdateInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUncheckedUpdateManyWithoutInstitutestudentUserNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsCreateManyInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
  }

  export type InstituteStudentsUpdateManyMutationInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsUncheckedUpdateManyInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffCreateInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    provider: ProvidersCreateNestedOneWithoutProviderStaffInput
    userGroup: ProviderUserGroupsCreateNestedOneWithoutProviderStaffInput
  }

  export type ProviderStaffUncheckedCreateInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    providerId: string
    userGroupId: string
  }

  export type ProviderStaffUpdateInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    provider?: ProvidersUpdateOneRequiredWithoutProviderStaffNestedInput
    userGroup?: ProviderUserGroupsUpdateOneRequiredWithoutProviderStaffNestedInput
  }

  export type ProviderStaffUncheckedUpdateInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffCreateManyInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    providerId: string
    userGroupId: string
  }

  export type ProviderStaffUpdateManyMutationInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffUncheckedUpdateManyInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type PotentialprovidersCreateInput = {
    id: string
    types?: PotentialprovidersCreatetypesInput | string[]
    geoHash: string
    nationalPhoneNumber: string
    email?: PotentialprovidersCreateemailInput | string[]
    formattedAddress: string
    websiteUri: string
    name: string
    pointOfOrigin: pointOfOriginCreateNestedOneWithoutPotentialprovidersInput
  }

  export type PotentialprovidersUncheckedCreateInput = {
    id: string
    types?: PotentialprovidersCreatetypesInput | string[]
    geoHash: string
    nationalPhoneNumber: string
    email?: PotentialprovidersCreateemailInput | string[]
    formattedAddress: string
    websiteUri: string
    name: string
    poid: string
  }

  export type PotentialprovidersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    types?: PotentialprovidersUpdatetypesInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    nationalPhoneNumber?: StringFieldUpdateOperationsInput | string
    email?: PotentialprovidersUpdateemailInput | string[]
    formattedAddress?: StringFieldUpdateOperationsInput | string
    websiteUri?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pointOfOrigin?: pointOfOriginUpdateOneRequiredWithoutPotentialprovidersNestedInput
  }

  export type PotentialprovidersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    types?: PotentialprovidersUpdatetypesInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    nationalPhoneNumber?: StringFieldUpdateOperationsInput | string
    email?: PotentialprovidersUpdateemailInput | string[]
    formattedAddress?: StringFieldUpdateOperationsInput | string
    websiteUri?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    poid?: StringFieldUpdateOperationsInput | string
  }

  export type PotentialprovidersCreateManyInput = {
    id: string
    types?: PotentialprovidersCreatetypesInput | string[]
    geoHash: string
    nationalPhoneNumber: string
    email?: PotentialprovidersCreateemailInput | string[]
    formattedAddress: string
    websiteUri: string
    name: string
    poid: string
  }

  export type PotentialprovidersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    types?: PotentialprovidersUpdatetypesInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    nationalPhoneNumber?: StringFieldUpdateOperationsInput | string
    email?: PotentialprovidersUpdateemailInput | string[]
    formattedAddress?: StringFieldUpdateOperationsInput | string
    websiteUri?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PotentialprovidersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    types?: PotentialprovidersUpdatetypesInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    nationalPhoneNumber?: StringFieldUpdateOperationsInput | string
    email?: PotentialprovidersUpdateemailInput | string[]
    formattedAddress?: StringFieldUpdateOperationsInput | string
    websiteUri?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    poid?: StringFieldUpdateOperationsInput | string
  }

  export type pointOfOriginCreateInput = {
    poid: string
    Name: string
    geoHash: string
    Potentialproviders?: PotentialprovidersCreateNestedManyWithoutPointOfOriginInput
  }

  export type pointOfOriginUncheckedCreateInput = {
    poid: string
    Name: string
    geoHash: string
    Potentialproviders?: PotentialprovidersUncheckedCreateNestedManyWithoutPointOfOriginInput
  }

  export type pointOfOriginUpdateInput = {
    poid?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
    Potentialproviders?: PotentialprovidersUpdateManyWithoutPointOfOriginNestedInput
  }

  export type pointOfOriginUncheckedUpdateInput = {
    poid?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
    Potentialproviders?: PotentialprovidersUncheckedUpdateManyWithoutPointOfOriginNestedInput
  }

  export type pointOfOriginCreateManyInput = {
    poid: string
    Name: string
    geoHash: string
  }

  export type pointOfOriginUpdateManyMutationInput = {
    poid?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
  }

  export type pointOfOriginUncheckedUpdateManyInput = {
    poid?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type InstitutesNullableRelationFilter = {
    is?: InstitutesWhereInput | null
    isNot?: InstitutesWhereInput | null
  }

  export type ProvidersNullableRelationFilter = {
    is?: ProvidersWhereInput | null
    isNot?: ProvidersWhereInput | null
  }

  export type ContactsListRelationFilter = {
    every?: ContactsWhereInput
    some?: ContactsWhereInput
    none?: ContactsWhereInput
  }

  export type PlacementListingsListRelationFilter = {
    every?: PlacementListingsWhereInput
    some?: PlacementListingsWhereInput
    none?: PlacementListingsWhereInput
  }

  export type PlacementsListRelationFilter = {
    every?: PlacementsWhereInput
    some?: PlacementsWhereInput
    none?: PlacementsWhereInput
  }

  export type ProviderCohortsListRelationFilter = {
    every?: ProviderCohortsWhereInput
    some?: ProviderCohortsWhereInput
    none?: ProviderCohortsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ContactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlacementListingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlacementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderCohortsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressesCountOrderByAggregateInput = {
    addressId?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    email?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    phone?: SortOrder
    postal_code?: SortOrder
    instituteId?: SortOrder
    providerId?: SortOrder
  }

  export type AddressesMaxOrderByAggregateInput = {
    addressId?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    email?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    phone?: SortOrder
    postal_code?: SortOrder
    instituteId?: SortOrder
    providerId?: SortOrder
  }

  export type AddressesMinOrderByAggregateInput = {
    addressId?: SortOrder
    name?: SortOrder
    stage?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    email?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    phone?: SortOrder
    postal_code?: SortOrder
    instituteId?: SortOrder
    providerId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type InstitutesRelationFilter = {
    is?: InstitutesWhereInput
    isNot?: InstitutesWhereInput
  }

  export type InstituteStudentsListRelationFilter = {
    every?: InstituteStudentsWhereInput
    some?: InstituteStudentsWhereInput
    none?: InstituteStudentsWhereInput
  }

  export type InstituteStudentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CohortsCountOrderByAggregateInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    includedFiles?: SortOrder
    includedForms?: SortOrder
    workflow?: SortOrder
    instituteId?: SortOrder
  }

  export type CohortsMaxOrderByAggregateInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    workflow?: SortOrder
    instituteId?: SortOrder
  }

  export type CohortsMinOrderByAggregateInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    workflow?: SortOrder
    instituteId?: SortOrder
  }

  export type AddressesRelationFilter = {
    is?: AddressesWhereInput
    isNot?: AddressesWhereInput
  }

  export type ProvidersRelationFilter = {
    is?: ProvidersWhereInput
    isNot?: ProvidersWhereInput
  }

  export type ProviderCohortsCountOrderByAggregateInput = {
    cohortId?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    providerId?: SortOrder
  }

  export type ProviderCohortsMaxOrderByAggregateInput = {
    cohortId?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    providerId?: SortOrder
  }

  export type ProviderCohortsMinOrderByAggregateInput = {
    cohortId?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    providerId?: SortOrder
  }

  export type InstituteStudentsRelationFilter = {
    is?: InstituteStudentsWhereInput
    isNot?: InstituteStudentsWhereInput
  }

  export type StudentUsersRelationFilter = {
    is?: StudentUsersWhereInput
    isNot?: StudentUsersWhereInput
  }

  export type ContactsCountOrderByAggregateInput = {
    contactId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    name?: SortOrder
    providerPhone?: SortOrder
    InstituteStudentUserId?: SortOrder
    addressId?: SortOrder
    studentUserId?: SortOrder
  }

  export type ContactsMaxOrderByAggregateInput = {
    contactId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    name?: SortOrder
    providerPhone?: SortOrder
    InstituteStudentUserId?: SortOrder
    addressId?: SortOrder
    studentUserId?: SortOrder
  }

  export type ContactsMinOrderByAggregateInput = {
    contactId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    name?: SortOrder
    providerPhone?: SortOrder
    InstituteStudentUserId?: SortOrder
    addressId?: SortOrder
    studentUserId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type InstituteFormsCountOrderByAggregateInput = {
    formId?: SortOrder
    form?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }

  export type InstituteFormsMaxOrderByAggregateInput = {
    formId?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }

  export type InstituteFormsMinOrderByAggregateInput = {
    formId?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AddressesListRelationFilter = {
    every?: AddressesWhereInput
    some?: AddressesWhereInput
    none?: AddressesWhereInput
  }

  export type CohortsListRelationFilter = {
    every?: CohortsWhereInput
    some?: CohortsWhereInput
    none?: CohortsWhereInput
  }

  export type InstituteFormsListRelationFilter = {
    every?: InstituteFormsWhereInput
    some?: InstituteFormsWhereInput
    none?: InstituteFormsWhereInput
  }

  export type InstituteStaffListRelationFilter = {
    every?: InstituteStaffWhereInput
    some?: InstituteStaffWhereInput
    none?: InstituteStaffWhereInput
  }

  export type InstituteStaffUserGroupsListRelationFilter = {
    every?: InstituteStaffUserGroupsWhereInput
    some?: InstituteStaffUserGroupsWhereInput
    none?: InstituteStaffUserGroupsWhereInput
  }

  export type InstituteStudentUserGroupsListRelationFilter = {
    every?: InstituteStudentUserGroupsWhereInput
    some?: InstituteStudentUserGroupsWhereInput
    none?: InstituteStudentUserGroupsWhereInput
  }

  export type AddressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CohortsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstituteFormsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstituteStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstituteStaffUserGroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstituteStudentUserGroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutesCountOrderByAggregateInput = {
    instituteId?: SortOrder
    admin?: SortOrder
    externalProviderUploads?: SortOrder
    name?: SortOrder
    referral?: SortOrder
    status?: SortOrder
    studentsFields?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
    staffFields?: SortOrder
    staffGuidance?: SortOrder
    studentsGuidance?: SortOrder
    verifiedProviders?: SortOrder
  }

  export type InstitutesAvgOrderByAggregateInput = {
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
  }

  export type InstitutesMaxOrderByAggregateInput = {
    instituteId?: SortOrder
    admin?: SortOrder
    externalProviderUploads?: SortOrder
    name?: SortOrder
    referral?: SortOrder
    status?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
  }

  export type InstitutesMinOrderByAggregateInput = {
    instituteId?: SortOrder
    admin?: SortOrder
    externalProviderUploads?: SortOrder
    name?: SortOrder
    referral?: SortOrder
    status?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
  }

  export type InstitutesSumOrderByAggregateInput = {
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PlacementsRelationFilter = {
    is?: PlacementsWhereInput
    isNot?: PlacementsWhereInput
  }

  export type LogsCountOrderByAggregateInput = {
    logId?: SortOrder
    provider?: SortOrder
    students?: SortOrder
    staff?: SortOrder
    uid?: SortOrder
    placementId?: SortOrder
  }

  export type LogsMaxOrderByAggregateInput = {
    logId?: SortOrder
    uid?: SortOrder
    placementId?: SortOrder
  }

  export type LogsMinOrderByAggregateInput = {
    logId?: SortOrder
    uid?: SortOrder
    placementId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PlacementListingsCountOrderByAggregateInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    savedBy?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
  }

  export type PlacementListingsMaxOrderByAggregateInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
  }

  export type PlacementListingsMinOrderByAggregateInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LogsListRelationFilter = {
    every?: LogsWhereInput
    some?: LogsWhereInput
    none?: LogsWhereInput
  }

  export type InstituteStudentUserGroupsRelationFilter = {
    is?: InstituteStudentUserGroupsWhereInput
    isNot?: InstituteStudentUserGroupsWhereInput
  }

  export type LogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlacementsCountOrderByAggregateInput = {
    placementId?: SortOrder
    activeDates?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    flags?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    leadTimes?: SortOrder
    name?: SortOrder
    parentEmailed?: SortOrder
    parentExpiry?: SortOrder
    parentKey?: SortOrder
    product?: SortOrder
    providerEmail?: SortOrder
    providerEmailed?: SortOrder
    providerExpiry?: SortOrder
    providerKey?: SortOrder
    providerName?: SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    forms?: SortOrder
    questions?: SortOrder
    uploadedBy?: SortOrder
    addressId?: SortOrder
    instituteId?: SortOrder
    instituteStudentId?: SortOrder
    providerId?: SortOrder
    studentId?: SortOrder
    userGroupId?: SortOrder
  }

  export type PlacementsAvgOrderByAggregateInput = {
    nextStatus?: SortOrder
    status?: SortOrder
  }

  export type PlacementsMaxOrderByAggregateInput = {
    placementId?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    name?: SortOrder
    parentEmailed?: SortOrder
    parentExpiry?: SortOrder
    parentKey?: SortOrder
    product?: SortOrder
    providerEmail?: SortOrder
    providerEmailed?: SortOrder
    providerExpiry?: SortOrder
    providerKey?: SortOrder
    providerName?: SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
    addressId?: SortOrder
    instituteId?: SortOrder
    instituteStudentId?: SortOrder
    providerId?: SortOrder
    studentId?: SortOrder
    userGroupId?: SortOrder
  }

  export type PlacementsMinOrderByAggregateInput = {
    placementId?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    name?: SortOrder
    parentEmailed?: SortOrder
    parentExpiry?: SortOrder
    parentKey?: SortOrder
    product?: SortOrder
    providerEmail?: SortOrder
    providerEmailed?: SortOrder
    providerExpiry?: SortOrder
    providerKey?: SortOrder
    providerName?: SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
    addressId?: SortOrder
    instituteId?: SortOrder
    instituteStudentId?: SortOrder
    providerId?: SortOrder
    studentId?: SortOrder
    userGroupId?: SortOrder
  }

  export type PlacementsSumOrderByAggregateInput = {
    nextStatus?: SortOrder
    status?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProviderStaffListRelationFilter = {
    every?: ProviderStaffWhereInput
    some?: ProviderStaffWhereInput
    none?: ProviderStaffWhereInput
  }

  export type ProviderUserGroupsListRelationFilter = {
    every?: ProviderUserGroupsWhereInput
    some?: ProviderUserGroupsWhereInput
    none?: ProviderUserGroupsWhereInput
  }

  export type ProviderStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderUserGroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvidersCountOrderByAggregateInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrder
    insurance?: SortOrder
    mapConsentDate?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrder
    rememberConsentDate?: SortOrder
    savedBy?: SortOrder
    sector?: SortOrder
    referral?: SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrder
    activationCode?: SortOrder
    status?: SortOrder
  }

  export type ProvidersAvgOrderByAggregateInput = {
    activationCode?: SortOrder
  }

  export type ProvidersMaxOrderByAggregateInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrder
    insurance?: SortOrder
    mapConsentDate?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrder
    rememberConsentDate?: SortOrder
    sector?: SortOrder
    referral?: SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrder
    activationCode?: SortOrder
    status?: SortOrder
  }

  export type ProvidersMinOrderByAggregateInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrder
    insurance?: SortOrder
    mapConsentDate?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrder
    rememberConsentDate?: SortOrder
    sector?: SortOrder
    referral?: SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrder
    activationCode?: SortOrder
    status?: SortOrder
  }

  export type ProvidersSumOrderByAggregateInput = {
    activationCode?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type InstituteStudentUserGroupsCountOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }

  export type InstituteStudentUserGroupsMaxOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }

  export type InstituteStudentUserGroupsMinOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }

  export type InstituteStaffUserGroupsCountOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }

  export type InstituteStaffUserGroupsMaxOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }

  export type InstituteStaffUserGroupsMinOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    instituteId?: SortOrder
  }

  export type ProviderUserGroupsCountOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    providerId?: SortOrder
  }

  export type ProviderUserGroupsMaxOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    providerId?: SortOrder
  }

  export type ProviderUserGroupsMinOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    updated?: SortOrder
    providerId?: SortOrder
  }

  export type StudentUsersCountOrderByAggregateInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    analytics?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
  }

  export type StudentUsersMaxOrderByAggregateInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    created?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
  }

  export type StudentUsersMinOrderByAggregateInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    created?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStaffUserGroupsRelationFilter = {
    is?: InstituteStaffUserGroupsWhereInput
    isNot?: InstituteStaffUserGroupsWhereInput
  }

  export type InstituteStaffCountOrderByAggregateInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
  }

  export type InstituteStaffMaxOrderByAggregateInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
  }

  export type InstituteStaffMinOrderByAggregateInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
  }

  export type CohortsRelationFilter = {
    is?: CohortsWhereInput
    isNot?: CohortsWhereInput
  }

  export type InstituteStudentsCountOrderByAggregateInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    details?: SortOrder
    email?: SortOrder
    flags?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
  }

  export type InstituteStudentsMaxOrderByAggregateInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
  }

  export type InstituteStudentsMinOrderByAggregateInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userType?: SortOrder
    instituteId?: SortOrder
    userGroupId?: SortOrder
  }

  export type ProviderUserGroupsRelationFilter = {
    is?: ProviderUserGroupsWhereInput
    isNot?: ProviderUserGroupsWhereInput
  }

  export type ProviderStaffCountOrderByAggregateInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    providerId?: SortOrder
    userGroupId?: SortOrder
  }

  export type ProviderStaffMaxOrderByAggregateInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    email?: SortOrder
    status?: SortOrder
    providerId?: SortOrder
    userGroupId?: SortOrder
  }

  export type ProviderStaffMinOrderByAggregateInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    email?: SortOrder
    status?: SortOrder
    providerId?: SortOrder
    userGroupId?: SortOrder
  }

  export type PointOfOriginRelationFilter = {
    is?: pointOfOriginWhereInput
    isNot?: pointOfOriginWhereInput
  }

  export type PotentialprovidersCountOrderByAggregateInput = {
    id?: SortOrder
    types?: SortOrder
    geoHash?: SortOrder
    nationalPhoneNumber?: SortOrder
    email?: SortOrder
    formattedAddress?: SortOrder
    websiteUri?: SortOrder
    name?: SortOrder
    poid?: SortOrder
  }

  export type PotentialprovidersMaxOrderByAggregateInput = {
    id?: SortOrder
    geoHash?: SortOrder
    nationalPhoneNumber?: SortOrder
    formattedAddress?: SortOrder
    websiteUri?: SortOrder
    name?: SortOrder
    poid?: SortOrder
  }

  export type PotentialprovidersMinOrderByAggregateInput = {
    id?: SortOrder
    geoHash?: SortOrder
    nationalPhoneNumber?: SortOrder
    formattedAddress?: SortOrder
    websiteUri?: SortOrder
    name?: SortOrder
    poid?: SortOrder
  }

  export type PotentialprovidersListRelationFilter = {
    every?: PotentialprovidersWhereInput
    some?: PotentialprovidersWhereInput
    none?: PotentialprovidersWhereInput
  }

  export type PotentialprovidersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pointOfOriginCountOrderByAggregateInput = {
    poid?: SortOrder
    Name?: SortOrder
    geoHash?: SortOrder
  }

  export type pointOfOriginMaxOrderByAggregateInput = {
    poid?: SortOrder
    Name?: SortOrder
    geoHash?: SortOrder
  }

  export type pointOfOriginMinOrderByAggregateInput = {
    poid?: SortOrder
    Name?: SortOrder
    geoHash?: SortOrder
  }

  export type InstitutesCreateNestedOneWithoutAddressesInput = {
    create?: XOR<InstitutesCreateWithoutAddressesInput, InstitutesUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutAddressesInput
    connect?: InstitutesWhereUniqueInput
  }

  export type ProvidersCreateNestedOneWithoutAddressesInput = {
    create?: XOR<ProvidersCreateWithoutAddressesInput, ProvidersUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutAddressesInput
    connect?: ProvidersWhereUniqueInput
  }

  export type ContactsCreateNestedManyWithoutAddressInput = {
    create?: XOR<ContactsCreateWithoutAddressInput, ContactsUncheckedCreateWithoutAddressInput> | ContactsCreateWithoutAddressInput[] | ContactsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutAddressInput | ContactsCreateOrConnectWithoutAddressInput[]
    createMany?: ContactsCreateManyAddressInputEnvelope
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
  }

  export type PlacementListingsCreateNestedManyWithoutAddressInput = {
    create?: XOR<PlacementListingsCreateWithoutAddressInput, PlacementListingsUncheckedCreateWithoutAddressInput> | PlacementListingsCreateWithoutAddressInput[] | PlacementListingsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: PlacementListingsCreateOrConnectWithoutAddressInput | PlacementListingsCreateOrConnectWithoutAddressInput[]
    createMany?: PlacementListingsCreateManyAddressInputEnvelope
    connect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
  }

  export type PlacementsCreateNestedManyWithoutAddressInput = {
    create?: XOR<PlacementsCreateWithoutAddressInput, PlacementsUncheckedCreateWithoutAddressInput> | PlacementsCreateWithoutAddressInput[] | PlacementsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutAddressInput | PlacementsCreateOrConnectWithoutAddressInput[]
    createMany?: PlacementsCreateManyAddressInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type ProviderCohortsCreateNestedManyWithoutAddressInput = {
    create?: XOR<ProviderCohortsCreateWithoutAddressInput, ProviderCohortsUncheckedCreateWithoutAddressInput> | ProviderCohortsCreateWithoutAddressInput[] | ProviderCohortsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ProviderCohortsCreateOrConnectWithoutAddressInput | ProviderCohortsCreateOrConnectWithoutAddressInput[]
    createMany?: ProviderCohortsCreateManyAddressInputEnvelope
    connect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
  }

  export type ContactsUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<ContactsCreateWithoutAddressInput, ContactsUncheckedCreateWithoutAddressInput> | ContactsCreateWithoutAddressInput[] | ContactsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutAddressInput | ContactsCreateOrConnectWithoutAddressInput[]
    createMany?: ContactsCreateManyAddressInputEnvelope
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
  }

  export type PlacementListingsUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<PlacementListingsCreateWithoutAddressInput, PlacementListingsUncheckedCreateWithoutAddressInput> | PlacementListingsCreateWithoutAddressInput[] | PlacementListingsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: PlacementListingsCreateOrConnectWithoutAddressInput | PlacementListingsCreateOrConnectWithoutAddressInput[]
    createMany?: PlacementListingsCreateManyAddressInputEnvelope
    connect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
  }

  export type PlacementsUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<PlacementsCreateWithoutAddressInput, PlacementsUncheckedCreateWithoutAddressInput> | PlacementsCreateWithoutAddressInput[] | PlacementsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutAddressInput | PlacementsCreateOrConnectWithoutAddressInput[]
    createMany?: PlacementsCreateManyAddressInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type ProviderCohortsUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<ProviderCohortsCreateWithoutAddressInput, ProviderCohortsUncheckedCreateWithoutAddressInput> | ProviderCohortsCreateWithoutAddressInput[] | ProviderCohortsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ProviderCohortsCreateOrConnectWithoutAddressInput | ProviderCohortsCreateOrConnectWithoutAddressInput[]
    createMany?: ProviderCohortsCreateManyAddressInputEnvelope
    connect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type InstitutesUpdateOneWithoutAddressesNestedInput = {
    create?: XOR<InstitutesCreateWithoutAddressesInput, InstitutesUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutAddressesInput
    upsert?: InstitutesUpsertWithoutAddressesInput
    disconnect?: InstitutesWhereInput | boolean
    delete?: InstitutesWhereInput | boolean
    connect?: InstitutesWhereUniqueInput
    update?: XOR<XOR<InstitutesUpdateToOneWithWhereWithoutAddressesInput, InstitutesUpdateWithoutAddressesInput>, InstitutesUncheckedUpdateWithoutAddressesInput>
  }

  export type ProvidersUpdateOneWithoutAddressesNestedInput = {
    create?: XOR<ProvidersCreateWithoutAddressesInput, ProvidersUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutAddressesInput
    upsert?: ProvidersUpsertWithoutAddressesInput
    disconnect?: ProvidersWhereInput | boolean
    delete?: ProvidersWhereInput | boolean
    connect?: ProvidersWhereUniqueInput
    update?: XOR<XOR<ProvidersUpdateToOneWithWhereWithoutAddressesInput, ProvidersUpdateWithoutAddressesInput>, ProvidersUncheckedUpdateWithoutAddressesInput>
  }

  export type ContactsUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ContactsCreateWithoutAddressInput, ContactsUncheckedCreateWithoutAddressInput> | ContactsCreateWithoutAddressInput[] | ContactsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutAddressInput | ContactsCreateOrConnectWithoutAddressInput[]
    upsert?: ContactsUpsertWithWhereUniqueWithoutAddressInput | ContactsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ContactsCreateManyAddressInputEnvelope
    set?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    disconnect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    delete?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    update?: ContactsUpdateWithWhereUniqueWithoutAddressInput | ContactsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ContactsUpdateManyWithWhereWithoutAddressInput | ContactsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
  }

  export type PlacementListingsUpdateManyWithoutAddressNestedInput = {
    create?: XOR<PlacementListingsCreateWithoutAddressInput, PlacementListingsUncheckedCreateWithoutAddressInput> | PlacementListingsCreateWithoutAddressInput[] | PlacementListingsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: PlacementListingsCreateOrConnectWithoutAddressInput | PlacementListingsCreateOrConnectWithoutAddressInput[]
    upsert?: PlacementListingsUpsertWithWhereUniqueWithoutAddressInput | PlacementListingsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: PlacementListingsCreateManyAddressInputEnvelope
    set?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    disconnect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    delete?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    connect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    update?: PlacementListingsUpdateWithWhereUniqueWithoutAddressInput | PlacementListingsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: PlacementListingsUpdateManyWithWhereWithoutAddressInput | PlacementListingsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: PlacementListingsScalarWhereInput | PlacementListingsScalarWhereInput[]
  }

  export type PlacementsUpdateManyWithoutAddressNestedInput = {
    create?: XOR<PlacementsCreateWithoutAddressInput, PlacementsUncheckedCreateWithoutAddressInput> | PlacementsCreateWithoutAddressInput[] | PlacementsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutAddressInput | PlacementsCreateOrConnectWithoutAddressInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutAddressInput | PlacementsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: PlacementsCreateManyAddressInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutAddressInput | PlacementsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutAddressInput | PlacementsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type ProviderCohortsUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ProviderCohortsCreateWithoutAddressInput, ProviderCohortsUncheckedCreateWithoutAddressInput> | ProviderCohortsCreateWithoutAddressInput[] | ProviderCohortsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ProviderCohortsCreateOrConnectWithoutAddressInput | ProviderCohortsCreateOrConnectWithoutAddressInput[]
    upsert?: ProviderCohortsUpsertWithWhereUniqueWithoutAddressInput | ProviderCohortsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ProviderCohortsCreateManyAddressInputEnvelope
    set?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    disconnect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    delete?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    connect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    update?: ProviderCohortsUpdateWithWhereUniqueWithoutAddressInput | ProviderCohortsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ProviderCohortsUpdateManyWithWhereWithoutAddressInput | ProviderCohortsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ProviderCohortsScalarWhereInput | ProviderCohortsScalarWhereInput[]
  }

  export type ContactsUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ContactsCreateWithoutAddressInput, ContactsUncheckedCreateWithoutAddressInput> | ContactsCreateWithoutAddressInput[] | ContactsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutAddressInput | ContactsCreateOrConnectWithoutAddressInput[]
    upsert?: ContactsUpsertWithWhereUniqueWithoutAddressInput | ContactsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ContactsCreateManyAddressInputEnvelope
    set?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    disconnect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    delete?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    update?: ContactsUpdateWithWhereUniqueWithoutAddressInput | ContactsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ContactsUpdateManyWithWhereWithoutAddressInput | ContactsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
  }

  export type PlacementListingsUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<PlacementListingsCreateWithoutAddressInput, PlacementListingsUncheckedCreateWithoutAddressInput> | PlacementListingsCreateWithoutAddressInput[] | PlacementListingsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: PlacementListingsCreateOrConnectWithoutAddressInput | PlacementListingsCreateOrConnectWithoutAddressInput[]
    upsert?: PlacementListingsUpsertWithWhereUniqueWithoutAddressInput | PlacementListingsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: PlacementListingsCreateManyAddressInputEnvelope
    set?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    disconnect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    delete?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    connect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    update?: PlacementListingsUpdateWithWhereUniqueWithoutAddressInput | PlacementListingsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: PlacementListingsUpdateManyWithWhereWithoutAddressInput | PlacementListingsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: PlacementListingsScalarWhereInput | PlacementListingsScalarWhereInput[]
  }

  export type PlacementsUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<PlacementsCreateWithoutAddressInput, PlacementsUncheckedCreateWithoutAddressInput> | PlacementsCreateWithoutAddressInput[] | PlacementsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutAddressInput | PlacementsCreateOrConnectWithoutAddressInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutAddressInput | PlacementsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: PlacementsCreateManyAddressInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutAddressInput | PlacementsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutAddressInput | PlacementsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type ProviderCohortsUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ProviderCohortsCreateWithoutAddressInput, ProviderCohortsUncheckedCreateWithoutAddressInput> | ProviderCohortsCreateWithoutAddressInput[] | ProviderCohortsUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ProviderCohortsCreateOrConnectWithoutAddressInput | ProviderCohortsCreateOrConnectWithoutAddressInput[]
    upsert?: ProviderCohortsUpsertWithWhereUniqueWithoutAddressInput | ProviderCohortsUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ProviderCohortsCreateManyAddressInputEnvelope
    set?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    disconnect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    delete?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    connect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    update?: ProviderCohortsUpdateWithWhereUniqueWithoutAddressInput | ProviderCohortsUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ProviderCohortsUpdateManyWithWhereWithoutAddressInput | ProviderCohortsUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ProviderCohortsScalarWhereInput | ProviderCohortsScalarWhereInput[]
  }

  export type CohortsCreateincludedFilesInput = {
    set: string[]
  }

  export type CohortsCreateincludedFormsInput = {
    set: string[]
  }

  export type InstitutesCreateNestedOneWithoutCohortsInput = {
    create?: XOR<InstitutesCreateWithoutCohortsInput, InstitutesUncheckedCreateWithoutCohortsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutCohortsInput
    connect?: InstitutesWhereUniqueInput
  }

  export type InstituteStudentsCreateNestedManyWithoutCohortInput = {
    create?: XOR<InstituteStudentsCreateWithoutCohortInput, InstituteStudentsUncheckedCreateWithoutCohortInput> | InstituteStudentsCreateWithoutCohortInput[] | InstituteStudentsUncheckedCreateWithoutCohortInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutCohortInput | InstituteStudentsCreateOrConnectWithoutCohortInput[]
    createMany?: InstituteStudentsCreateManyCohortInputEnvelope
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
  }

  export type InstituteStudentsUncheckedCreateNestedManyWithoutCohortInput = {
    create?: XOR<InstituteStudentsCreateWithoutCohortInput, InstituteStudentsUncheckedCreateWithoutCohortInput> | InstituteStudentsCreateWithoutCohortInput[] | InstituteStudentsUncheckedCreateWithoutCohortInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutCohortInput | InstituteStudentsCreateOrConnectWithoutCohortInput[]
    createMany?: InstituteStudentsCreateManyCohortInputEnvelope
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
  }

  export type CohortsUpdateincludedFilesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CohortsUpdateincludedFormsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutesUpdateOneRequiredWithoutCohortsNestedInput = {
    create?: XOR<InstitutesCreateWithoutCohortsInput, InstitutesUncheckedCreateWithoutCohortsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutCohortsInput
    upsert?: InstitutesUpsertWithoutCohortsInput
    connect?: InstitutesWhereUniqueInput
    update?: XOR<XOR<InstitutesUpdateToOneWithWhereWithoutCohortsInput, InstitutesUpdateWithoutCohortsInput>, InstitutesUncheckedUpdateWithoutCohortsInput>
  }

  export type InstituteStudentsUpdateManyWithoutCohortNestedInput = {
    create?: XOR<InstituteStudentsCreateWithoutCohortInput, InstituteStudentsUncheckedCreateWithoutCohortInput> | InstituteStudentsCreateWithoutCohortInput[] | InstituteStudentsUncheckedCreateWithoutCohortInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutCohortInput | InstituteStudentsCreateOrConnectWithoutCohortInput[]
    upsert?: InstituteStudentsUpsertWithWhereUniqueWithoutCohortInput | InstituteStudentsUpsertWithWhereUniqueWithoutCohortInput[]
    createMany?: InstituteStudentsCreateManyCohortInputEnvelope
    set?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    disconnect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    delete?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    update?: InstituteStudentsUpdateWithWhereUniqueWithoutCohortInput | InstituteStudentsUpdateWithWhereUniqueWithoutCohortInput[]
    updateMany?: InstituteStudentsUpdateManyWithWhereWithoutCohortInput | InstituteStudentsUpdateManyWithWhereWithoutCohortInput[]
    deleteMany?: InstituteStudentsScalarWhereInput | InstituteStudentsScalarWhereInput[]
  }

  export type InstituteStudentsUncheckedUpdateManyWithoutCohortNestedInput = {
    create?: XOR<InstituteStudentsCreateWithoutCohortInput, InstituteStudentsUncheckedCreateWithoutCohortInput> | InstituteStudentsCreateWithoutCohortInput[] | InstituteStudentsUncheckedCreateWithoutCohortInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutCohortInput | InstituteStudentsCreateOrConnectWithoutCohortInput[]
    upsert?: InstituteStudentsUpsertWithWhereUniqueWithoutCohortInput | InstituteStudentsUpsertWithWhereUniqueWithoutCohortInput[]
    createMany?: InstituteStudentsCreateManyCohortInputEnvelope
    set?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    disconnect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    delete?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    update?: InstituteStudentsUpdateWithWhereUniqueWithoutCohortInput | InstituteStudentsUpdateWithWhereUniqueWithoutCohortInput[]
    updateMany?: InstituteStudentsUpdateManyWithWhereWithoutCohortInput | InstituteStudentsUpdateManyWithWhereWithoutCohortInput[]
    deleteMany?: InstituteStudentsScalarWhereInput | InstituteStudentsScalarWhereInput[]
  }

  export type AddressesCreateNestedOneWithoutProviderCohortsInput = {
    create?: XOR<AddressesCreateWithoutProviderCohortsInput, AddressesUncheckedCreateWithoutProviderCohortsInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutProviderCohortsInput
    connect?: AddressesWhereUniqueInput
  }

  export type ProvidersCreateNestedOneWithoutProviderCohortsInput = {
    create?: XOR<ProvidersCreateWithoutProviderCohortsInput, ProvidersUncheckedCreateWithoutProviderCohortsInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutProviderCohortsInput
    connect?: ProvidersWhereUniqueInput
  }

  export type AddressesUpdateOneRequiredWithoutProviderCohortsNestedInput = {
    create?: XOR<AddressesCreateWithoutProviderCohortsInput, AddressesUncheckedCreateWithoutProviderCohortsInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutProviderCohortsInput
    upsert?: AddressesUpsertWithoutProviderCohortsInput
    connect?: AddressesWhereUniqueInput
    update?: XOR<XOR<AddressesUpdateToOneWithWhereWithoutProviderCohortsInput, AddressesUpdateWithoutProviderCohortsInput>, AddressesUncheckedUpdateWithoutProviderCohortsInput>
  }

  export type ProvidersUpdateOneRequiredWithoutProviderCohortsNestedInput = {
    create?: XOR<ProvidersCreateWithoutProviderCohortsInput, ProvidersUncheckedCreateWithoutProviderCohortsInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutProviderCohortsInput
    upsert?: ProvidersUpsertWithoutProviderCohortsInput
    connect?: ProvidersWhereUniqueInput
    update?: XOR<XOR<ProvidersUpdateToOneWithWhereWithoutProviderCohortsInput, ProvidersUpdateWithoutProviderCohortsInput>, ProvidersUncheckedUpdateWithoutProviderCohortsInput>
  }

  export type InstituteStudentsCreateNestedOneWithoutContactsInput = {
    create?: XOR<InstituteStudentsCreateWithoutContactsInput, InstituteStudentsUncheckedCreateWithoutContactsInput>
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutContactsInput
    connect?: InstituteStudentsWhereUniqueInput
  }

  export type AddressesCreateNestedOneWithoutContactsInput = {
    create?: XOR<AddressesCreateWithoutContactsInput, AddressesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutContactsInput
    connect?: AddressesWhereUniqueInput
  }

  export type StudentUsersCreateNestedOneWithoutContactsInput = {
    create?: XOR<StudentUsersCreateWithoutContactsInput, StudentUsersUncheckedCreateWithoutContactsInput>
    connectOrCreate?: StudentUsersCreateOrConnectWithoutContactsInput
    connect?: StudentUsersWhereUniqueInput
  }

  export type InstituteStudentsUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<InstituteStudentsCreateWithoutContactsInput, InstituteStudentsUncheckedCreateWithoutContactsInput>
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutContactsInput
    upsert?: InstituteStudentsUpsertWithoutContactsInput
    connect?: InstituteStudentsWhereUniqueInput
    update?: XOR<XOR<InstituteStudentsUpdateToOneWithWhereWithoutContactsInput, InstituteStudentsUpdateWithoutContactsInput>, InstituteStudentsUncheckedUpdateWithoutContactsInput>
  }

  export type AddressesUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<AddressesCreateWithoutContactsInput, AddressesUncheckedCreateWithoutContactsInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutContactsInput
    upsert?: AddressesUpsertWithoutContactsInput
    connect?: AddressesWhereUniqueInput
    update?: XOR<XOR<AddressesUpdateToOneWithWhereWithoutContactsInput, AddressesUpdateWithoutContactsInput>, AddressesUncheckedUpdateWithoutContactsInput>
  }

  export type StudentUsersUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<StudentUsersCreateWithoutContactsInput, StudentUsersUncheckedCreateWithoutContactsInput>
    connectOrCreate?: StudentUsersCreateOrConnectWithoutContactsInput
    upsert?: StudentUsersUpsertWithoutContactsInput
    connect?: StudentUsersWhereUniqueInput
    update?: XOR<XOR<StudentUsersUpdateToOneWithWhereWithoutContactsInput, StudentUsersUpdateWithoutContactsInput>, StudentUsersUncheckedUpdateWithoutContactsInput>
  }

  export type InstitutesCreateNestedOneWithoutFormsInput = {
    create?: XOR<InstitutesCreateWithoutFormsInput, InstitutesUncheckedCreateWithoutFormsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutFormsInput
    connect?: InstitutesWhereUniqueInput
  }

  export type InstitutesUpdateOneRequiredWithoutFormsNestedInput = {
    create?: XOR<InstitutesCreateWithoutFormsInput, InstitutesUncheckedCreateWithoutFormsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutFormsInput
    upsert?: InstitutesUpsertWithoutFormsInput
    connect?: InstitutesWhereUniqueInput
    update?: XOR<XOR<InstitutesUpdateToOneWithWhereWithoutFormsInput, InstitutesUpdateWithoutFormsInput>, InstitutesUncheckedUpdateWithoutFormsInput>
  }

  export type InstitutesCreatestudentsFieldsInput = {
    set: string[]
  }

  export type InstitutesCreatestaffFieldsInput = {
    set: string[]
  }

  export type InstitutesCreateverifiedProvidersInput = {
    set: string[]
  }

  export type AddressesCreateNestedManyWithoutInstituteInput = {
    create?: XOR<AddressesCreateWithoutInstituteInput, AddressesUncheckedCreateWithoutInstituteInput> | AddressesCreateWithoutInstituteInput[] | AddressesUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutInstituteInput | AddressesCreateOrConnectWithoutInstituteInput[]
    createMany?: AddressesCreateManyInstituteInputEnvelope
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
  }

  export type CohortsCreateNestedManyWithoutInstituteInput = {
    create?: XOR<CohortsCreateWithoutInstituteInput, CohortsUncheckedCreateWithoutInstituteInput> | CohortsCreateWithoutInstituteInput[] | CohortsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: CohortsCreateOrConnectWithoutInstituteInput | CohortsCreateOrConnectWithoutInstituteInput[]
    createMany?: CohortsCreateManyInstituteInputEnvelope
    connect?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
  }

  export type InstituteFormsCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteFormsCreateWithoutInstituteInput, InstituteFormsUncheckedCreateWithoutInstituteInput> | InstituteFormsCreateWithoutInstituteInput[] | InstituteFormsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteFormsCreateOrConnectWithoutInstituteInput | InstituteFormsCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteFormsCreateManyInstituteInputEnvelope
    connect?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
  }

  export type InstituteStaffCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteStaffCreateWithoutInstituteInput, InstituteStaffUncheckedCreateWithoutInstituteInput> | InstituteStaffCreateWithoutInstituteInput[] | InstituteStaffUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStaffCreateOrConnectWithoutInstituteInput | InstituteStaffCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteStaffCreateManyInstituteInputEnvelope
    connect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
  }

  export type InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteStaffUserGroupsCreateWithoutInstituteInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput> | InstituteStaffUserGroupsCreateWithoutInstituteInput[] | InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput | InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteStaffUserGroupsCreateManyInstituteInputEnvelope
    connect?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
  }

  export type InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteStudentUserGroupsCreateWithoutInstituteInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput> | InstituteStudentUserGroupsCreateWithoutInstituteInput[] | InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput | InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteStudentUserGroupsCreateManyInstituteInputEnvelope
    connect?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
  }

  export type InstituteStudentsCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteStudentsCreateWithoutInstituteInput, InstituteStudentsUncheckedCreateWithoutInstituteInput> | InstituteStudentsCreateWithoutInstituteInput[] | InstituteStudentsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutInstituteInput | InstituteStudentsCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteStudentsCreateManyInstituteInputEnvelope
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
  }

  export type PlacementsCreateNestedManyWithoutInstituteInput = {
    create?: XOR<PlacementsCreateWithoutInstituteInput, PlacementsUncheckedCreateWithoutInstituteInput> | PlacementsCreateWithoutInstituteInput[] | PlacementsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutInstituteInput | PlacementsCreateOrConnectWithoutInstituteInput[]
    createMany?: PlacementsCreateManyInstituteInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type AddressesUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<AddressesCreateWithoutInstituteInput, AddressesUncheckedCreateWithoutInstituteInput> | AddressesCreateWithoutInstituteInput[] | AddressesUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutInstituteInput | AddressesCreateOrConnectWithoutInstituteInput[]
    createMany?: AddressesCreateManyInstituteInputEnvelope
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
  }

  export type CohortsUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<CohortsCreateWithoutInstituteInput, CohortsUncheckedCreateWithoutInstituteInput> | CohortsCreateWithoutInstituteInput[] | CohortsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: CohortsCreateOrConnectWithoutInstituteInput | CohortsCreateOrConnectWithoutInstituteInput[]
    createMany?: CohortsCreateManyInstituteInputEnvelope
    connect?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
  }

  export type InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteFormsCreateWithoutInstituteInput, InstituteFormsUncheckedCreateWithoutInstituteInput> | InstituteFormsCreateWithoutInstituteInput[] | InstituteFormsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteFormsCreateOrConnectWithoutInstituteInput | InstituteFormsCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteFormsCreateManyInstituteInputEnvelope
    connect?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
  }

  export type InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteStaffCreateWithoutInstituteInput, InstituteStaffUncheckedCreateWithoutInstituteInput> | InstituteStaffCreateWithoutInstituteInput[] | InstituteStaffUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStaffCreateOrConnectWithoutInstituteInput | InstituteStaffCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteStaffCreateManyInstituteInputEnvelope
    connect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
  }

  export type InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteStaffUserGroupsCreateWithoutInstituteInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput> | InstituteStaffUserGroupsCreateWithoutInstituteInput[] | InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput | InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteStaffUserGroupsCreateManyInstituteInputEnvelope
    connect?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
  }

  export type InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteStudentUserGroupsCreateWithoutInstituteInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput> | InstituteStudentUserGroupsCreateWithoutInstituteInput[] | InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput | InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteStudentUserGroupsCreateManyInstituteInputEnvelope
    connect?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
  }

  export type InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<InstituteStudentsCreateWithoutInstituteInput, InstituteStudentsUncheckedCreateWithoutInstituteInput> | InstituteStudentsCreateWithoutInstituteInput[] | InstituteStudentsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutInstituteInput | InstituteStudentsCreateOrConnectWithoutInstituteInput[]
    createMany?: InstituteStudentsCreateManyInstituteInputEnvelope
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
  }

  export type PlacementsUncheckedCreateNestedManyWithoutInstituteInput = {
    create?: XOR<PlacementsCreateWithoutInstituteInput, PlacementsUncheckedCreateWithoutInstituteInput> | PlacementsCreateWithoutInstituteInput[] | PlacementsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutInstituteInput | PlacementsCreateOrConnectWithoutInstituteInput[]
    createMany?: PlacementsCreateManyInstituteInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type InstitutesUpdatestudentsFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InstitutesUpdatestaffFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutesUpdateverifiedProvidersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AddressesUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<AddressesCreateWithoutInstituteInput, AddressesUncheckedCreateWithoutInstituteInput> | AddressesCreateWithoutInstituteInput[] | AddressesUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutInstituteInput | AddressesCreateOrConnectWithoutInstituteInput[]
    upsert?: AddressesUpsertWithWhereUniqueWithoutInstituteInput | AddressesUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: AddressesCreateManyInstituteInputEnvelope
    set?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    disconnect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    delete?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    update?: AddressesUpdateWithWhereUniqueWithoutInstituteInput | AddressesUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: AddressesUpdateManyWithWhereWithoutInstituteInput | AddressesUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
  }

  export type CohortsUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<CohortsCreateWithoutInstituteInput, CohortsUncheckedCreateWithoutInstituteInput> | CohortsCreateWithoutInstituteInput[] | CohortsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: CohortsCreateOrConnectWithoutInstituteInput | CohortsCreateOrConnectWithoutInstituteInput[]
    upsert?: CohortsUpsertWithWhereUniqueWithoutInstituteInput | CohortsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: CohortsCreateManyInstituteInputEnvelope
    set?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
    disconnect?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
    delete?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
    connect?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
    update?: CohortsUpdateWithWhereUniqueWithoutInstituteInput | CohortsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: CohortsUpdateManyWithWhereWithoutInstituteInput | CohortsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: CohortsScalarWhereInput | CohortsScalarWhereInput[]
  }

  export type InstituteFormsUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteFormsCreateWithoutInstituteInput, InstituteFormsUncheckedCreateWithoutInstituteInput> | InstituteFormsCreateWithoutInstituteInput[] | InstituteFormsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteFormsCreateOrConnectWithoutInstituteInput | InstituteFormsCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteFormsUpsertWithWhereUniqueWithoutInstituteInput | InstituteFormsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteFormsCreateManyInstituteInputEnvelope
    set?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
    disconnect?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
    delete?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
    connect?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
    update?: InstituteFormsUpdateWithWhereUniqueWithoutInstituteInput | InstituteFormsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteFormsUpdateManyWithWhereWithoutInstituteInput | InstituteFormsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteFormsScalarWhereInput | InstituteFormsScalarWhereInput[]
  }

  export type InstituteStaffUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteStaffCreateWithoutInstituteInput, InstituteStaffUncheckedCreateWithoutInstituteInput> | InstituteStaffCreateWithoutInstituteInput[] | InstituteStaffUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStaffCreateOrConnectWithoutInstituteInput | InstituteStaffCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteStaffUpsertWithWhereUniqueWithoutInstituteInput | InstituteStaffUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteStaffCreateManyInstituteInputEnvelope
    set?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    disconnect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    delete?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    connect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    update?: InstituteStaffUpdateWithWhereUniqueWithoutInstituteInput | InstituteStaffUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteStaffUpdateManyWithWhereWithoutInstituteInput | InstituteStaffUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteStaffScalarWhereInput | InstituteStaffScalarWhereInput[]
  }

  export type InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteStaffUserGroupsCreateWithoutInstituteInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput> | InstituteStaffUserGroupsCreateWithoutInstituteInput[] | InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput | InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteStaffUserGroupsUpsertWithWhereUniqueWithoutInstituteInput | InstituteStaffUserGroupsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteStaffUserGroupsCreateManyInstituteInputEnvelope
    set?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
    disconnect?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
    delete?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
    connect?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
    update?: InstituteStaffUserGroupsUpdateWithWhereUniqueWithoutInstituteInput | InstituteStaffUserGroupsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteStaffUserGroupsUpdateManyWithWhereWithoutInstituteInput | InstituteStaffUserGroupsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteStaffUserGroupsScalarWhereInput | InstituteStaffUserGroupsScalarWhereInput[]
  }

  export type InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteStudentUserGroupsCreateWithoutInstituteInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput> | InstituteStudentUserGroupsCreateWithoutInstituteInput[] | InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput | InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteStudentUserGroupsUpsertWithWhereUniqueWithoutInstituteInput | InstituteStudentUserGroupsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteStudentUserGroupsCreateManyInstituteInputEnvelope
    set?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
    disconnect?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
    delete?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
    connect?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
    update?: InstituteStudentUserGroupsUpdateWithWhereUniqueWithoutInstituteInput | InstituteStudentUserGroupsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteStudentUserGroupsUpdateManyWithWhereWithoutInstituteInput | InstituteStudentUserGroupsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteStudentUserGroupsScalarWhereInput | InstituteStudentUserGroupsScalarWhereInput[]
  }

  export type InstituteStudentsUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteStudentsCreateWithoutInstituteInput, InstituteStudentsUncheckedCreateWithoutInstituteInput> | InstituteStudentsCreateWithoutInstituteInput[] | InstituteStudentsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutInstituteInput | InstituteStudentsCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteStudentsUpsertWithWhereUniqueWithoutInstituteInput | InstituteStudentsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteStudentsCreateManyInstituteInputEnvelope
    set?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    disconnect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    delete?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    update?: InstituteStudentsUpdateWithWhereUniqueWithoutInstituteInput | InstituteStudentsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteStudentsUpdateManyWithWhereWithoutInstituteInput | InstituteStudentsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteStudentsScalarWhereInput | InstituteStudentsScalarWhereInput[]
  }

  export type PlacementsUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<PlacementsCreateWithoutInstituteInput, PlacementsUncheckedCreateWithoutInstituteInput> | PlacementsCreateWithoutInstituteInput[] | PlacementsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutInstituteInput | PlacementsCreateOrConnectWithoutInstituteInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutInstituteInput | PlacementsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: PlacementsCreateManyInstituteInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutInstituteInput | PlacementsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutInstituteInput | PlacementsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type AddressesUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<AddressesCreateWithoutInstituteInput, AddressesUncheckedCreateWithoutInstituteInput> | AddressesCreateWithoutInstituteInput[] | AddressesUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutInstituteInput | AddressesCreateOrConnectWithoutInstituteInput[]
    upsert?: AddressesUpsertWithWhereUniqueWithoutInstituteInput | AddressesUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: AddressesCreateManyInstituteInputEnvelope
    set?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    disconnect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    delete?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    update?: AddressesUpdateWithWhereUniqueWithoutInstituteInput | AddressesUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: AddressesUpdateManyWithWhereWithoutInstituteInput | AddressesUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
  }

  export type CohortsUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<CohortsCreateWithoutInstituteInput, CohortsUncheckedCreateWithoutInstituteInput> | CohortsCreateWithoutInstituteInput[] | CohortsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: CohortsCreateOrConnectWithoutInstituteInput | CohortsCreateOrConnectWithoutInstituteInput[]
    upsert?: CohortsUpsertWithWhereUniqueWithoutInstituteInput | CohortsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: CohortsCreateManyInstituteInputEnvelope
    set?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
    disconnect?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
    delete?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
    connect?: CohortsWhereUniqueInput | CohortsWhereUniqueInput[]
    update?: CohortsUpdateWithWhereUniqueWithoutInstituteInput | CohortsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: CohortsUpdateManyWithWhereWithoutInstituteInput | CohortsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: CohortsScalarWhereInput | CohortsScalarWhereInput[]
  }

  export type InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteFormsCreateWithoutInstituteInput, InstituteFormsUncheckedCreateWithoutInstituteInput> | InstituteFormsCreateWithoutInstituteInput[] | InstituteFormsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteFormsCreateOrConnectWithoutInstituteInput | InstituteFormsCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteFormsUpsertWithWhereUniqueWithoutInstituteInput | InstituteFormsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteFormsCreateManyInstituteInputEnvelope
    set?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
    disconnect?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
    delete?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
    connect?: InstituteFormsWhereUniqueInput | InstituteFormsWhereUniqueInput[]
    update?: InstituteFormsUpdateWithWhereUniqueWithoutInstituteInput | InstituteFormsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteFormsUpdateManyWithWhereWithoutInstituteInput | InstituteFormsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteFormsScalarWhereInput | InstituteFormsScalarWhereInput[]
  }

  export type InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteStaffCreateWithoutInstituteInput, InstituteStaffUncheckedCreateWithoutInstituteInput> | InstituteStaffCreateWithoutInstituteInput[] | InstituteStaffUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStaffCreateOrConnectWithoutInstituteInput | InstituteStaffCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteStaffUpsertWithWhereUniqueWithoutInstituteInput | InstituteStaffUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteStaffCreateManyInstituteInputEnvelope
    set?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    disconnect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    delete?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    connect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    update?: InstituteStaffUpdateWithWhereUniqueWithoutInstituteInput | InstituteStaffUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteStaffUpdateManyWithWhereWithoutInstituteInput | InstituteStaffUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteStaffScalarWhereInput | InstituteStaffScalarWhereInput[]
  }

  export type InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteStaffUserGroupsCreateWithoutInstituteInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput> | InstituteStaffUserGroupsCreateWithoutInstituteInput[] | InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput | InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteStaffUserGroupsUpsertWithWhereUniqueWithoutInstituteInput | InstituteStaffUserGroupsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteStaffUserGroupsCreateManyInstituteInputEnvelope
    set?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
    disconnect?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
    delete?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
    connect?: InstituteStaffUserGroupsWhereUniqueInput | InstituteStaffUserGroupsWhereUniqueInput[]
    update?: InstituteStaffUserGroupsUpdateWithWhereUniqueWithoutInstituteInput | InstituteStaffUserGroupsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteStaffUserGroupsUpdateManyWithWhereWithoutInstituteInput | InstituteStaffUserGroupsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteStaffUserGroupsScalarWhereInput | InstituteStaffUserGroupsScalarWhereInput[]
  }

  export type InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteStudentUserGroupsCreateWithoutInstituteInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput> | InstituteStudentUserGroupsCreateWithoutInstituteInput[] | InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput | InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteStudentUserGroupsUpsertWithWhereUniqueWithoutInstituteInput | InstituteStudentUserGroupsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteStudentUserGroupsCreateManyInstituteInputEnvelope
    set?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
    disconnect?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
    delete?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
    connect?: InstituteStudentUserGroupsWhereUniqueInput | InstituteStudentUserGroupsWhereUniqueInput[]
    update?: InstituteStudentUserGroupsUpdateWithWhereUniqueWithoutInstituteInput | InstituteStudentUserGroupsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteStudentUserGroupsUpdateManyWithWhereWithoutInstituteInput | InstituteStudentUserGroupsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteStudentUserGroupsScalarWhereInput | InstituteStudentUserGroupsScalarWhereInput[]
  }

  export type InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<InstituteStudentsCreateWithoutInstituteInput, InstituteStudentsUncheckedCreateWithoutInstituteInput> | InstituteStudentsCreateWithoutInstituteInput[] | InstituteStudentsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutInstituteInput | InstituteStudentsCreateOrConnectWithoutInstituteInput[]
    upsert?: InstituteStudentsUpsertWithWhereUniqueWithoutInstituteInput | InstituteStudentsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: InstituteStudentsCreateManyInstituteInputEnvelope
    set?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    disconnect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    delete?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    update?: InstituteStudentsUpdateWithWhereUniqueWithoutInstituteInput | InstituteStudentsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: InstituteStudentsUpdateManyWithWhereWithoutInstituteInput | InstituteStudentsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: InstituteStudentsScalarWhereInput | InstituteStudentsScalarWhereInput[]
  }

  export type PlacementsUncheckedUpdateManyWithoutInstituteNestedInput = {
    create?: XOR<PlacementsCreateWithoutInstituteInput, PlacementsUncheckedCreateWithoutInstituteInput> | PlacementsCreateWithoutInstituteInput[] | PlacementsUncheckedCreateWithoutInstituteInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutInstituteInput | PlacementsCreateOrConnectWithoutInstituteInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutInstituteInput | PlacementsUpsertWithWhereUniqueWithoutInstituteInput[]
    createMany?: PlacementsCreateManyInstituteInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutInstituteInput | PlacementsUpdateWithWhereUniqueWithoutInstituteInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutInstituteInput | PlacementsUpdateManyWithWhereWithoutInstituteInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type PlacementsCreateNestedOneWithoutLogsInput = {
    create?: XOR<PlacementsCreateWithoutLogsInput, PlacementsUncheckedCreateWithoutLogsInput>
    connectOrCreate?: PlacementsCreateOrConnectWithoutLogsInput
    connect?: PlacementsWhereUniqueInput
  }

  export type PlacementsUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<PlacementsCreateWithoutLogsInput, PlacementsUncheckedCreateWithoutLogsInput>
    connectOrCreate?: PlacementsCreateOrConnectWithoutLogsInput
    upsert?: PlacementsUpsertWithoutLogsInput
    connect?: PlacementsWhereUniqueInput
    update?: XOR<XOR<PlacementsUpdateToOneWithWhereWithoutLogsInput, PlacementsUpdateWithoutLogsInput>, PlacementsUncheckedUpdateWithoutLogsInput>
  }

  export type AddressesCreateNestedOneWithoutPlacementListingsInput = {
    create?: XOR<AddressesCreateWithoutPlacementListingsInput, AddressesUncheckedCreateWithoutPlacementListingsInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutPlacementListingsInput
    connect?: AddressesWhereUniqueInput
  }

  export type ProvidersCreateNestedOneWithoutPlacementListingsInput = {
    create?: XOR<ProvidersCreateWithoutPlacementListingsInput, ProvidersUncheckedCreateWithoutPlacementListingsInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutPlacementListingsInput
    connect?: ProvidersWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AddressesUpdateOneRequiredWithoutPlacementListingsNestedInput = {
    create?: XOR<AddressesCreateWithoutPlacementListingsInput, AddressesUncheckedCreateWithoutPlacementListingsInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutPlacementListingsInput
    upsert?: AddressesUpsertWithoutPlacementListingsInput
    connect?: AddressesWhereUniqueInput
    update?: XOR<XOR<AddressesUpdateToOneWithWhereWithoutPlacementListingsInput, AddressesUpdateWithoutPlacementListingsInput>, AddressesUncheckedUpdateWithoutPlacementListingsInput>
  }

  export type ProvidersUpdateOneRequiredWithoutPlacementListingsNestedInput = {
    create?: XOR<ProvidersCreateWithoutPlacementListingsInput, ProvidersUncheckedCreateWithoutPlacementListingsInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutPlacementListingsInput
    upsert?: ProvidersUpsertWithoutPlacementListingsInput
    connect?: ProvidersWhereUniqueInput
    update?: XOR<XOR<ProvidersUpdateToOneWithWhereWithoutPlacementListingsInput, ProvidersUpdateWithoutPlacementListingsInput>, ProvidersUncheckedUpdateWithoutPlacementListingsInput>
  }

  export type PlacementsCreateactiveDatesInput = {
    set: string[]
  }

  export type PlacementsCreateflagsInput = {
    set: string[]
  }

  export type PlacementsCreateleadTimesInput = {
    set: string[]
  }

  export type LogsCreateNestedManyWithoutPlacementInput = {
    create?: XOR<LogsCreateWithoutPlacementInput, LogsUncheckedCreateWithoutPlacementInput> | LogsCreateWithoutPlacementInput[] | LogsUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutPlacementInput | LogsCreateOrConnectWithoutPlacementInput[]
    createMany?: LogsCreateManyPlacementInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type AddressesCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<AddressesCreateWithoutPlacementsInput, AddressesUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutPlacementsInput
    connect?: AddressesWhereUniqueInput
  }

  export type InstitutesCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<InstitutesCreateWithoutPlacementsInput, InstitutesUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutPlacementsInput
    connect?: InstitutesWhereUniqueInput
  }

  export type InstituteStudentsCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<InstituteStudentsCreateWithoutPlacementsInput, InstituteStudentsUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutPlacementsInput
    connect?: InstituteStudentsWhereUniqueInput
  }

  export type ProvidersCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<ProvidersCreateWithoutPlacementsInput, ProvidersUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutPlacementsInput
    connect?: ProvidersWhereUniqueInput
  }

  export type StudentUsersCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<StudentUsersCreateWithoutPlacementsInput, StudentUsersUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: StudentUsersCreateOrConnectWithoutPlacementsInput
    connect?: StudentUsersWhereUniqueInput
  }

  export type InstituteStudentUserGroupsCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<InstituteStudentUserGroupsCreateWithoutPlacementsInput, InstituteStudentUserGroupsUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: InstituteStudentUserGroupsCreateOrConnectWithoutPlacementsInput
    connect?: InstituteStudentUserGroupsWhereUniqueInput
  }

  export type LogsUncheckedCreateNestedManyWithoutPlacementInput = {
    create?: XOR<LogsCreateWithoutPlacementInput, LogsUncheckedCreateWithoutPlacementInput> | LogsCreateWithoutPlacementInput[] | LogsUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutPlacementInput | LogsCreateOrConnectWithoutPlacementInput[]
    createMany?: LogsCreateManyPlacementInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type PlacementsUpdateactiveDatesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlacementsUpdateflagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlacementsUpdateleadTimesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LogsUpdateManyWithoutPlacementNestedInput = {
    create?: XOR<LogsCreateWithoutPlacementInput, LogsUncheckedCreateWithoutPlacementInput> | LogsCreateWithoutPlacementInput[] | LogsUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutPlacementInput | LogsCreateOrConnectWithoutPlacementInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutPlacementInput | LogsUpsertWithWhereUniqueWithoutPlacementInput[]
    createMany?: LogsCreateManyPlacementInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutPlacementInput | LogsUpdateWithWhereUniqueWithoutPlacementInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutPlacementInput | LogsUpdateManyWithWhereWithoutPlacementInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type AddressesUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<AddressesCreateWithoutPlacementsInput, AddressesUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: AddressesCreateOrConnectWithoutPlacementsInput
    upsert?: AddressesUpsertWithoutPlacementsInput
    connect?: AddressesWhereUniqueInput
    update?: XOR<XOR<AddressesUpdateToOneWithWhereWithoutPlacementsInput, AddressesUpdateWithoutPlacementsInput>, AddressesUncheckedUpdateWithoutPlacementsInput>
  }

  export type InstitutesUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<InstitutesCreateWithoutPlacementsInput, InstitutesUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutPlacementsInput
    upsert?: InstitutesUpsertWithoutPlacementsInput
    connect?: InstitutesWhereUniqueInput
    update?: XOR<XOR<InstitutesUpdateToOneWithWhereWithoutPlacementsInput, InstitutesUpdateWithoutPlacementsInput>, InstitutesUncheckedUpdateWithoutPlacementsInput>
  }

  export type InstituteStudentsUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<InstituteStudentsCreateWithoutPlacementsInput, InstituteStudentsUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutPlacementsInput
    upsert?: InstituteStudentsUpsertWithoutPlacementsInput
    connect?: InstituteStudentsWhereUniqueInput
    update?: XOR<XOR<InstituteStudentsUpdateToOneWithWhereWithoutPlacementsInput, InstituteStudentsUpdateWithoutPlacementsInput>, InstituteStudentsUncheckedUpdateWithoutPlacementsInput>
  }

  export type ProvidersUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<ProvidersCreateWithoutPlacementsInput, ProvidersUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutPlacementsInput
    upsert?: ProvidersUpsertWithoutPlacementsInput
    connect?: ProvidersWhereUniqueInput
    update?: XOR<XOR<ProvidersUpdateToOneWithWhereWithoutPlacementsInput, ProvidersUpdateWithoutPlacementsInput>, ProvidersUncheckedUpdateWithoutPlacementsInput>
  }

  export type StudentUsersUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<StudentUsersCreateWithoutPlacementsInput, StudentUsersUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: StudentUsersCreateOrConnectWithoutPlacementsInput
    upsert?: StudentUsersUpsertWithoutPlacementsInput
    connect?: StudentUsersWhereUniqueInput
    update?: XOR<XOR<StudentUsersUpdateToOneWithWhereWithoutPlacementsInput, StudentUsersUpdateWithoutPlacementsInput>, StudentUsersUncheckedUpdateWithoutPlacementsInput>
  }

  export type InstituteStudentUserGroupsUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<InstituteStudentUserGroupsCreateWithoutPlacementsInput, InstituteStudentUserGroupsUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: InstituteStudentUserGroupsCreateOrConnectWithoutPlacementsInput
    upsert?: InstituteStudentUserGroupsUpsertWithoutPlacementsInput
    connect?: InstituteStudentUserGroupsWhereUniqueInput
    update?: XOR<XOR<InstituteStudentUserGroupsUpdateToOneWithWhereWithoutPlacementsInput, InstituteStudentUserGroupsUpdateWithoutPlacementsInput>, InstituteStudentUserGroupsUncheckedUpdateWithoutPlacementsInput>
  }

  export type LogsUncheckedUpdateManyWithoutPlacementNestedInput = {
    create?: XOR<LogsCreateWithoutPlacementInput, LogsUncheckedCreateWithoutPlacementInput> | LogsCreateWithoutPlacementInput[] | LogsUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutPlacementInput | LogsCreateOrConnectWithoutPlacementInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutPlacementInput | LogsUpsertWithWhereUniqueWithoutPlacementInput[]
    createMany?: LogsCreateManyPlacementInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutPlacementInput | LogsUpdateWithWhereUniqueWithoutPlacementInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutPlacementInput | LogsUpdateManyWithWhereWithoutPlacementInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type AddressesCreateNestedManyWithoutProviderInput = {
    create?: XOR<AddressesCreateWithoutProviderInput, AddressesUncheckedCreateWithoutProviderInput> | AddressesCreateWithoutProviderInput[] | AddressesUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutProviderInput | AddressesCreateOrConnectWithoutProviderInput[]
    createMany?: AddressesCreateManyProviderInputEnvelope
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
  }

  export type PlacementListingsCreateNestedManyWithoutProviderInput = {
    create?: XOR<PlacementListingsCreateWithoutProviderInput, PlacementListingsUncheckedCreateWithoutProviderInput> | PlacementListingsCreateWithoutProviderInput[] | PlacementListingsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlacementListingsCreateOrConnectWithoutProviderInput | PlacementListingsCreateOrConnectWithoutProviderInput[]
    createMany?: PlacementListingsCreateManyProviderInputEnvelope
    connect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
  }

  export type PlacementsCreateNestedManyWithoutProviderInput = {
    create?: XOR<PlacementsCreateWithoutProviderInput, PlacementsUncheckedCreateWithoutProviderInput> | PlacementsCreateWithoutProviderInput[] | PlacementsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutProviderInput | PlacementsCreateOrConnectWithoutProviderInput[]
    createMany?: PlacementsCreateManyProviderInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type ProviderStaffCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderStaffCreateWithoutProviderInput, ProviderStaffUncheckedCreateWithoutProviderInput> | ProviderStaffCreateWithoutProviderInput[] | ProviderStaffUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderStaffCreateOrConnectWithoutProviderInput | ProviderStaffCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderStaffCreateManyProviderInputEnvelope
    connect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
  }

  export type ProviderUserGroupsCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderUserGroupsCreateWithoutProviderInput, ProviderUserGroupsUncheckedCreateWithoutProviderInput> | ProviderUserGroupsCreateWithoutProviderInput[] | ProviderUserGroupsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderUserGroupsCreateOrConnectWithoutProviderInput | ProviderUserGroupsCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderUserGroupsCreateManyProviderInputEnvelope
    connect?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
  }

  export type ProviderCohortsCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderCohortsCreateWithoutProviderInput, ProviderCohortsUncheckedCreateWithoutProviderInput> | ProviderCohortsCreateWithoutProviderInput[] | ProviderCohortsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderCohortsCreateOrConnectWithoutProviderInput | ProviderCohortsCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderCohortsCreateManyProviderInputEnvelope
    connect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
  }

  export type AddressesUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<AddressesCreateWithoutProviderInput, AddressesUncheckedCreateWithoutProviderInput> | AddressesCreateWithoutProviderInput[] | AddressesUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutProviderInput | AddressesCreateOrConnectWithoutProviderInput[]
    createMany?: AddressesCreateManyProviderInputEnvelope
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
  }

  export type PlacementListingsUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<PlacementListingsCreateWithoutProviderInput, PlacementListingsUncheckedCreateWithoutProviderInput> | PlacementListingsCreateWithoutProviderInput[] | PlacementListingsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlacementListingsCreateOrConnectWithoutProviderInput | PlacementListingsCreateOrConnectWithoutProviderInput[]
    createMany?: PlacementListingsCreateManyProviderInputEnvelope
    connect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
  }

  export type PlacementsUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<PlacementsCreateWithoutProviderInput, PlacementsUncheckedCreateWithoutProviderInput> | PlacementsCreateWithoutProviderInput[] | PlacementsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutProviderInput | PlacementsCreateOrConnectWithoutProviderInput[]
    createMany?: PlacementsCreateManyProviderInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type ProviderStaffUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderStaffCreateWithoutProviderInput, ProviderStaffUncheckedCreateWithoutProviderInput> | ProviderStaffCreateWithoutProviderInput[] | ProviderStaffUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderStaffCreateOrConnectWithoutProviderInput | ProviderStaffCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderStaffCreateManyProviderInputEnvelope
    connect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
  }

  export type ProviderUserGroupsUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderUserGroupsCreateWithoutProviderInput, ProviderUserGroupsUncheckedCreateWithoutProviderInput> | ProviderUserGroupsCreateWithoutProviderInput[] | ProviderUserGroupsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderUserGroupsCreateOrConnectWithoutProviderInput | ProviderUserGroupsCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderUserGroupsCreateManyProviderInputEnvelope
    connect?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
  }

  export type ProviderCohortsUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderCohortsCreateWithoutProviderInput, ProviderCohortsUncheckedCreateWithoutProviderInput> | ProviderCohortsCreateWithoutProviderInput[] | ProviderCohortsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderCohortsCreateOrConnectWithoutProviderInput | ProviderCohortsCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderCohortsCreateManyProviderInputEnvelope
    connect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AddressesUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AddressesCreateWithoutProviderInput, AddressesUncheckedCreateWithoutProviderInput> | AddressesCreateWithoutProviderInput[] | AddressesUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutProviderInput | AddressesCreateOrConnectWithoutProviderInput[]
    upsert?: AddressesUpsertWithWhereUniqueWithoutProviderInput | AddressesUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AddressesCreateManyProviderInputEnvelope
    set?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    disconnect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    delete?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    update?: AddressesUpdateWithWhereUniqueWithoutProviderInput | AddressesUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AddressesUpdateManyWithWhereWithoutProviderInput | AddressesUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
  }

  export type PlacementListingsUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PlacementListingsCreateWithoutProviderInput, PlacementListingsUncheckedCreateWithoutProviderInput> | PlacementListingsCreateWithoutProviderInput[] | PlacementListingsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlacementListingsCreateOrConnectWithoutProviderInput | PlacementListingsCreateOrConnectWithoutProviderInput[]
    upsert?: PlacementListingsUpsertWithWhereUniqueWithoutProviderInput | PlacementListingsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: PlacementListingsCreateManyProviderInputEnvelope
    set?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    disconnect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    delete?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    connect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    update?: PlacementListingsUpdateWithWhereUniqueWithoutProviderInput | PlacementListingsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PlacementListingsUpdateManyWithWhereWithoutProviderInput | PlacementListingsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PlacementListingsScalarWhereInput | PlacementListingsScalarWhereInput[]
  }

  export type PlacementsUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PlacementsCreateWithoutProviderInput, PlacementsUncheckedCreateWithoutProviderInput> | PlacementsCreateWithoutProviderInput[] | PlacementsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutProviderInput | PlacementsCreateOrConnectWithoutProviderInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutProviderInput | PlacementsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: PlacementsCreateManyProviderInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutProviderInput | PlacementsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutProviderInput | PlacementsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type ProviderStaffUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderStaffCreateWithoutProviderInput, ProviderStaffUncheckedCreateWithoutProviderInput> | ProviderStaffCreateWithoutProviderInput[] | ProviderStaffUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderStaffCreateOrConnectWithoutProviderInput | ProviderStaffCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderStaffUpsertWithWhereUniqueWithoutProviderInput | ProviderStaffUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderStaffCreateManyProviderInputEnvelope
    set?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    disconnect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    delete?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    connect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    update?: ProviderStaffUpdateWithWhereUniqueWithoutProviderInput | ProviderStaffUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderStaffUpdateManyWithWhereWithoutProviderInput | ProviderStaffUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderStaffScalarWhereInput | ProviderStaffScalarWhereInput[]
  }

  export type ProviderUserGroupsUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderUserGroupsCreateWithoutProviderInput, ProviderUserGroupsUncheckedCreateWithoutProviderInput> | ProviderUserGroupsCreateWithoutProviderInput[] | ProviderUserGroupsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderUserGroupsCreateOrConnectWithoutProviderInput | ProviderUserGroupsCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderUserGroupsUpsertWithWhereUniqueWithoutProviderInput | ProviderUserGroupsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderUserGroupsCreateManyProviderInputEnvelope
    set?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
    disconnect?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
    delete?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
    connect?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
    update?: ProviderUserGroupsUpdateWithWhereUniqueWithoutProviderInput | ProviderUserGroupsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderUserGroupsUpdateManyWithWhereWithoutProviderInput | ProviderUserGroupsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderUserGroupsScalarWhereInput | ProviderUserGroupsScalarWhereInput[]
  }

  export type ProviderCohortsUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderCohortsCreateWithoutProviderInput, ProviderCohortsUncheckedCreateWithoutProviderInput> | ProviderCohortsCreateWithoutProviderInput[] | ProviderCohortsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderCohortsCreateOrConnectWithoutProviderInput | ProviderCohortsCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderCohortsUpsertWithWhereUniqueWithoutProviderInput | ProviderCohortsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderCohortsCreateManyProviderInputEnvelope
    set?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    disconnect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    delete?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    connect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    update?: ProviderCohortsUpdateWithWhereUniqueWithoutProviderInput | ProviderCohortsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderCohortsUpdateManyWithWhereWithoutProviderInput | ProviderCohortsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderCohortsScalarWhereInput | ProviderCohortsScalarWhereInput[]
  }

  export type AddressesUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AddressesCreateWithoutProviderInput, AddressesUncheckedCreateWithoutProviderInput> | AddressesCreateWithoutProviderInput[] | AddressesUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AddressesCreateOrConnectWithoutProviderInput | AddressesCreateOrConnectWithoutProviderInput[]
    upsert?: AddressesUpsertWithWhereUniqueWithoutProviderInput | AddressesUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AddressesCreateManyProviderInputEnvelope
    set?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    disconnect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    delete?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    connect?: AddressesWhereUniqueInput | AddressesWhereUniqueInput[]
    update?: AddressesUpdateWithWhereUniqueWithoutProviderInput | AddressesUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AddressesUpdateManyWithWhereWithoutProviderInput | AddressesUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
  }

  export type PlacementListingsUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PlacementListingsCreateWithoutProviderInput, PlacementListingsUncheckedCreateWithoutProviderInput> | PlacementListingsCreateWithoutProviderInput[] | PlacementListingsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlacementListingsCreateOrConnectWithoutProviderInput | PlacementListingsCreateOrConnectWithoutProviderInput[]
    upsert?: PlacementListingsUpsertWithWhereUniqueWithoutProviderInput | PlacementListingsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: PlacementListingsCreateManyProviderInputEnvelope
    set?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    disconnect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    delete?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    connect?: PlacementListingsWhereUniqueInput | PlacementListingsWhereUniqueInput[]
    update?: PlacementListingsUpdateWithWhereUniqueWithoutProviderInput | PlacementListingsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PlacementListingsUpdateManyWithWhereWithoutProviderInput | PlacementListingsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PlacementListingsScalarWhereInput | PlacementListingsScalarWhereInput[]
  }

  export type PlacementsUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PlacementsCreateWithoutProviderInput, PlacementsUncheckedCreateWithoutProviderInput> | PlacementsCreateWithoutProviderInput[] | PlacementsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutProviderInput | PlacementsCreateOrConnectWithoutProviderInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutProviderInput | PlacementsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: PlacementsCreateManyProviderInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutProviderInput | PlacementsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutProviderInput | PlacementsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type ProviderStaffUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderStaffCreateWithoutProviderInput, ProviderStaffUncheckedCreateWithoutProviderInput> | ProviderStaffCreateWithoutProviderInput[] | ProviderStaffUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderStaffCreateOrConnectWithoutProviderInput | ProviderStaffCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderStaffUpsertWithWhereUniqueWithoutProviderInput | ProviderStaffUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderStaffCreateManyProviderInputEnvelope
    set?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    disconnect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    delete?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    connect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    update?: ProviderStaffUpdateWithWhereUniqueWithoutProviderInput | ProviderStaffUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderStaffUpdateManyWithWhereWithoutProviderInput | ProviderStaffUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderStaffScalarWhereInput | ProviderStaffScalarWhereInput[]
  }

  export type ProviderUserGroupsUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderUserGroupsCreateWithoutProviderInput, ProviderUserGroupsUncheckedCreateWithoutProviderInput> | ProviderUserGroupsCreateWithoutProviderInput[] | ProviderUserGroupsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderUserGroupsCreateOrConnectWithoutProviderInput | ProviderUserGroupsCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderUserGroupsUpsertWithWhereUniqueWithoutProviderInput | ProviderUserGroupsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderUserGroupsCreateManyProviderInputEnvelope
    set?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
    disconnect?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
    delete?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
    connect?: ProviderUserGroupsWhereUniqueInput | ProviderUserGroupsWhereUniqueInput[]
    update?: ProviderUserGroupsUpdateWithWhereUniqueWithoutProviderInput | ProviderUserGroupsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderUserGroupsUpdateManyWithWhereWithoutProviderInput | ProviderUserGroupsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderUserGroupsScalarWhereInput | ProviderUserGroupsScalarWhereInput[]
  }

  export type ProviderCohortsUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderCohortsCreateWithoutProviderInput, ProviderCohortsUncheckedCreateWithoutProviderInput> | ProviderCohortsCreateWithoutProviderInput[] | ProviderCohortsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderCohortsCreateOrConnectWithoutProviderInput | ProviderCohortsCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderCohortsUpsertWithWhereUniqueWithoutProviderInput | ProviderCohortsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderCohortsCreateManyProviderInputEnvelope
    set?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    disconnect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    delete?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    connect?: ProviderCohortsWhereUniqueInput | ProviderCohortsWhereUniqueInput[]
    update?: ProviderCohortsUpdateWithWhereUniqueWithoutProviderInput | ProviderCohortsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderCohortsUpdateManyWithWhereWithoutProviderInput | ProviderCohortsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderCohortsScalarWhereInput | ProviderCohortsScalarWhereInput[]
  }

  export type InstitutesCreateNestedOneWithoutStudentUserGroupsInput = {
    create?: XOR<InstitutesCreateWithoutStudentUserGroupsInput, InstitutesUncheckedCreateWithoutStudentUserGroupsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutStudentUserGroupsInput
    connect?: InstitutesWhereUniqueInput
  }

  export type InstituteStudentsCreateNestedManyWithoutUserGroupInput = {
    create?: XOR<InstituteStudentsCreateWithoutUserGroupInput, InstituteStudentsUncheckedCreateWithoutUserGroupInput> | InstituteStudentsCreateWithoutUserGroupInput[] | InstituteStudentsUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutUserGroupInput | InstituteStudentsCreateOrConnectWithoutUserGroupInput[]
    createMany?: InstituteStudentsCreateManyUserGroupInputEnvelope
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
  }

  export type PlacementsCreateNestedManyWithoutUserGroupInput = {
    create?: XOR<PlacementsCreateWithoutUserGroupInput, PlacementsUncheckedCreateWithoutUserGroupInput> | PlacementsCreateWithoutUserGroupInput[] | PlacementsUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutUserGroupInput | PlacementsCreateOrConnectWithoutUserGroupInput[]
    createMany?: PlacementsCreateManyUserGroupInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type InstituteStudentsUncheckedCreateNestedManyWithoutUserGroupInput = {
    create?: XOR<InstituteStudentsCreateWithoutUserGroupInput, InstituteStudentsUncheckedCreateWithoutUserGroupInput> | InstituteStudentsCreateWithoutUserGroupInput[] | InstituteStudentsUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutUserGroupInput | InstituteStudentsCreateOrConnectWithoutUserGroupInput[]
    createMany?: InstituteStudentsCreateManyUserGroupInputEnvelope
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
  }

  export type PlacementsUncheckedCreateNestedManyWithoutUserGroupInput = {
    create?: XOR<PlacementsCreateWithoutUserGroupInput, PlacementsUncheckedCreateWithoutUserGroupInput> | PlacementsCreateWithoutUserGroupInput[] | PlacementsUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutUserGroupInput | PlacementsCreateOrConnectWithoutUserGroupInput[]
    createMany?: PlacementsCreateManyUserGroupInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type InstitutesUpdateOneRequiredWithoutStudentUserGroupsNestedInput = {
    create?: XOR<InstitutesCreateWithoutStudentUserGroupsInput, InstitutesUncheckedCreateWithoutStudentUserGroupsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutStudentUserGroupsInput
    upsert?: InstitutesUpsertWithoutStudentUserGroupsInput
    connect?: InstitutesWhereUniqueInput
    update?: XOR<XOR<InstitutesUpdateToOneWithWhereWithoutStudentUserGroupsInput, InstitutesUpdateWithoutStudentUserGroupsInput>, InstitutesUncheckedUpdateWithoutStudentUserGroupsInput>
  }

  export type InstituteStudentsUpdateManyWithoutUserGroupNestedInput = {
    create?: XOR<InstituteStudentsCreateWithoutUserGroupInput, InstituteStudentsUncheckedCreateWithoutUserGroupInput> | InstituteStudentsCreateWithoutUserGroupInput[] | InstituteStudentsUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutUserGroupInput | InstituteStudentsCreateOrConnectWithoutUserGroupInput[]
    upsert?: InstituteStudentsUpsertWithWhereUniqueWithoutUserGroupInput | InstituteStudentsUpsertWithWhereUniqueWithoutUserGroupInput[]
    createMany?: InstituteStudentsCreateManyUserGroupInputEnvelope
    set?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    disconnect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    delete?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    update?: InstituteStudentsUpdateWithWhereUniqueWithoutUserGroupInput | InstituteStudentsUpdateWithWhereUniqueWithoutUserGroupInput[]
    updateMany?: InstituteStudentsUpdateManyWithWhereWithoutUserGroupInput | InstituteStudentsUpdateManyWithWhereWithoutUserGroupInput[]
    deleteMany?: InstituteStudentsScalarWhereInput | InstituteStudentsScalarWhereInput[]
  }

  export type PlacementsUpdateManyWithoutUserGroupNestedInput = {
    create?: XOR<PlacementsCreateWithoutUserGroupInput, PlacementsUncheckedCreateWithoutUserGroupInput> | PlacementsCreateWithoutUserGroupInput[] | PlacementsUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutUserGroupInput | PlacementsCreateOrConnectWithoutUserGroupInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutUserGroupInput | PlacementsUpsertWithWhereUniqueWithoutUserGroupInput[]
    createMany?: PlacementsCreateManyUserGroupInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutUserGroupInput | PlacementsUpdateWithWhereUniqueWithoutUserGroupInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutUserGroupInput | PlacementsUpdateManyWithWhereWithoutUserGroupInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type InstituteStudentsUncheckedUpdateManyWithoutUserGroupNestedInput = {
    create?: XOR<InstituteStudentsCreateWithoutUserGroupInput, InstituteStudentsUncheckedCreateWithoutUserGroupInput> | InstituteStudentsCreateWithoutUserGroupInput[] | InstituteStudentsUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: InstituteStudentsCreateOrConnectWithoutUserGroupInput | InstituteStudentsCreateOrConnectWithoutUserGroupInput[]
    upsert?: InstituteStudentsUpsertWithWhereUniqueWithoutUserGroupInput | InstituteStudentsUpsertWithWhereUniqueWithoutUserGroupInput[]
    createMany?: InstituteStudentsCreateManyUserGroupInputEnvelope
    set?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    disconnect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    delete?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    connect?: InstituteStudentsWhereUniqueInput | InstituteStudentsWhereUniqueInput[]
    update?: InstituteStudentsUpdateWithWhereUniqueWithoutUserGroupInput | InstituteStudentsUpdateWithWhereUniqueWithoutUserGroupInput[]
    updateMany?: InstituteStudentsUpdateManyWithWhereWithoutUserGroupInput | InstituteStudentsUpdateManyWithWhereWithoutUserGroupInput[]
    deleteMany?: InstituteStudentsScalarWhereInput | InstituteStudentsScalarWhereInput[]
  }

  export type PlacementsUncheckedUpdateManyWithoutUserGroupNestedInput = {
    create?: XOR<PlacementsCreateWithoutUserGroupInput, PlacementsUncheckedCreateWithoutUserGroupInput> | PlacementsCreateWithoutUserGroupInput[] | PlacementsUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutUserGroupInput | PlacementsCreateOrConnectWithoutUserGroupInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutUserGroupInput | PlacementsUpsertWithWhereUniqueWithoutUserGroupInput[]
    createMany?: PlacementsCreateManyUserGroupInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutUserGroupInput | PlacementsUpdateWithWhereUniqueWithoutUserGroupInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutUserGroupInput | PlacementsUpdateManyWithWhereWithoutUserGroupInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type InstituteStaffCreateNestedManyWithoutUserGroupInput = {
    create?: XOR<InstituteStaffCreateWithoutUserGroupInput, InstituteStaffUncheckedCreateWithoutUserGroupInput> | InstituteStaffCreateWithoutUserGroupInput[] | InstituteStaffUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: InstituteStaffCreateOrConnectWithoutUserGroupInput | InstituteStaffCreateOrConnectWithoutUserGroupInput[]
    createMany?: InstituteStaffCreateManyUserGroupInputEnvelope
    connect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
  }

  export type InstitutesCreateNestedOneWithoutStaffUserGroupsInput = {
    create?: XOR<InstitutesCreateWithoutStaffUserGroupsInput, InstitutesUncheckedCreateWithoutStaffUserGroupsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutStaffUserGroupsInput
    connect?: InstitutesWhereUniqueInput
  }

  export type InstituteStaffUncheckedCreateNestedManyWithoutUserGroupInput = {
    create?: XOR<InstituteStaffCreateWithoutUserGroupInput, InstituteStaffUncheckedCreateWithoutUserGroupInput> | InstituteStaffCreateWithoutUserGroupInput[] | InstituteStaffUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: InstituteStaffCreateOrConnectWithoutUserGroupInput | InstituteStaffCreateOrConnectWithoutUserGroupInput[]
    createMany?: InstituteStaffCreateManyUserGroupInputEnvelope
    connect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
  }

  export type InstituteStaffUpdateManyWithoutUserGroupNestedInput = {
    create?: XOR<InstituteStaffCreateWithoutUserGroupInput, InstituteStaffUncheckedCreateWithoutUserGroupInput> | InstituteStaffCreateWithoutUserGroupInput[] | InstituteStaffUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: InstituteStaffCreateOrConnectWithoutUserGroupInput | InstituteStaffCreateOrConnectWithoutUserGroupInput[]
    upsert?: InstituteStaffUpsertWithWhereUniqueWithoutUserGroupInput | InstituteStaffUpsertWithWhereUniqueWithoutUserGroupInput[]
    createMany?: InstituteStaffCreateManyUserGroupInputEnvelope
    set?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    disconnect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    delete?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    connect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    update?: InstituteStaffUpdateWithWhereUniqueWithoutUserGroupInput | InstituteStaffUpdateWithWhereUniqueWithoutUserGroupInput[]
    updateMany?: InstituteStaffUpdateManyWithWhereWithoutUserGroupInput | InstituteStaffUpdateManyWithWhereWithoutUserGroupInput[]
    deleteMany?: InstituteStaffScalarWhereInput | InstituteStaffScalarWhereInput[]
  }

  export type InstitutesUpdateOneRequiredWithoutStaffUserGroupsNestedInput = {
    create?: XOR<InstitutesCreateWithoutStaffUserGroupsInput, InstitutesUncheckedCreateWithoutStaffUserGroupsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutStaffUserGroupsInput
    upsert?: InstitutesUpsertWithoutStaffUserGroupsInput
    connect?: InstitutesWhereUniqueInput
    update?: XOR<XOR<InstitutesUpdateToOneWithWhereWithoutStaffUserGroupsInput, InstitutesUpdateWithoutStaffUserGroupsInput>, InstitutesUncheckedUpdateWithoutStaffUserGroupsInput>
  }

  export type InstituteStaffUncheckedUpdateManyWithoutUserGroupNestedInput = {
    create?: XOR<InstituteStaffCreateWithoutUserGroupInput, InstituteStaffUncheckedCreateWithoutUserGroupInput> | InstituteStaffCreateWithoutUserGroupInput[] | InstituteStaffUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: InstituteStaffCreateOrConnectWithoutUserGroupInput | InstituteStaffCreateOrConnectWithoutUserGroupInput[]
    upsert?: InstituteStaffUpsertWithWhereUniqueWithoutUserGroupInput | InstituteStaffUpsertWithWhereUniqueWithoutUserGroupInput[]
    createMany?: InstituteStaffCreateManyUserGroupInputEnvelope
    set?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    disconnect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    delete?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    connect?: InstituteStaffWhereUniqueInput | InstituteStaffWhereUniqueInput[]
    update?: InstituteStaffUpdateWithWhereUniqueWithoutUserGroupInput | InstituteStaffUpdateWithWhereUniqueWithoutUserGroupInput[]
    updateMany?: InstituteStaffUpdateManyWithWhereWithoutUserGroupInput | InstituteStaffUpdateManyWithWhereWithoutUserGroupInput[]
    deleteMany?: InstituteStaffScalarWhereInput | InstituteStaffScalarWhereInput[]
  }

  export type ProviderStaffCreateNestedManyWithoutUserGroupInput = {
    create?: XOR<ProviderStaffCreateWithoutUserGroupInput, ProviderStaffUncheckedCreateWithoutUserGroupInput> | ProviderStaffCreateWithoutUserGroupInput[] | ProviderStaffUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: ProviderStaffCreateOrConnectWithoutUserGroupInput | ProviderStaffCreateOrConnectWithoutUserGroupInput[]
    createMany?: ProviderStaffCreateManyUserGroupInputEnvelope
    connect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
  }

  export type ProvidersCreateNestedOneWithoutProviderUserGroupsInput = {
    create?: XOR<ProvidersCreateWithoutProviderUserGroupsInput, ProvidersUncheckedCreateWithoutProviderUserGroupsInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutProviderUserGroupsInput
    connect?: ProvidersWhereUniqueInput
  }

  export type ProviderStaffUncheckedCreateNestedManyWithoutUserGroupInput = {
    create?: XOR<ProviderStaffCreateWithoutUserGroupInput, ProviderStaffUncheckedCreateWithoutUserGroupInput> | ProviderStaffCreateWithoutUserGroupInput[] | ProviderStaffUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: ProviderStaffCreateOrConnectWithoutUserGroupInput | ProviderStaffCreateOrConnectWithoutUserGroupInput[]
    createMany?: ProviderStaffCreateManyUserGroupInputEnvelope
    connect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
  }

  export type ProviderStaffUpdateManyWithoutUserGroupNestedInput = {
    create?: XOR<ProviderStaffCreateWithoutUserGroupInput, ProviderStaffUncheckedCreateWithoutUserGroupInput> | ProviderStaffCreateWithoutUserGroupInput[] | ProviderStaffUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: ProviderStaffCreateOrConnectWithoutUserGroupInput | ProviderStaffCreateOrConnectWithoutUserGroupInput[]
    upsert?: ProviderStaffUpsertWithWhereUniqueWithoutUserGroupInput | ProviderStaffUpsertWithWhereUniqueWithoutUserGroupInput[]
    createMany?: ProviderStaffCreateManyUserGroupInputEnvelope
    set?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    disconnect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    delete?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    connect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    update?: ProviderStaffUpdateWithWhereUniqueWithoutUserGroupInput | ProviderStaffUpdateWithWhereUniqueWithoutUserGroupInput[]
    updateMany?: ProviderStaffUpdateManyWithWhereWithoutUserGroupInput | ProviderStaffUpdateManyWithWhereWithoutUserGroupInput[]
    deleteMany?: ProviderStaffScalarWhereInput | ProviderStaffScalarWhereInput[]
  }

  export type ProvidersUpdateOneRequiredWithoutProviderUserGroupsNestedInput = {
    create?: XOR<ProvidersCreateWithoutProviderUserGroupsInput, ProvidersUncheckedCreateWithoutProviderUserGroupsInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutProviderUserGroupsInput
    upsert?: ProvidersUpsertWithoutProviderUserGroupsInput
    connect?: ProvidersWhereUniqueInput
    update?: XOR<XOR<ProvidersUpdateToOneWithWhereWithoutProviderUserGroupsInput, ProvidersUpdateWithoutProviderUserGroupsInput>, ProvidersUncheckedUpdateWithoutProviderUserGroupsInput>
  }

  export type ProviderStaffUncheckedUpdateManyWithoutUserGroupNestedInput = {
    create?: XOR<ProviderStaffCreateWithoutUserGroupInput, ProviderStaffUncheckedCreateWithoutUserGroupInput> | ProviderStaffCreateWithoutUserGroupInput[] | ProviderStaffUncheckedCreateWithoutUserGroupInput[]
    connectOrCreate?: ProviderStaffCreateOrConnectWithoutUserGroupInput | ProviderStaffCreateOrConnectWithoutUserGroupInput[]
    upsert?: ProviderStaffUpsertWithWhereUniqueWithoutUserGroupInput | ProviderStaffUpsertWithWhereUniqueWithoutUserGroupInput[]
    createMany?: ProviderStaffCreateManyUserGroupInputEnvelope
    set?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    disconnect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    delete?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    connect?: ProviderStaffWhereUniqueInput | ProviderStaffWhereUniqueInput[]
    update?: ProviderStaffUpdateWithWhereUniqueWithoutUserGroupInput | ProviderStaffUpdateWithWhereUniqueWithoutUserGroupInput[]
    updateMany?: ProviderStaffUpdateManyWithWhereWithoutUserGroupInput | ProviderStaffUpdateManyWithWhereWithoutUserGroupInput[]
    deleteMany?: ProviderStaffScalarWhereInput | ProviderStaffScalarWhereInput[]
  }

  export type ContactsCreateNestedManyWithoutStudentUserInput = {
    create?: XOR<ContactsCreateWithoutStudentUserInput, ContactsUncheckedCreateWithoutStudentUserInput> | ContactsCreateWithoutStudentUserInput[] | ContactsUncheckedCreateWithoutStudentUserInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutStudentUserInput | ContactsCreateOrConnectWithoutStudentUserInput[]
    createMany?: ContactsCreateManyStudentUserInputEnvelope
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
  }

  export type PlacementsCreateNestedManyWithoutStudentInput = {
    create?: XOR<PlacementsCreateWithoutStudentInput, PlacementsUncheckedCreateWithoutStudentInput> | PlacementsCreateWithoutStudentInput[] | PlacementsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutStudentInput | PlacementsCreateOrConnectWithoutStudentInput[]
    createMany?: PlacementsCreateManyStudentInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type ContactsUncheckedCreateNestedManyWithoutStudentUserInput = {
    create?: XOR<ContactsCreateWithoutStudentUserInput, ContactsUncheckedCreateWithoutStudentUserInput> | ContactsCreateWithoutStudentUserInput[] | ContactsUncheckedCreateWithoutStudentUserInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutStudentUserInput | ContactsCreateOrConnectWithoutStudentUserInput[]
    createMany?: ContactsCreateManyStudentUserInputEnvelope
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
  }

  export type PlacementsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PlacementsCreateWithoutStudentInput, PlacementsUncheckedCreateWithoutStudentInput> | PlacementsCreateWithoutStudentInput[] | PlacementsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutStudentInput | PlacementsCreateOrConnectWithoutStudentInput[]
    createMany?: PlacementsCreateManyStudentInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type ContactsUpdateManyWithoutStudentUserNestedInput = {
    create?: XOR<ContactsCreateWithoutStudentUserInput, ContactsUncheckedCreateWithoutStudentUserInput> | ContactsCreateWithoutStudentUserInput[] | ContactsUncheckedCreateWithoutStudentUserInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutStudentUserInput | ContactsCreateOrConnectWithoutStudentUserInput[]
    upsert?: ContactsUpsertWithWhereUniqueWithoutStudentUserInput | ContactsUpsertWithWhereUniqueWithoutStudentUserInput[]
    createMany?: ContactsCreateManyStudentUserInputEnvelope
    set?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    disconnect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    delete?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    update?: ContactsUpdateWithWhereUniqueWithoutStudentUserInput | ContactsUpdateWithWhereUniqueWithoutStudentUserInput[]
    updateMany?: ContactsUpdateManyWithWhereWithoutStudentUserInput | ContactsUpdateManyWithWhereWithoutStudentUserInput[]
    deleteMany?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
  }

  export type PlacementsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PlacementsCreateWithoutStudentInput, PlacementsUncheckedCreateWithoutStudentInput> | PlacementsCreateWithoutStudentInput[] | PlacementsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutStudentInput | PlacementsCreateOrConnectWithoutStudentInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutStudentInput | PlacementsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PlacementsCreateManyStudentInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutStudentInput | PlacementsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutStudentInput | PlacementsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type ContactsUncheckedUpdateManyWithoutStudentUserNestedInput = {
    create?: XOR<ContactsCreateWithoutStudentUserInput, ContactsUncheckedCreateWithoutStudentUserInput> | ContactsCreateWithoutStudentUserInput[] | ContactsUncheckedCreateWithoutStudentUserInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutStudentUserInput | ContactsCreateOrConnectWithoutStudentUserInput[]
    upsert?: ContactsUpsertWithWhereUniqueWithoutStudentUserInput | ContactsUpsertWithWhereUniqueWithoutStudentUserInput[]
    createMany?: ContactsCreateManyStudentUserInputEnvelope
    set?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    disconnect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    delete?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    update?: ContactsUpdateWithWhereUniqueWithoutStudentUserInput | ContactsUpdateWithWhereUniqueWithoutStudentUserInput[]
    updateMany?: ContactsUpdateManyWithWhereWithoutStudentUserInput | ContactsUpdateManyWithWhereWithoutStudentUserInput[]
    deleteMany?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
  }

  export type PlacementsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PlacementsCreateWithoutStudentInput, PlacementsUncheckedCreateWithoutStudentInput> | PlacementsCreateWithoutStudentInput[] | PlacementsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutStudentInput | PlacementsCreateOrConnectWithoutStudentInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutStudentInput | PlacementsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PlacementsCreateManyStudentInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutStudentInput | PlacementsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutStudentInput | PlacementsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type InstitutesCreateNestedOneWithoutInstituteStaffInput = {
    create?: XOR<InstitutesCreateWithoutInstituteStaffInput, InstitutesUncheckedCreateWithoutInstituteStaffInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutInstituteStaffInput
    connect?: InstitutesWhereUniqueInput
  }

  export type InstituteStaffUserGroupsCreateNestedOneWithoutInstituteStaffInput = {
    create?: XOR<InstituteStaffUserGroupsCreateWithoutInstituteStaffInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteStaffInput>
    connectOrCreate?: InstituteStaffUserGroupsCreateOrConnectWithoutInstituteStaffInput
    connect?: InstituteStaffUserGroupsWhereUniqueInput
  }

  export type InstitutesUpdateOneRequiredWithoutInstituteStaffNestedInput = {
    create?: XOR<InstitutesCreateWithoutInstituteStaffInput, InstitutesUncheckedCreateWithoutInstituteStaffInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutInstituteStaffInput
    upsert?: InstitutesUpsertWithoutInstituteStaffInput
    connect?: InstitutesWhereUniqueInput
    update?: XOR<XOR<InstitutesUpdateToOneWithWhereWithoutInstituteStaffInput, InstitutesUpdateWithoutInstituteStaffInput>, InstitutesUncheckedUpdateWithoutInstituteStaffInput>
  }

  export type InstituteStaffUserGroupsUpdateOneRequiredWithoutInstituteStaffNestedInput = {
    create?: XOR<InstituteStaffUserGroupsCreateWithoutInstituteStaffInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteStaffInput>
    connectOrCreate?: InstituteStaffUserGroupsCreateOrConnectWithoutInstituteStaffInput
    upsert?: InstituteStaffUserGroupsUpsertWithoutInstituteStaffInput
    connect?: InstituteStaffUserGroupsWhereUniqueInput
    update?: XOR<XOR<InstituteStaffUserGroupsUpdateToOneWithWhereWithoutInstituteStaffInput, InstituteStaffUserGroupsUpdateWithoutInstituteStaffInput>, InstituteStaffUserGroupsUncheckedUpdateWithoutInstituteStaffInput>
  }

  export type InstituteStudentsCreateflagsInput = {
    set: string[]
  }

  export type ContactsCreateNestedManyWithoutInstitutestudentUserInput = {
    create?: XOR<ContactsCreateWithoutInstitutestudentUserInput, ContactsUncheckedCreateWithoutInstitutestudentUserInput> | ContactsCreateWithoutInstitutestudentUserInput[] | ContactsUncheckedCreateWithoutInstitutestudentUserInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutInstitutestudentUserInput | ContactsCreateOrConnectWithoutInstitutestudentUserInput[]
    createMany?: ContactsCreateManyInstitutestudentUserInputEnvelope
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
  }

  export type CohortsCreateNestedOneWithoutInstituteStudentsInput = {
    create?: XOR<CohortsCreateWithoutInstituteStudentsInput, CohortsUncheckedCreateWithoutInstituteStudentsInput>
    connectOrCreate?: CohortsCreateOrConnectWithoutInstituteStudentsInput
    connect?: CohortsWhereUniqueInput
  }

  export type InstitutesCreateNestedOneWithoutInstituteStudentsInput = {
    create?: XOR<InstitutesCreateWithoutInstituteStudentsInput, InstitutesUncheckedCreateWithoutInstituteStudentsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutInstituteStudentsInput
    connect?: InstitutesWhereUniqueInput
  }

  export type InstituteStudentUserGroupsCreateNestedOneWithoutInstituteStudentsInput = {
    create?: XOR<InstituteStudentUserGroupsCreateWithoutInstituteStudentsInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteStudentsInput>
    connectOrCreate?: InstituteStudentUserGroupsCreateOrConnectWithoutInstituteStudentsInput
    connect?: InstituteStudentUserGroupsWhereUniqueInput
  }

  export type PlacementsCreateNestedManyWithoutInstituteStudentInput = {
    create?: XOR<PlacementsCreateWithoutInstituteStudentInput, PlacementsUncheckedCreateWithoutInstituteStudentInput> | PlacementsCreateWithoutInstituteStudentInput[] | PlacementsUncheckedCreateWithoutInstituteStudentInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutInstituteStudentInput | PlacementsCreateOrConnectWithoutInstituteStudentInput[]
    createMany?: PlacementsCreateManyInstituteStudentInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type ContactsUncheckedCreateNestedManyWithoutInstitutestudentUserInput = {
    create?: XOR<ContactsCreateWithoutInstitutestudentUserInput, ContactsUncheckedCreateWithoutInstitutestudentUserInput> | ContactsCreateWithoutInstitutestudentUserInput[] | ContactsUncheckedCreateWithoutInstitutestudentUserInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutInstitutestudentUserInput | ContactsCreateOrConnectWithoutInstitutestudentUserInput[]
    createMany?: ContactsCreateManyInstitutestudentUserInputEnvelope
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
  }

  export type PlacementsUncheckedCreateNestedManyWithoutInstituteStudentInput = {
    create?: XOR<PlacementsCreateWithoutInstituteStudentInput, PlacementsUncheckedCreateWithoutInstituteStudentInput> | PlacementsCreateWithoutInstituteStudentInput[] | PlacementsUncheckedCreateWithoutInstituteStudentInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutInstituteStudentInput | PlacementsCreateOrConnectWithoutInstituteStudentInput[]
    createMany?: PlacementsCreateManyInstituteStudentInputEnvelope
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
  }

  export type InstituteStudentsUpdateflagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContactsUpdateManyWithoutInstitutestudentUserNestedInput = {
    create?: XOR<ContactsCreateWithoutInstitutestudentUserInput, ContactsUncheckedCreateWithoutInstitutestudentUserInput> | ContactsCreateWithoutInstitutestudentUserInput[] | ContactsUncheckedCreateWithoutInstitutestudentUserInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutInstitutestudentUserInput | ContactsCreateOrConnectWithoutInstitutestudentUserInput[]
    upsert?: ContactsUpsertWithWhereUniqueWithoutInstitutestudentUserInput | ContactsUpsertWithWhereUniqueWithoutInstitutestudentUserInput[]
    createMany?: ContactsCreateManyInstitutestudentUserInputEnvelope
    set?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    disconnect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    delete?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    update?: ContactsUpdateWithWhereUniqueWithoutInstitutestudentUserInput | ContactsUpdateWithWhereUniqueWithoutInstitutestudentUserInput[]
    updateMany?: ContactsUpdateManyWithWhereWithoutInstitutestudentUserInput | ContactsUpdateManyWithWhereWithoutInstitutestudentUserInput[]
    deleteMany?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
  }

  export type CohortsUpdateOneRequiredWithoutInstituteStudentsNestedInput = {
    create?: XOR<CohortsCreateWithoutInstituteStudentsInput, CohortsUncheckedCreateWithoutInstituteStudentsInput>
    connectOrCreate?: CohortsCreateOrConnectWithoutInstituteStudentsInput
    upsert?: CohortsUpsertWithoutInstituteStudentsInput
    connect?: CohortsWhereUniqueInput
    update?: XOR<XOR<CohortsUpdateToOneWithWhereWithoutInstituteStudentsInput, CohortsUpdateWithoutInstituteStudentsInput>, CohortsUncheckedUpdateWithoutInstituteStudentsInput>
  }

  export type InstitutesUpdateOneRequiredWithoutInstituteStudentsNestedInput = {
    create?: XOR<InstitutesCreateWithoutInstituteStudentsInput, InstitutesUncheckedCreateWithoutInstituteStudentsInput>
    connectOrCreate?: InstitutesCreateOrConnectWithoutInstituteStudentsInput
    upsert?: InstitutesUpsertWithoutInstituteStudentsInput
    connect?: InstitutesWhereUniqueInput
    update?: XOR<XOR<InstitutesUpdateToOneWithWhereWithoutInstituteStudentsInput, InstitutesUpdateWithoutInstituteStudentsInput>, InstitutesUncheckedUpdateWithoutInstituteStudentsInput>
  }

  export type InstituteStudentUserGroupsUpdateOneRequiredWithoutInstituteStudentsNestedInput = {
    create?: XOR<InstituteStudentUserGroupsCreateWithoutInstituteStudentsInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteStudentsInput>
    connectOrCreate?: InstituteStudentUserGroupsCreateOrConnectWithoutInstituteStudentsInput
    upsert?: InstituteStudentUserGroupsUpsertWithoutInstituteStudentsInput
    connect?: InstituteStudentUserGroupsWhereUniqueInput
    update?: XOR<XOR<InstituteStudentUserGroupsUpdateToOneWithWhereWithoutInstituteStudentsInput, InstituteStudentUserGroupsUpdateWithoutInstituteStudentsInput>, InstituteStudentUserGroupsUncheckedUpdateWithoutInstituteStudentsInput>
  }

  export type PlacementsUpdateManyWithoutInstituteStudentNestedInput = {
    create?: XOR<PlacementsCreateWithoutInstituteStudentInput, PlacementsUncheckedCreateWithoutInstituteStudentInput> | PlacementsCreateWithoutInstituteStudentInput[] | PlacementsUncheckedCreateWithoutInstituteStudentInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutInstituteStudentInput | PlacementsCreateOrConnectWithoutInstituteStudentInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutInstituteStudentInput | PlacementsUpsertWithWhereUniqueWithoutInstituteStudentInput[]
    createMany?: PlacementsCreateManyInstituteStudentInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutInstituteStudentInput | PlacementsUpdateWithWhereUniqueWithoutInstituteStudentInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutInstituteStudentInput | PlacementsUpdateManyWithWhereWithoutInstituteStudentInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type ContactsUncheckedUpdateManyWithoutInstitutestudentUserNestedInput = {
    create?: XOR<ContactsCreateWithoutInstitutestudentUserInput, ContactsUncheckedCreateWithoutInstitutestudentUserInput> | ContactsCreateWithoutInstitutestudentUserInput[] | ContactsUncheckedCreateWithoutInstitutestudentUserInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutInstitutestudentUserInput | ContactsCreateOrConnectWithoutInstitutestudentUserInput[]
    upsert?: ContactsUpsertWithWhereUniqueWithoutInstitutestudentUserInput | ContactsUpsertWithWhereUniqueWithoutInstitutestudentUserInput[]
    createMany?: ContactsCreateManyInstitutestudentUserInputEnvelope
    set?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    disconnect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    delete?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    update?: ContactsUpdateWithWhereUniqueWithoutInstitutestudentUserInput | ContactsUpdateWithWhereUniqueWithoutInstitutestudentUserInput[]
    updateMany?: ContactsUpdateManyWithWhereWithoutInstitutestudentUserInput | ContactsUpdateManyWithWhereWithoutInstitutestudentUserInput[]
    deleteMany?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
  }

  export type PlacementsUncheckedUpdateManyWithoutInstituteStudentNestedInput = {
    create?: XOR<PlacementsCreateWithoutInstituteStudentInput, PlacementsUncheckedCreateWithoutInstituteStudentInput> | PlacementsCreateWithoutInstituteStudentInput[] | PlacementsUncheckedCreateWithoutInstituteStudentInput[]
    connectOrCreate?: PlacementsCreateOrConnectWithoutInstituteStudentInput | PlacementsCreateOrConnectWithoutInstituteStudentInput[]
    upsert?: PlacementsUpsertWithWhereUniqueWithoutInstituteStudentInput | PlacementsUpsertWithWhereUniqueWithoutInstituteStudentInput[]
    createMany?: PlacementsCreateManyInstituteStudentInputEnvelope
    set?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    disconnect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    delete?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    connect?: PlacementsWhereUniqueInput | PlacementsWhereUniqueInput[]
    update?: PlacementsUpdateWithWhereUniqueWithoutInstituteStudentInput | PlacementsUpdateWithWhereUniqueWithoutInstituteStudentInput[]
    updateMany?: PlacementsUpdateManyWithWhereWithoutInstituteStudentInput | PlacementsUpdateManyWithWhereWithoutInstituteStudentInput[]
    deleteMany?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
  }

  export type ProvidersCreateNestedOneWithoutProviderStaffInput = {
    create?: XOR<ProvidersCreateWithoutProviderStaffInput, ProvidersUncheckedCreateWithoutProviderStaffInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutProviderStaffInput
    connect?: ProvidersWhereUniqueInput
  }

  export type ProviderUserGroupsCreateNestedOneWithoutProviderStaffInput = {
    create?: XOR<ProviderUserGroupsCreateWithoutProviderStaffInput, ProviderUserGroupsUncheckedCreateWithoutProviderStaffInput>
    connectOrCreate?: ProviderUserGroupsCreateOrConnectWithoutProviderStaffInput
    connect?: ProviderUserGroupsWhereUniqueInput
  }

  export type ProvidersUpdateOneRequiredWithoutProviderStaffNestedInput = {
    create?: XOR<ProvidersCreateWithoutProviderStaffInput, ProvidersUncheckedCreateWithoutProviderStaffInput>
    connectOrCreate?: ProvidersCreateOrConnectWithoutProviderStaffInput
    upsert?: ProvidersUpsertWithoutProviderStaffInput
    connect?: ProvidersWhereUniqueInput
    update?: XOR<XOR<ProvidersUpdateToOneWithWhereWithoutProviderStaffInput, ProvidersUpdateWithoutProviderStaffInput>, ProvidersUncheckedUpdateWithoutProviderStaffInput>
  }

  export type ProviderUserGroupsUpdateOneRequiredWithoutProviderStaffNestedInput = {
    create?: XOR<ProviderUserGroupsCreateWithoutProviderStaffInput, ProviderUserGroupsUncheckedCreateWithoutProviderStaffInput>
    connectOrCreate?: ProviderUserGroupsCreateOrConnectWithoutProviderStaffInput
    upsert?: ProviderUserGroupsUpsertWithoutProviderStaffInput
    connect?: ProviderUserGroupsWhereUniqueInput
    update?: XOR<XOR<ProviderUserGroupsUpdateToOneWithWhereWithoutProviderStaffInput, ProviderUserGroupsUpdateWithoutProviderStaffInput>, ProviderUserGroupsUncheckedUpdateWithoutProviderStaffInput>
  }

  export type PotentialprovidersCreatetypesInput = {
    set: string[]
  }

  export type PotentialprovidersCreateemailInput = {
    set: string[]
  }

  export type pointOfOriginCreateNestedOneWithoutPotentialprovidersInput = {
    create?: XOR<pointOfOriginCreateWithoutPotentialprovidersInput, pointOfOriginUncheckedCreateWithoutPotentialprovidersInput>
    connectOrCreate?: pointOfOriginCreateOrConnectWithoutPotentialprovidersInput
    connect?: pointOfOriginWhereUniqueInput
  }

  export type PotentialprovidersUpdatetypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PotentialprovidersUpdateemailInput = {
    set?: string[]
    push?: string | string[]
  }

  export type pointOfOriginUpdateOneRequiredWithoutPotentialprovidersNestedInput = {
    create?: XOR<pointOfOriginCreateWithoutPotentialprovidersInput, pointOfOriginUncheckedCreateWithoutPotentialprovidersInput>
    connectOrCreate?: pointOfOriginCreateOrConnectWithoutPotentialprovidersInput
    upsert?: pointOfOriginUpsertWithoutPotentialprovidersInput
    connect?: pointOfOriginWhereUniqueInput
    update?: XOR<XOR<pointOfOriginUpdateToOneWithWhereWithoutPotentialprovidersInput, pointOfOriginUpdateWithoutPotentialprovidersInput>, pointOfOriginUncheckedUpdateWithoutPotentialprovidersInput>
  }

  export type PotentialprovidersCreateNestedManyWithoutPointOfOriginInput = {
    create?: XOR<PotentialprovidersCreateWithoutPointOfOriginInput, PotentialprovidersUncheckedCreateWithoutPointOfOriginInput> | PotentialprovidersCreateWithoutPointOfOriginInput[] | PotentialprovidersUncheckedCreateWithoutPointOfOriginInput[]
    connectOrCreate?: PotentialprovidersCreateOrConnectWithoutPointOfOriginInput | PotentialprovidersCreateOrConnectWithoutPointOfOriginInput[]
    createMany?: PotentialprovidersCreateManyPointOfOriginInputEnvelope
    connect?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
  }

  export type PotentialprovidersUncheckedCreateNestedManyWithoutPointOfOriginInput = {
    create?: XOR<PotentialprovidersCreateWithoutPointOfOriginInput, PotentialprovidersUncheckedCreateWithoutPointOfOriginInput> | PotentialprovidersCreateWithoutPointOfOriginInput[] | PotentialprovidersUncheckedCreateWithoutPointOfOriginInput[]
    connectOrCreate?: PotentialprovidersCreateOrConnectWithoutPointOfOriginInput | PotentialprovidersCreateOrConnectWithoutPointOfOriginInput[]
    createMany?: PotentialprovidersCreateManyPointOfOriginInputEnvelope
    connect?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
  }

  export type PotentialprovidersUpdateManyWithoutPointOfOriginNestedInput = {
    create?: XOR<PotentialprovidersCreateWithoutPointOfOriginInput, PotentialprovidersUncheckedCreateWithoutPointOfOriginInput> | PotentialprovidersCreateWithoutPointOfOriginInput[] | PotentialprovidersUncheckedCreateWithoutPointOfOriginInput[]
    connectOrCreate?: PotentialprovidersCreateOrConnectWithoutPointOfOriginInput | PotentialprovidersCreateOrConnectWithoutPointOfOriginInput[]
    upsert?: PotentialprovidersUpsertWithWhereUniqueWithoutPointOfOriginInput | PotentialprovidersUpsertWithWhereUniqueWithoutPointOfOriginInput[]
    createMany?: PotentialprovidersCreateManyPointOfOriginInputEnvelope
    set?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
    disconnect?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
    delete?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
    connect?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
    update?: PotentialprovidersUpdateWithWhereUniqueWithoutPointOfOriginInput | PotentialprovidersUpdateWithWhereUniqueWithoutPointOfOriginInput[]
    updateMany?: PotentialprovidersUpdateManyWithWhereWithoutPointOfOriginInput | PotentialprovidersUpdateManyWithWhereWithoutPointOfOriginInput[]
    deleteMany?: PotentialprovidersScalarWhereInput | PotentialprovidersScalarWhereInput[]
  }

  export type PotentialprovidersUncheckedUpdateManyWithoutPointOfOriginNestedInput = {
    create?: XOR<PotentialprovidersCreateWithoutPointOfOriginInput, PotentialprovidersUncheckedCreateWithoutPointOfOriginInput> | PotentialprovidersCreateWithoutPointOfOriginInput[] | PotentialprovidersUncheckedCreateWithoutPointOfOriginInput[]
    connectOrCreate?: PotentialprovidersCreateOrConnectWithoutPointOfOriginInput | PotentialprovidersCreateOrConnectWithoutPointOfOriginInput[]
    upsert?: PotentialprovidersUpsertWithWhereUniqueWithoutPointOfOriginInput | PotentialprovidersUpsertWithWhereUniqueWithoutPointOfOriginInput[]
    createMany?: PotentialprovidersCreateManyPointOfOriginInputEnvelope
    set?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
    disconnect?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
    delete?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
    connect?: PotentialprovidersWhereUniqueInput | PotentialprovidersWhereUniqueInput[]
    update?: PotentialprovidersUpdateWithWhereUniqueWithoutPointOfOriginInput | PotentialprovidersUpdateWithWhereUniqueWithoutPointOfOriginInput[]
    updateMany?: PotentialprovidersUpdateManyWithWhereWithoutPointOfOriginInput | PotentialprovidersUpdateManyWithWhereWithoutPointOfOriginInput[]
    deleteMany?: PotentialprovidersScalarWhereInput | PotentialprovidersScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type InstitutesCreateWithoutAddressesInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Cohorts?: CohortsCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateWithoutAddressesInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Cohorts?: CohortsUncheckedCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesCreateOrConnectWithoutAddressesInput = {
    where: InstitutesWhereUniqueInput
    create: XOR<InstitutesCreateWithoutAddressesInput, InstitutesUncheckedCreateWithoutAddressesInput>
  }

  export type ProvidersCreateWithoutAddressesInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    PlacementListings?: PlacementListingsCreateNestedManyWithoutProviderInput
    Placements?: PlacementsCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutProviderInput
  }

  export type ProvidersUncheckedCreateWithoutAddressesInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutProviderInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffUncheckedCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProvidersCreateOrConnectWithoutAddressesInput = {
    where: ProvidersWhereUniqueInput
    create: XOR<ProvidersCreateWithoutAddressesInput, ProvidersUncheckedCreateWithoutAddressesInput>
  }

  export type ContactsCreateWithoutAddressInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstitutestudentUser: InstituteStudentsCreateNestedOneWithoutContactsInput
    studentUser: StudentUsersCreateNestedOneWithoutContactsInput
  }

  export type ContactsUncheckedCreateWithoutAddressInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstituteStudentUserId: string
    studentUserId: string
  }

  export type ContactsCreateOrConnectWithoutAddressInput = {
    where: ContactsWhereUniqueInput
    create: XOR<ContactsCreateWithoutAddressInput, ContactsUncheckedCreateWithoutAddressInput>
  }

  export type ContactsCreateManyAddressInputEnvelope = {
    data: ContactsCreateManyAddressInput | ContactsCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type PlacementListingsCreateWithoutAddressInput = {
    placementListingId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
    provider: ProvidersCreateNestedOneWithoutPlacementListingsInput
  }

  export type PlacementListingsUncheckedCreateWithoutAddressInput = {
    placementListingId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementListingsCreateOrConnectWithoutAddressInput = {
    where: PlacementListingsWhereUniqueInput
    create: XOR<PlacementListingsCreateWithoutAddressInput, PlacementListingsUncheckedCreateWithoutAddressInput>
  }

  export type PlacementListingsCreateManyAddressInputEnvelope = {
    data: PlacementListingsCreateManyAddressInput | PlacementListingsCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type PlacementsCreateWithoutAddressInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    Logs?: LogsCreateNestedManyWithoutPlacementInput
    institute: InstitutesCreateNestedOneWithoutPlacementsInput
    instituteStudent: InstituteStudentsCreateNestedOneWithoutPlacementsInput
    provider: ProvidersCreateNestedOneWithoutPlacementsInput
    student: StudentUsersCreateNestedOneWithoutPlacementsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementsUncheckedCreateWithoutAddressInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    userGroupId: string
    Logs?: LogsUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementsCreateOrConnectWithoutAddressInput = {
    where: PlacementsWhereUniqueInput
    create: XOR<PlacementsCreateWithoutAddressInput, PlacementsUncheckedCreateWithoutAddressInput>
  }

  export type PlacementsCreateManyAddressInputEnvelope = {
    data: PlacementsCreateManyAddressInput | PlacementsCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type ProviderCohortsCreateWithoutAddressInput = {
    cohortId: string
    stage: string
    name: string
    provider: ProvidersCreateNestedOneWithoutProviderCohortsInput
  }

  export type ProviderCohortsUncheckedCreateWithoutAddressInput = {
    cohortId: string
    stage: string
    name: string
    providerId: string
  }

  export type ProviderCohortsCreateOrConnectWithoutAddressInput = {
    where: ProviderCohortsWhereUniqueInput
    create: XOR<ProviderCohortsCreateWithoutAddressInput, ProviderCohortsUncheckedCreateWithoutAddressInput>
  }

  export type ProviderCohortsCreateManyAddressInputEnvelope = {
    data: ProviderCohortsCreateManyAddressInput | ProviderCohortsCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type InstitutesUpsertWithoutAddressesInput = {
    update: XOR<InstitutesUpdateWithoutAddressesInput, InstitutesUncheckedUpdateWithoutAddressesInput>
    create: XOR<InstitutesCreateWithoutAddressesInput, InstitutesUncheckedCreateWithoutAddressesInput>
    where?: InstitutesWhereInput
  }

  export type InstitutesUpdateToOneWithWhereWithoutAddressesInput = {
    where?: InstitutesWhereInput
    data: XOR<InstitutesUpdateWithoutAddressesInput, InstitutesUncheckedUpdateWithoutAddressesInput>
  }

  export type InstitutesUpdateWithoutAddressesInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Cohorts?: CohortsUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateWithoutAddressesInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Cohorts?: CohortsUncheckedUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type ProvidersUpsertWithoutAddressesInput = {
    update: XOR<ProvidersUpdateWithoutAddressesInput, ProvidersUncheckedUpdateWithoutAddressesInput>
    create: XOR<ProvidersCreateWithoutAddressesInput, ProvidersUncheckedCreateWithoutAddressesInput>
    where?: ProvidersWhereInput
  }

  export type ProvidersUpdateToOneWithWhereWithoutAddressesInput = {
    where?: ProvidersWhereInput
    data: XOR<ProvidersUpdateWithoutAddressesInput, ProvidersUncheckedUpdateWithoutAddressesInput>
  }

  export type ProvidersUpdateWithoutAddressesInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    PlacementListings?: PlacementListingsUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutProviderNestedInput
  }

  export type ProvidersUncheckedUpdateWithoutAddressesInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUncheckedUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ContactsUpsertWithWhereUniqueWithoutAddressInput = {
    where: ContactsWhereUniqueInput
    update: XOR<ContactsUpdateWithoutAddressInput, ContactsUncheckedUpdateWithoutAddressInput>
    create: XOR<ContactsCreateWithoutAddressInput, ContactsUncheckedCreateWithoutAddressInput>
  }

  export type ContactsUpdateWithWhereUniqueWithoutAddressInput = {
    where: ContactsWhereUniqueInput
    data: XOR<ContactsUpdateWithoutAddressInput, ContactsUncheckedUpdateWithoutAddressInput>
  }

  export type ContactsUpdateManyWithWhereWithoutAddressInput = {
    where: ContactsScalarWhereInput
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyWithoutAddressInput>
  }

  export type ContactsScalarWhereInput = {
    AND?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
    OR?: ContactsScalarWhereInput[]
    NOT?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
    contactId?: StringFilter<"Contacts"> | string
    contactForename?: StringFilter<"Contacts"> | string
    contactSurname?: StringFilter<"Contacts"> | string
    created?: StringFilter<"Contacts"> | string
    name?: StringFilter<"Contacts"> | string
    providerPhone?: StringFilter<"Contacts"> | string
    InstituteStudentUserId?: StringFilter<"Contacts"> | string
    addressId?: StringFilter<"Contacts"> | string
    studentUserId?: StringFilter<"Contacts"> | string
  }

  export type PlacementListingsUpsertWithWhereUniqueWithoutAddressInput = {
    where: PlacementListingsWhereUniqueInput
    update: XOR<PlacementListingsUpdateWithoutAddressInput, PlacementListingsUncheckedUpdateWithoutAddressInput>
    create: XOR<PlacementListingsCreateWithoutAddressInput, PlacementListingsUncheckedCreateWithoutAddressInput>
  }

  export type PlacementListingsUpdateWithWhereUniqueWithoutAddressInput = {
    where: PlacementListingsWhereUniqueInput
    data: XOR<PlacementListingsUpdateWithoutAddressInput, PlacementListingsUncheckedUpdateWithoutAddressInput>
  }

  export type PlacementListingsUpdateManyWithWhereWithoutAddressInput = {
    where: PlacementListingsScalarWhereInput
    data: XOR<PlacementListingsUpdateManyMutationInput, PlacementListingsUncheckedUpdateManyWithoutAddressInput>
  }

  export type PlacementListingsScalarWhereInput = {
    AND?: PlacementListingsScalarWhereInput | PlacementListingsScalarWhereInput[]
    OR?: PlacementListingsScalarWhereInput[]
    NOT?: PlacementListingsScalarWhereInput | PlacementListingsScalarWhereInput[]
    placementListingId?: StringFilter<"PlacementListings"> | string
    addressId?: StringFilter<"PlacementListings"> | string
    contactForename?: StringFilter<"PlacementListings"> | string
    contactSurname?: StringFilter<"PlacementListings"> | string
    created?: DateTimeFilter<"PlacementListings"> | Date | string
    mapConsent?: BoolFilter<"PlacementListings"> | boolean
    mapConsentDate?: StringFilter<"PlacementListings"> | string
    providerEmail?: StringFilter<"PlacementListings"> | string
    providerId?: StringFilter<"PlacementListings"> | string
    providerPhone?: StringFilter<"PlacementListings"> | string
    savedBy?: JsonFilter<"PlacementListings">
    questions?: JsonFilter<"PlacementListings">
    title?: StringFilter<"PlacementListings"> | string
    uploadedBy?: StringFilter<"PlacementListings"> | string
  }

  export type PlacementsUpsertWithWhereUniqueWithoutAddressInput = {
    where: PlacementsWhereUniqueInput
    update: XOR<PlacementsUpdateWithoutAddressInput, PlacementsUncheckedUpdateWithoutAddressInput>
    create: XOR<PlacementsCreateWithoutAddressInput, PlacementsUncheckedCreateWithoutAddressInput>
  }

  export type PlacementsUpdateWithWhereUniqueWithoutAddressInput = {
    where: PlacementsWhereUniqueInput
    data: XOR<PlacementsUpdateWithoutAddressInput, PlacementsUncheckedUpdateWithoutAddressInput>
  }

  export type PlacementsUpdateManyWithWhereWithoutAddressInput = {
    where: PlacementsScalarWhereInput
    data: XOR<PlacementsUpdateManyMutationInput, PlacementsUncheckedUpdateManyWithoutAddressInput>
  }

  export type PlacementsScalarWhereInput = {
    AND?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
    OR?: PlacementsScalarWhereInput[]
    NOT?: PlacementsScalarWhereInput | PlacementsScalarWhereInput[]
    placementId?: StringFilter<"Placements"> | string
    activeDates?: StringNullableListFilter<"Placements">
    cohortId?: StringFilter<"Placements"> | string
    contactForename?: StringFilter<"Placements"> | string
    contactSurname?: StringFilter<"Placements"> | string
    created?: StringFilter<"Placements"> | string
    draft?: BoolFilter<"Placements"> | boolean
    endDate?: StringFilter<"Placements"> | string
    flags?: StringNullableListFilter<"Placements">
    geoHash?: StringFilter<"Placements"> | string
    inProgress?: BoolFilter<"Placements"> | boolean
    leadTimes?: StringNullableListFilter<"Placements">
    name?: StringFilter<"Placements"> | string
    parentEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    parentExpiry?: StringNullableFilter<"Placements"> | string | null
    parentKey?: StringNullableFilter<"Placements"> | string | null
    product?: StringNullableFilter<"Placements"> | string | null
    providerEmail?: StringNullableFilter<"Placements"> | string | null
    providerEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    providerExpiry?: StringNullableFilter<"Placements"> | string | null
    providerKey?: StringNullableFilter<"Placements"> | string | null
    providerName?: StringNullableFilter<"Placements"> | string | null
    providerPhone?: StringFilter<"Placements"> | string
    nextStatus?: IntNullableFilter<"Placements"> | number | null
    status?: IntFilter<"Placements"> | number
    startDate?: StringFilter<"Placements"> | string
    title?: StringFilter<"Placements"> | string
    forms?: JsonFilter<"Placements">
    questions?: JsonFilter<"Placements">
    uploadedBy?: StringFilter<"Placements"> | string
    addressId?: StringFilter<"Placements"> | string
    instituteId?: StringFilter<"Placements"> | string
    instituteStudentId?: StringFilter<"Placements"> | string
    providerId?: StringFilter<"Placements"> | string
    studentId?: StringFilter<"Placements"> | string
    userGroupId?: StringFilter<"Placements"> | string
  }

  export type ProviderCohortsUpsertWithWhereUniqueWithoutAddressInput = {
    where: ProviderCohortsWhereUniqueInput
    update: XOR<ProviderCohortsUpdateWithoutAddressInput, ProviderCohortsUncheckedUpdateWithoutAddressInput>
    create: XOR<ProviderCohortsCreateWithoutAddressInput, ProviderCohortsUncheckedCreateWithoutAddressInput>
  }

  export type ProviderCohortsUpdateWithWhereUniqueWithoutAddressInput = {
    where: ProviderCohortsWhereUniqueInput
    data: XOR<ProviderCohortsUpdateWithoutAddressInput, ProviderCohortsUncheckedUpdateWithoutAddressInput>
  }

  export type ProviderCohortsUpdateManyWithWhereWithoutAddressInput = {
    where: ProviderCohortsScalarWhereInput
    data: XOR<ProviderCohortsUpdateManyMutationInput, ProviderCohortsUncheckedUpdateManyWithoutAddressInput>
  }

  export type ProviderCohortsScalarWhereInput = {
    AND?: ProviderCohortsScalarWhereInput | ProviderCohortsScalarWhereInput[]
    OR?: ProviderCohortsScalarWhereInput[]
    NOT?: ProviderCohortsScalarWhereInput | ProviderCohortsScalarWhereInput[]
    cohortId?: StringFilter<"ProviderCohorts"> | string
    stage?: StringFilter<"ProviderCohorts"> | string
    name?: StringFilter<"ProviderCohorts"> | string
    addressId?: StringFilter<"ProviderCohorts"> | string
    providerId?: StringFilter<"ProviderCohorts"> | string
  }

  export type InstitutesCreateWithoutCohortsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateWithoutCohortsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesCreateOrConnectWithoutCohortsInput = {
    where: InstitutesWhereUniqueInput
    create: XOR<InstitutesCreateWithoutCohortsInput, InstitutesUncheckedCreateWithoutCohortsInput>
  }

  export type InstituteStudentsCreateWithoutCohortInput = {
    instituteStudentId: string
    activated: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    Contacts?: ContactsCreateNestedManyWithoutInstitutestudentUserInput
    institute: InstitutesCreateNestedOneWithoutInstituteStudentsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutInstituteStudentsInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsUncheckedCreateWithoutCohortInput = {
    instituteStudentId: string
    activated: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
    Contacts?: ContactsUncheckedCreateNestedManyWithoutInstitutestudentUserInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsCreateOrConnectWithoutCohortInput = {
    where: InstituteStudentsWhereUniqueInput
    create: XOR<InstituteStudentsCreateWithoutCohortInput, InstituteStudentsUncheckedCreateWithoutCohortInput>
  }

  export type InstituteStudentsCreateManyCohortInputEnvelope = {
    data: InstituteStudentsCreateManyCohortInput | InstituteStudentsCreateManyCohortInput[]
    skipDuplicates?: boolean
  }

  export type InstitutesUpsertWithoutCohortsInput = {
    update: XOR<InstitutesUpdateWithoutCohortsInput, InstitutesUncheckedUpdateWithoutCohortsInput>
    create: XOR<InstitutesCreateWithoutCohortsInput, InstitutesUncheckedCreateWithoutCohortsInput>
    where?: InstitutesWhereInput
  }

  export type InstitutesUpdateToOneWithWhereWithoutCohortsInput = {
    where?: InstitutesWhereInput
    data: XOR<InstitutesUpdateWithoutCohortsInput, InstitutesUncheckedUpdateWithoutCohortsInput>
  }

  export type InstitutesUpdateWithoutCohortsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateWithoutCohortsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type InstituteStudentsUpsertWithWhereUniqueWithoutCohortInput = {
    where: InstituteStudentsWhereUniqueInput
    update: XOR<InstituteStudentsUpdateWithoutCohortInput, InstituteStudentsUncheckedUpdateWithoutCohortInput>
    create: XOR<InstituteStudentsCreateWithoutCohortInput, InstituteStudentsUncheckedCreateWithoutCohortInput>
  }

  export type InstituteStudentsUpdateWithWhereUniqueWithoutCohortInput = {
    where: InstituteStudentsWhereUniqueInput
    data: XOR<InstituteStudentsUpdateWithoutCohortInput, InstituteStudentsUncheckedUpdateWithoutCohortInput>
  }

  export type InstituteStudentsUpdateManyWithWhereWithoutCohortInput = {
    where: InstituteStudentsScalarWhereInput
    data: XOR<InstituteStudentsUpdateManyMutationInput, InstituteStudentsUncheckedUpdateManyWithoutCohortInput>
  }

  export type InstituteStudentsScalarWhereInput = {
    AND?: InstituteStudentsScalarWhereInput | InstituteStudentsScalarWhereInput[]
    OR?: InstituteStudentsScalarWhereInput[]
    NOT?: InstituteStudentsScalarWhereInput | InstituteStudentsScalarWhereInput[]
    instituteStudentId?: StringFilter<"InstituteStudents"> | string
    activated?: StringFilter<"InstituteStudents"> | string
    created?: StringFilter<"InstituteStudents"> | string
    cohortId?: StringFilter<"InstituteStudents"> | string
    details?: JsonFilter<"InstituteStudents">
    email?: StringFilter<"InstituteStudents"> | string
    flags?: StringNullableListFilter<"InstituteStudents">
    oId?: StringFilter<"InstituteStudents"> | string
    resetExpiry?: DateTimeFilter<"InstituteStudents"> | Date | string
    status?: StringFilter<"InstituteStudents"> | string
    userType?: StringFilter<"InstituteStudents"> | string
    instituteId?: StringFilter<"InstituteStudents"> | string
    userGroupId?: StringFilter<"InstituteStudents"> | string
  }

  export type AddressesCreateWithoutProviderCohortsInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    institute?: InstitutesCreateNestedOneWithoutAddressesInput
    provider?: ProvidersCreateNestedOneWithoutAddressesInput
    Contacts?: ContactsCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutAddressInput
    Placements?: PlacementsCreateNestedManyWithoutAddressInput
  }

  export type AddressesUncheckedCreateWithoutProviderCohortsInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    instituteId?: string | null
    providerId?: string | null
    Contacts?: ContactsUncheckedCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutAddressInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressesCreateOrConnectWithoutProviderCohortsInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutProviderCohortsInput, AddressesUncheckedCreateWithoutProviderCohortsInput>
  }

  export type ProvidersCreateWithoutProviderCohortsInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutProviderInput
    Placements?: PlacementsCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsCreateNestedManyWithoutProviderInput
  }

  export type ProvidersUncheckedCreateWithoutProviderCohortsInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesUncheckedCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutProviderInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffUncheckedCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProvidersCreateOrConnectWithoutProviderCohortsInput = {
    where: ProvidersWhereUniqueInput
    create: XOR<ProvidersCreateWithoutProviderCohortsInput, ProvidersUncheckedCreateWithoutProviderCohortsInput>
  }

  export type AddressesUpsertWithoutProviderCohortsInput = {
    update: XOR<AddressesUpdateWithoutProviderCohortsInput, AddressesUncheckedUpdateWithoutProviderCohortsInput>
    create: XOR<AddressesCreateWithoutProviderCohortsInput, AddressesUncheckedCreateWithoutProviderCohortsInput>
    where?: AddressesWhereInput
  }

  export type AddressesUpdateToOneWithWhereWithoutProviderCohortsInput = {
    where?: AddressesWhereInput
    data: XOR<AddressesUpdateWithoutProviderCohortsInput, AddressesUncheckedUpdateWithoutProviderCohortsInput>
  }

  export type AddressesUpdateWithoutProviderCohortsInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    institute?: InstitutesUpdateOneWithoutAddressesNestedInput
    provider?: ProvidersUpdateOneWithoutAddressesNestedInput
    Contacts?: ContactsUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutProviderCohortsInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    Contacts?: ContactsUncheckedUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type ProvidersUpsertWithoutProviderCohortsInput = {
    update: XOR<ProvidersUpdateWithoutProviderCohortsInput, ProvidersUncheckedUpdateWithoutProviderCohortsInput>
    create: XOR<ProvidersCreateWithoutProviderCohortsInput, ProvidersUncheckedCreateWithoutProviderCohortsInput>
    where?: ProvidersWhereInput
  }

  export type ProvidersUpdateToOneWithWhereWithoutProviderCohortsInput = {
    where?: ProvidersWhereInput
    data: XOR<ProvidersUpdateWithoutProviderCohortsInput, ProvidersUncheckedUpdateWithoutProviderCohortsInput>
  }

  export type ProvidersUpdateWithoutProviderCohortsInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUpdateManyWithoutProviderNestedInput
  }

  export type ProvidersUncheckedUpdateWithoutProviderCohortsInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUncheckedUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUncheckedUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type InstituteStudentsCreateWithoutContactsInput = {
    instituteStudentId: string
    activated: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    cohort: CohortsCreateNestedOneWithoutInstituteStudentsInput
    institute: InstitutesCreateNestedOneWithoutInstituteStudentsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutInstituteStudentsInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsUncheckedCreateWithoutContactsInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsCreateOrConnectWithoutContactsInput = {
    where: InstituteStudentsWhereUniqueInput
    create: XOR<InstituteStudentsCreateWithoutContactsInput, InstituteStudentsUncheckedCreateWithoutContactsInput>
  }

  export type AddressesCreateWithoutContactsInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    institute?: InstitutesCreateNestedOneWithoutAddressesInput
    provider?: ProvidersCreateNestedOneWithoutAddressesInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutAddressInput
    Placements?: PlacementsCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutAddressInput
  }

  export type AddressesUncheckedCreateWithoutContactsInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    instituteId?: string | null
    providerId?: string | null
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutAddressInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressesCreateOrConnectWithoutContactsInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutContactsInput, AddressesUncheckedCreateWithoutContactsInput>
  }

  export type StudentUsersCreateWithoutContactsInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
    Placements?: PlacementsCreateNestedManyWithoutStudentInput
  }

  export type StudentUsersUncheckedCreateWithoutContactsInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
    Placements?: PlacementsUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUsersCreateOrConnectWithoutContactsInput = {
    where: StudentUsersWhereUniqueInput
    create: XOR<StudentUsersCreateWithoutContactsInput, StudentUsersUncheckedCreateWithoutContactsInput>
  }

  export type InstituteStudentsUpsertWithoutContactsInput = {
    update: XOR<InstituteStudentsUpdateWithoutContactsInput, InstituteStudentsUncheckedUpdateWithoutContactsInput>
    create: XOR<InstituteStudentsCreateWithoutContactsInput, InstituteStudentsUncheckedCreateWithoutContactsInput>
    where?: InstituteStudentsWhereInput
  }

  export type InstituteStudentsUpdateToOneWithWhereWithoutContactsInput = {
    where?: InstituteStudentsWhereInput
    data: XOR<InstituteStudentsUpdateWithoutContactsInput, InstituteStudentsUncheckedUpdateWithoutContactsInput>
  }

  export type InstituteStudentsUpdateWithoutContactsInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    cohort?: CohortsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutInstituteStudentsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsUncheckedUpdateWithoutContactsInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteStudentNestedInput
  }

  export type AddressesUpsertWithoutContactsInput = {
    update: XOR<AddressesUpdateWithoutContactsInput, AddressesUncheckedUpdateWithoutContactsInput>
    create: XOR<AddressesCreateWithoutContactsInput, AddressesUncheckedCreateWithoutContactsInput>
    where?: AddressesWhereInput
  }

  export type AddressesUpdateToOneWithWhereWithoutContactsInput = {
    where?: AddressesWhereInput
    data: XOR<AddressesUpdateWithoutContactsInput, AddressesUncheckedUpdateWithoutContactsInput>
  }

  export type AddressesUpdateWithoutContactsInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    institute?: InstitutesUpdateOneWithoutAddressesNestedInput
    provider?: ProvidersUpdateOneWithoutAddressesNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutContactsInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type StudentUsersUpsertWithoutContactsInput = {
    update: XOR<StudentUsersUpdateWithoutContactsInput, StudentUsersUncheckedUpdateWithoutContactsInput>
    create: XOR<StudentUsersCreateWithoutContactsInput, StudentUsersUncheckedCreateWithoutContactsInput>
    where?: StudentUsersWhereInput
  }

  export type StudentUsersUpdateToOneWithWhereWithoutContactsInput = {
    where?: StudentUsersWhereInput
    data: XOR<StudentUsersUpdateWithoutContactsInput, StudentUsersUncheckedUpdateWithoutContactsInput>
  }

  export type StudentUsersUpdateWithoutContactsInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Placements?: PlacementsUpdateManyWithoutStudentNestedInput
  }

  export type StudentUsersUncheckedUpdateWithoutContactsInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Placements?: PlacementsUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type InstitutesCreateWithoutFormsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateWithoutFormsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesCreateOrConnectWithoutFormsInput = {
    where: InstitutesWhereUniqueInput
    create: XOR<InstitutesCreateWithoutFormsInput, InstitutesUncheckedCreateWithoutFormsInput>
  }

  export type InstitutesUpsertWithoutFormsInput = {
    update: XOR<InstitutesUpdateWithoutFormsInput, InstitutesUncheckedUpdateWithoutFormsInput>
    create: XOR<InstitutesCreateWithoutFormsInput, InstitutesUncheckedCreateWithoutFormsInput>
    where?: InstitutesWhereInput
  }

  export type InstitutesUpdateToOneWithWhereWithoutFormsInput = {
    where?: InstitutesWhereInput
    data: XOR<InstitutesUpdateWithoutFormsInput, InstitutesUncheckedUpdateWithoutFormsInput>
  }

  export type InstitutesUpdateWithoutFormsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateWithoutFormsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type AddressesCreateWithoutInstituteInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    provider?: ProvidersCreateNestedOneWithoutAddressesInput
    Contacts?: ContactsCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutAddressInput
    Placements?: PlacementsCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutAddressInput
  }

  export type AddressesUncheckedCreateWithoutInstituteInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    providerId?: string | null
    Contacts?: ContactsUncheckedCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutAddressInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressesCreateOrConnectWithoutInstituteInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutInstituteInput, AddressesUncheckedCreateWithoutInstituteInput>
  }

  export type AddressesCreateManyInstituteInputEnvelope = {
    data: AddressesCreateManyInstituteInput | AddressesCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type CohortsCreateWithoutInstituteInput = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutCohortInput
  }

  export type CohortsUncheckedCreateWithoutInstituteInput = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutCohortInput
  }

  export type CohortsCreateOrConnectWithoutInstituteInput = {
    where: CohortsWhereUniqueInput
    create: XOR<CohortsCreateWithoutInstituteInput, CohortsUncheckedCreateWithoutInstituteInput>
  }

  export type CohortsCreateManyInstituteInputEnvelope = {
    data: CohortsCreateManyInstituteInput | CohortsCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type InstituteFormsCreateWithoutInstituteInput = {
    formId: string
    form: JsonNullValueInput | InputJsonValue
    updated: string
  }

  export type InstituteFormsUncheckedCreateWithoutInstituteInput = {
    formId: string
    form: JsonNullValueInput | InputJsonValue
    updated: string
  }

  export type InstituteFormsCreateOrConnectWithoutInstituteInput = {
    where: InstituteFormsWhereUniqueInput
    create: XOR<InstituteFormsCreateWithoutInstituteInput, InstituteFormsUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteFormsCreateManyInstituteInputEnvelope = {
    data: InstituteFormsCreateManyInstituteInput | InstituteFormsCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type InstituteStaffCreateWithoutInstituteInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    userGroup: InstituteStaffUserGroupsCreateNestedOneWithoutInstituteStaffInput
  }

  export type InstituteStaffUncheckedCreateWithoutInstituteInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    userGroupId: string
  }

  export type InstituteStaffCreateOrConnectWithoutInstituteInput = {
    where: InstituteStaffWhereUniqueInput
    create: XOR<InstituteStaffCreateWithoutInstituteInput, InstituteStaffUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteStaffCreateManyInstituteInputEnvelope = {
    data: InstituteStaffCreateManyInstituteInput | InstituteStaffCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type InstituteStaffUserGroupsCreateWithoutInstituteInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStaffUserGroupsCreateOrConnectWithoutInstituteInput = {
    where: InstituteStaffUserGroupsWhereUniqueInput
    create: XOR<InstituteStaffUserGroupsCreateWithoutInstituteInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteStaffUserGroupsCreateManyInstituteInputEnvelope = {
    data: InstituteStaffUserGroupsCreateManyInstituteInput | InstituteStaffUserGroupsCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type InstituteStudentUserGroupsCreateWithoutInstituteInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutUserGroupInput
    Placements?: PlacementsCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutUserGroupInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStudentUserGroupsCreateOrConnectWithoutInstituteInput = {
    where: InstituteStudentUserGroupsWhereUniqueInput
    create: XOR<InstituteStudentUserGroupsCreateWithoutInstituteInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteStudentUserGroupsCreateManyInstituteInputEnvelope = {
    data: InstituteStudentUserGroupsCreateManyInstituteInput | InstituteStudentUserGroupsCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type InstituteStudentsCreateWithoutInstituteInput = {
    instituteStudentId: string
    activated: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    Contacts?: ContactsCreateNestedManyWithoutInstitutestudentUserInput
    cohort: CohortsCreateNestedOneWithoutInstituteStudentsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutInstituteStudentsInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsUncheckedCreateWithoutInstituteInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    userGroupId: string
    Contacts?: ContactsUncheckedCreateNestedManyWithoutInstitutestudentUserInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsCreateOrConnectWithoutInstituteInput = {
    where: InstituteStudentsWhereUniqueInput
    create: XOR<InstituteStudentsCreateWithoutInstituteInput, InstituteStudentsUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteStudentsCreateManyInstituteInputEnvelope = {
    data: InstituteStudentsCreateManyInstituteInput | InstituteStudentsCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type PlacementsCreateWithoutInstituteInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    Logs?: LogsCreateNestedManyWithoutPlacementInput
    address: AddressesCreateNestedOneWithoutPlacementsInput
    instituteStudent: InstituteStudentsCreateNestedOneWithoutPlacementsInput
    provider: ProvidersCreateNestedOneWithoutPlacementsInput
    student: StudentUsersCreateNestedOneWithoutPlacementsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementsUncheckedCreateWithoutInstituteInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    userGroupId: string
    Logs?: LogsUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementsCreateOrConnectWithoutInstituteInput = {
    where: PlacementsWhereUniqueInput
    create: XOR<PlacementsCreateWithoutInstituteInput, PlacementsUncheckedCreateWithoutInstituteInput>
  }

  export type PlacementsCreateManyInstituteInputEnvelope = {
    data: PlacementsCreateManyInstituteInput | PlacementsCreateManyInstituteInput[]
    skipDuplicates?: boolean
  }

  export type AddressesUpsertWithWhereUniqueWithoutInstituteInput = {
    where: AddressesWhereUniqueInput
    update: XOR<AddressesUpdateWithoutInstituteInput, AddressesUncheckedUpdateWithoutInstituteInput>
    create: XOR<AddressesCreateWithoutInstituteInput, AddressesUncheckedCreateWithoutInstituteInput>
  }

  export type AddressesUpdateWithWhereUniqueWithoutInstituteInput = {
    where: AddressesWhereUniqueInput
    data: XOR<AddressesUpdateWithoutInstituteInput, AddressesUncheckedUpdateWithoutInstituteInput>
  }

  export type AddressesUpdateManyWithWhereWithoutInstituteInput = {
    where: AddressesScalarWhereInput
    data: XOR<AddressesUpdateManyMutationInput, AddressesUncheckedUpdateManyWithoutInstituteInput>
  }

  export type AddressesScalarWhereInput = {
    AND?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
    OR?: AddressesScalarWhereInput[]
    NOT?: AddressesScalarWhereInput | AddressesScalarWhereInput[]
    addressId?: StringFilter<"Addresses"> | string
    name?: StringFilter<"Addresses"> | string
    stage?: StringNullableFilter<"Addresses"> | string | null
    addressLine1?: StringNullableFilter<"Addresses"> | string | null
    addressLine2?: StringNullableFilter<"Addresses"> | string | null
    contactForename?: StringNullableFilter<"Addresses"> | string | null
    contactSurname?: StringNullableFilter<"Addresses"> | string | null
    country?: StringNullableFilter<"Addresses"> | string | null
    email?: StringNullableFilter<"Addresses"> | string | null
    geoHash?: StringNullableFilter<"Addresses"> | string | null
    locality?: StringNullableFilter<"Addresses"> | string | null
    phone?: StringNullableFilter<"Addresses"> | string | null
    postal_code?: StringNullableFilter<"Addresses"> | string | null
    instituteId?: StringNullableFilter<"Addresses"> | string | null
    providerId?: StringNullableFilter<"Addresses"> | string | null
  }

  export type CohortsUpsertWithWhereUniqueWithoutInstituteInput = {
    where: CohortsWhereUniqueInput
    update: XOR<CohortsUpdateWithoutInstituteInput, CohortsUncheckedUpdateWithoutInstituteInput>
    create: XOR<CohortsCreateWithoutInstituteInput, CohortsUncheckedCreateWithoutInstituteInput>
  }

  export type CohortsUpdateWithWhereUniqueWithoutInstituteInput = {
    where: CohortsWhereUniqueInput
    data: XOR<CohortsUpdateWithoutInstituteInput, CohortsUncheckedUpdateWithoutInstituteInput>
  }

  export type CohortsUpdateManyWithWhereWithoutInstituteInput = {
    where: CohortsScalarWhereInput
    data: XOR<CohortsUpdateManyMutationInput, CohortsUncheckedUpdateManyWithoutInstituteInput>
  }

  export type CohortsScalarWhereInput = {
    AND?: CohortsScalarWhereInput | CohortsScalarWhereInput[]
    OR?: CohortsScalarWhereInput[]
    NOT?: CohortsScalarWhereInput | CohortsScalarWhereInput[]
    cohortId?: StringFilter<"Cohorts"> | string
    designatedStaff?: StringFilter<"Cohorts"> | string
    stage?: StringFilter<"Cohorts"> | string
    placementType?: StringFilter<"Cohorts"> | string
    name?: StringFilter<"Cohorts"> | string
    startPlacements?: StringFilter<"Cohorts"> | string
    endPlacements?: StringFilter<"Cohorts"> | string
    startSubmission?: StringFilter<"Cohorts"> | string
    endSubmission?: StringFilter<"Cohorts"> | string
    includedFiles?: StringNullableListFilter<"Cohorts">
    includedForms?: StringNullableListFilter<"Cohorts">
    workflow?: StringFilter<"Cohorts"> | string
    instituteId?: StringFilter<"Cohorts"> | string
  }

  export type InstituteFormsUpsertWithWhereUniqueWithoutInstituteInput = {
    where: InstituteFormsWhereUniqueInput
    update: XOR<InstituteFormsUpdateWithoutInstituteInput, InstituteFormsUncheckedUpdateWithoutInstituteInput>
    create: XOR<InstituteFormsCreateWithoutInstituteInput, InstituteFormsUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteFormsUpdateWithWhereUniqueWithoutInstituteInput = {
    where: InstituteFormsWhereUniqueInput
    data: XOR<InstituteFormsUpdateWithoutInstituteInput, InstituteFormsUncheckedUpdateWithoutInstituteInput>
  }

  export type InstituteFormsUpdateManyWithWhereWithoutInstituteInput = {
    where: InstituteFormsScalarWhereInput
    data: XOR<InstituteFormsUpdateManyMutationInput, InstituteFormsUncheckedUpdateManyWithoutInstituteInput>
  }

  export type InstituteFormsScalarWhereInput = {
    AND?: InstituteFormsScalarWhereInput | InstituteFormsScalarWhereInput[]
    OR?: InstituteFormsScalarWhereInput[]
    NOT?: InstituteFormsScalarWhereInput | InstituteFormsScalarWhereInput[]
    formId?: StringFilter<"InstituteForms"> | string
    form?: JsonFilter<"InstituteForms">
    updated?: StringFilter<"InstituteForms"> | string
    instituteId?: StringFilter<"InstituteForms"> | string
  }

  export type InstituteStaffUpsertWithWhereUniqueWithoutInstituteInput = {
    where: InstituteStaffWhereUniqueInput
    update: XOR<InstituteStaffUpdateWithoutInstituteInput, InstituteStaffUncheckedUpdateWithoutInstituteInput>
    create: XOR<InstituteStaffCreateWithoutInstituteInput, InstituteStaffUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteStaffUpdateWithWhereUniqueWithoutInstituteInput = {
    where: InstituteStaffWhereUniqueInput
    data: XOR<InstituteStaffUpdateWithoutInstituteInput, InstituteStaffUncheckedUpdateWithoutInstituteInput>
  }

  export type InstituteStaffUpdateManyWithWhereWithoutInstituteInput = {
    where: InstituteStaffScalarWhereInput
    data: XOR<InstituteStaffUpdateManyMutationInput, InstituteStaffUncheckedUpdateManyWithoutInstituteInput>
  }

  export type InstituteStaffScalarWhereInput = {
    AND?: InstituteStaffScalarWhereInput | InstituteStaffScalarWhereInput[]
    OR?: InstituteStaffScalarWhereInput[]
    NOT?: InstituteStaffScalarWhereInput | InstituteStaffScalarWhereInput[]
    instituteStaffId?: StringFilter<"InstituteStaff"> | string
    created?: StringFilter<"InstituteStaff"> | string
    details?: JsonFilter<"InstituteStaff">
    email?: StringFilter<"InstituteStaff"> | string
    oId?: StringFilter<"InstituteStaff"> | string
    status?: StringFilter<"InstituteStaff"> | string
    userType?: StringFilter<"InstituteStaff"> | string
    instituteId?: StringFilter<"InstituteStaff"> | string
    userGroupId?: StringFilter<"InstituteStaff"> | string
  }

  export type InstituteStaffUserGroupsUpsertWithWhereUniqueWithoutInstituteInput = {
    where: InstituteStaffUserGroupsWhereUniqueInput
    update: XOR<InstituteStaffUserGroupsUpdateWithoutInstituteInput, InstituteStaffUserGroupsUncheckedUpdateWithoutInstituteInput>
    create: XOR<InstituteStaffUserGroupsCreateWithoutInstituteInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteStaffUserGroupsUpdateWithWhereUniqueWithoutInstituteInput = {
    where: InstituteStaffUserGroupsWhereUniqueInput
    data: XOR<InstituteStaffUserGroupsUpdateWithoutInstituteInput, InstituteStaffUserGroupsUncheckedUpdateWithoutInstituteInput>
  }

  export type InstituteStaffUserGroupsUpdateManyWithWhereWithoutInstituteInput = {
    where: InstituteStaffUserGroupsScalarWhereInput
    data: XOR<InstituteStaffUserGroupsUpdateManyMutationInput, InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteInput>
  }

  export type InstituteStaffUserGroupsScalarWhereInput = {
    AND?: InstituteStaffUserGroupsScalarWhereInput | InstituteStaffUserGroupsScalarWhereInput[]
    OR?: InstituteStaffUserGroupsScalarWhereInput[]
    NOT?: InstituteStaffUserGroupsScalarWhereInput | InstituteStaffUserGroupsScalarWhereInput[]
    userGroupId?: StringFilter<"InstituteStaffUserGroups"> | string
    default?: BoolFilter<"InstituteStaffUserGroups"> | boolean
    name?: StringFilter<"InstituteStaffUserGroups"> | string
    updated?: StringFilter<"InstituteStaffUserGroups"> | string
    instituteId?: StringFilter<"InstituteStaffUserGroups"> | string
  }

  export type InstituteStudentUserGroupsUpsertWithWhereUniqueWithoutInstituteInput = {
    where: InstituteStudentUserGroupsWhereUniqueInput
    update: XOR<InstituteStudentUserGroupsUpdateWithoutInstituteInput, InstituteStudentUserGroupsUncheckedUpdateWithoutInstituteInput>
    create: XOR<InstituteStudentUserGroupsCreateWithoutInstituteInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteStudentUserGroupsUpdateWithWhereUniqueWithoutInstituteInput = {
    where: InstituteStudentUserGroupsWhereUniqueInput
    data: XOR<InstituteStudentUserGroupsUpdateWithoutInstituteInput, InstituteStudentUserGroupsUncheckedUpdateWithoutInstituteInput>
  }

  export type InstituteStudentUserGroupsUpdateManyWithWhereWithoutInstituteInput = {
    where: InstituteStudentUserGroupsScalarWhereInput
    data: XOR<InstituteStudentUserGroupsUpdateManyMutationInput, InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteInput>
  }

  export type InstituteStudentUserGroupsScalarWhereInput = {
    AND?: InstituteStudentUserGroupsScalarWhereInput | InstituteStudentUserGroupsScalarWhereInput[]
    OR?: InstituteStudentUserGroupsScalarWhereInput[]
    NOT?: InstituteStudentUserGroupsScalarWhereInput | InstituteStudentUserGroupsScalarWhereInput[]
    userGroupId?: StringFilter<"InstituteStudentUserGroups"> | string
    default?: BoolFilter<"InstituteStudentUserGroups"> | boolean
    name?: StringFilter<"InstituteStudentUserGroups"> | string
    updated?: StringFilter<"InstituteStudentUserGroups"> | string
    instituteId?: StringFilter<"InstituteStudentUserGroups"> | string
  }

  export type InstituteStudentsUpsertWithWhereUniqueWithoutInstituteInput = {
    where: InstituteStudentsWhereUniqueInput
    update: XOR<InstituteStudentsUpdateWithoutInstituteInput, InstituteStudentsUncheckedUpdateWithoutInstituteInput>
    create: XOR<InstituteStudentsCreateWithoutInstituteInput, InstituteStudentsUncheckedCreateWithoutInstituteInput>
  }

  export type InstituteStudentsUpdateWithWhereUniqueWithoutInstituteInput = {
    where: InstituteStudentsWhereUniqueInput
    data: XOR<InstituteStudentsUpdateWithoutInstituteInput, InstituteStudentsUncheckedUpdateWithoutInstituteInput>
  }

  export type InstituteStudentsUpdateManyWithWhereWithoutInstituteInput = {
    where: InstituteStudentsScalarWhereInput
    data: XOR<InstituteStudentsUpdateManyMutationInput, InstituteStudentsUncheckedUpdateManyWithoutInstituteInput>
  }

  export type PlacementsUpsertWithWhereUniqueWithoutInstituteInput = {
    where: PlacementsWhereUniqueInput
    update: XOR<PlacementsUpdateWithoutInstituteInput, PlacementsUncheckedUpdateWithoutInstituteInput>
    create: XOR<PlacementsCreateWithoutInstituteInput, PlacementsUncheckedCreateWithoutInstituteInput>
  }

  export type PlacementsUpdateWithWhereUniqueWithoutInstituteInput = {
    where: PlacementsWhereUniqueInput
    data: XOR<PlacementsUpdateWithoutInstituteInput, PlacementsUncheckedUpdateWithoutInstituteInput>
  }

  export type PlacementsUpdateManyWithWhereWithoutInstituteInput = {
    where: PlacementsScalarWhereInput
    data: XOR<PlacementsUpdateManyMutationInput, PlacementsUncheckedUpdateManyWithoutInstituteInput>
  }

  export type PlacementsCreateWithoutLogsInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    address: AddressesCreateNestedOneWithoutPlacementsInput
    institute: InstitutesCreateNestedOneWithoutPlacementsInput
    instituteStudent: InstituteStudentsCreateNestedOneWithoutPlacementsInput
    provider: ProvidersCreateNestedOneWithoutPlacementsInput
    student: StudentUsersCreateNestedOneWithoutPlacementsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementsUncheckedCreateWithoutLogsInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    userGroupId: string
  }

  export type PlacementsCreateOrConnectWithoutLogsInput = {
    where: PlacementsWhereUniqueInput
    create: XOR<PlacementsCreateWithoutLogsInput, PlacementsUncheckedCreateWithoutLogsInput>
  }

  export type PlacementsUpsertWithoutLogsInput = {
    update: XOR<PlacementsUpdateWithoutLogsInput, PlacementsUncheckedUpdateWithoutLogsInput>
    create: XOR<PlacementsCreateWithoutLogsInput, PlacementsUncheckedCreateWithoutLogsInput>
    where?: PlacementsWhereInput
  }

  export type PlacementsUpdateToOneWithWhereWithoutLogsInput = {
    where?: PlacementsWhereInput
    data: XOR<PlacementsUpdateWithoutLogsInput, PlacementsUncheckedUpdateWithoutLogsInput>
  }

  export type PlacementsUpdateWithoutLogsInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    address?: AddressesUpdateOneRequiredWithoutPlacementsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutPlacementsNestedInput
    instituteStudent?: InstituteStudentsUpdateOneRequiredWithoutPlacementsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutPlacementsNestedInput
    student?: StudentUsersUpdateOneRequiredWithoutPlacementsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementsUncheckedUpdateWithoutLogsInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressesCreateWithoutPlacementListingsInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    institute?: InstitutesCreateNestedOneWithoutAddressesInput
    provider?: ProvidersCreateNestedOneWithoutAddressesInput
    Contacts?: ContactsCreateNestedManyWithoutAddressInput
    Placements?: PlacementsCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutAddressInput
  }

  export type AddressesUncheckedCreateWithoutPlacementListingsInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    instituteId?: string | null
    providerId?: string | null
    Contacts?: ContactsUncheckedCreateNestedManyWithoutAddressInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressesCreateOrConnectWithoutPlacementListingsInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutPlacementListingsInput, AddressesUncheckedCreateWithoutPlacementListingsInput>
  }

  export type ProvidersCreateWithoutPlacementListingsInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesCreateNestedManyWithoutProviderInput
    Placements?: PlacementsCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutProviderInput
  }

  export type ProvidersUncheckedCreateWithoutPlacementListingsInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesUncheckedCreateNestedManyWithoutProviderInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffUncheckedCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProvidersCreateOrConnectWithoutPlacementListingsInput = {
    where: ProvidersWhereUniqueInput
    create: XOR<ProvidersCreateWithoutPlacementListingsInput, ProvidersUncheckedCreateWithoutPlacementListingsInput>
  }

  export type AddressesUpsertWithoutPlacementListingsInput = {
    update: XOR<AddressesUpdateWithoutPlacementListingsInput, AddressesUncheckedUpdateWithoutPlacementListingsInput>
    create: XOR<AddressesCreateWithoutPlacementListingsInput, AddressesUncheckedCreateWithoutPlacementListingsInput>
    where?: AddressesWhereInput
  }

  export type AddressesUpdateToOneWithWhereWithoutPlacementListingsInput = {
    where?: AddressesWhereInput
    data: XOR<AddressesUpdateWithoutPlacementListingsInput, AddressesUncheckedUpdateWithoutPlacementListingsInput>
  }

  export type AddressesUpdateWithoutPlacementListingsInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    institute?: InstitutesUpdateOneWithoutAddressesNestedInput
    provider?: ProvidersUpdateOneWithoutAddressesNestedInput
    Contacts?: ContactsUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutPlacementListingsInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    Contacts?: ContactsUncheckedUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type ProvidersUpsertWithoutPlacementListingsInput = {
    update: XOR<ProvidersUpdateWithoutPlacementListingsInput, ProvidersUncheckedUpdateWithoutPlacementListingsInput>
    create: XOR<ProvidersCreateWithoutPlacementListingsInput, ProvidersUncheckedCreateWithoutPlacementListingsInput>
    where?: ProvidersWhereInput
  }

  export type ProvidersUpdateToOneWithWhereWithoutPlacementListingsInput = {
    where?: ProvidersWhereInput
    data: XOR<ProvidersUpdateWithoutPlacementListingsInput, ProvidersUncheckedUpdateWithoutPlacementListingsInput>
  }

  export type ProvidersUpdateWithoutPlacementListingsInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutProviderNestedInput
  }

  export type ProvidersUncheckedUpdateWithoutPlacementListingsInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUncheckedUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUncheckedUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type LogsCreateWithoutPlacementInput = {
    logId: string
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
  }

  export type LogsUncheckedCreateWithoutPlacementInput = {
    logId: string
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
  }

  export type LogsCreateOrConnectWithoutPlacementInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutPlacementInput, LogsUncheckedCreateWithoutPlacementInput>
  }

  export type LogsCreateManyPlacementInputEnvelope = {
    data: LogsCreateManyPlacementInput | LogsCreateManyPlacementInput[]
    skipDuplicates?: boolean
  }

  export type AddressesCreateWithoutPlacementsInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    institute?: InstitutesCreateNestedOneWithoutAddressesInput
    provider?: ProvidersCreateNestedOneWithoutAddressesInput
    Contacts?: ContactsCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutAddressInput
  }

  export type AddressesUncheckedCreateWithoutPlacementsInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    instituteId?: string | null
    providerId?: string | null
    Contacts?: ContactsUncheckedCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressesCreateOrConnectWithoutPlacementsInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutPlacementsInput, AddressesUncheckedCreateWithoutPlacementsInput>
  }

  export type InstitutesCreateWithoutPlacementsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateWithoutPlacementsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsUncheckedCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesCreateOrConnectWithoutPlacementsInput = {
    where: InstitutesWhereUniqueInput
    create: XOR<InstitutesCreateWithoutPlacementsInput, InstitutesUncheckedCreateWithoutPlacementsInput>
  }

  export type InstituteStudentsCreateWithoutPlacementsInput = {
    instituteStudentId: string
    activated: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    Contacts?: ContactsCreateNestedManyWithoutInstitutestudentUserInput
    cohort: CohortsCreateNestedOneWithoutInstituteStudentsInput
    institute: InstitutesCreateNestedOneWithoutInstituteStudentsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutInstituteStudentsInput
  }

  export type InstituteStudentsUncheckedCreateWithoutPlacementsInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
    Contacts?: ContactsUncheckedCreateNestedManyWithoutInstitutestudentUserInput
  }

  export type InstituteStudentsCreateOrConnectWithoutPlacementsInput = {
    where: InstituteStudentsWhereUniqueInput
    create: XOR<InstituteStudentsCreateWithoutPlacementsInput, InstituteStudentsUncheckedCreateWithoutPlacementsInput>
  }

  export type ProvidersCreateWithoutPlacementsInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutProviderInput
  }

  export type ProvidersUncheckedCreateWithoutPlacementsInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesUncheckedCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffUncheckedCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProvidersCreateOrConnectWithoutPlacementsInput = {
    where: ProvidersWhereUniqueInput
    create: XOR<ProvidersCreateWithoutPlacementsInput, ProvidersUncheckedCreateWithoutPlacementsInput>
  }

  export type StudentUsersCreateWithoutPlacementsInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
    Contacts?: ContactsCreateNestedManyWithoutStudentUserInput
  }

  export type StudentUsersUncheckedCreateWithoutPlacementsInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
    Contacts?: ContactsUncheckedCreateNestedManyWithoutStudentUserInput
  }

  export type StudentUsersCreateOrConnectWithoutPlacementsInput = {
    where: StudentUsersWhereUniqueInput
    create: XOR<StudentUsersCreateWithoutPlacementsInput, StudentUsersUncheckedCreateWithoutPlacementsInput>
  }

  export type InstituteStudentUserGroupsCreateWithoutPlacementsInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    institute: InstitutesCreateNestedOneWithoutStudentUserGroupsInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStudentUserGroupsUncheckedCreateWithoutPlacementsInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStudentUserGroupsCreateOrConnectWithoutPlacementsInput = {
    where: InstituteStudentUserGroupsWhereUniqueInput
    create: XOR<InstituteStudentUserGroupsCreateWithoutPlacementsInput, InstituteStudentUserGroupsUncheckedCreateWithoutPlacementsInput>
  }

  export type LogsUpsertWithWhereUniqueWithoutPlacementInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutPlacementInput, LogsUncheckedUpdateWithoutPlacementInput>
    create: XOR<LogsCreateWithoutPlacementInput, LogsUncheckedCreateWithoutPlacementInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutPlacementInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutPlacementInput, LogsUncheckedUpdateWithoutPlacementInput>
  }

  export type LogsUpdateManyWithWhereWithoutPlacementInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutPlacementInput>
  }

  export type LogsScalarWhereInput = {
    AND?: LogsScalarWhereInput | LogsScalarWhereInput[]
    OR?: LogsScalarWhereInput[]
    NOT?: LogsScalarWhereInput | LogsScalarWhereInput[]
    logId?: StringFilter<"Logs"> | string
    provider?: JsonFilter<"Logs">
    students?: JsonFilter<"Logs">
    staff?: JsonFilter<"Logs">
    uid?: StringFilter<"Logs"> | string
    placementId?: StringFilter<"Logs"> | string
  }

  export type AddressesUpsertWithoutPlacementsInput = {
    update: XOR<AddressesUpdateWithoutPlacementsInput, AddressesUncheckedUpdateWithoutPlacementsInput>
    create: XOR<AddressesCreateWithoutPlacementsInput, AddressesUncheckedCreateWithoutPlacementsInput>
    where?: AddressesWhereInput
  }

  export type AddressesUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: AddressesWhereInput
    data: XOR<AddressesUpdateWithoutPlacementsInput, AddressesUncheckedUpdateWithoutPlacementsInput>
  }

  export type AddressesUpdateWithoutPlacementsInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    institute?: InstitutesUpdateOneWithoutAddressesNestedInput
    provider?: ProvidersUpdateOneWithoutAddressesNestedInput
    Contacts?: ContactsUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutPlacementsInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    Contacts?: ContactsUncheckedUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type InstitutesUpsertWithoutPlacementsInput = {
    update: XOR<InstitutesUpdateWithoutPlacementsInput, InstitutesUncheckedUpdateWithoutPlacementsInput>
    create: XOR<InstitutesCreateWithoutPlacementsInput, InstitutesUncheckedCreateWithoutPlacementsInput>
    where?: InstitutesWhereInput
  }

  export type InstitutesUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: InstitutesWhereInput
    data: XOR<InstitutesUpdateWithoutPlacementsInput, InstitutesUncheckedUpdateWithoutPlacementsInput>
  }

  export type InstitutesUpdateWithoutPlacementsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateWithoutPlacementsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUncheckedUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type InstituteStudentsUpsertWithoutPlacementsInput = {
    update: XOR<InstituteStudentsUpdateWithoutPlacementsInput, InstituteStudentsUncheckedUpdateWithoutPlacementsInput>
    create: XOR<InstituteStudentsCreateWithoutPlacementsInput, InstituteStudentsUncheckedCreateWithoutPlacementsInput>
    where?: InstituteStudentsWhereInput
  }

  export type InstituteStudentsUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: InstituteStudentsWhereInput
    data: XOR<InstituteStudentsUpdateWithoutPlacementsInput, InstituteStudentsUncheckedUpdateWithoutPlacementsInput>
  }

  export type InstituteStudentsUpdateWithoutPlacementsInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUpdateManyWithoutInstitutestudentUserNestedInput
    cohort?: CohortsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutInstituteStudentsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutInstituteStudentsNestedInput
  }

  export type InstituteStudentsUncheckedUpdateWithoutPlacementsInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUncheckedUpdateManyWithoutInstitutestudentUserNestedInput
  }

  export type ProvidersUpsertWithoutPlacementsInput = {
    update: XOR<ProvidersUpdateWithoutPlacementsInput, ProvidersUncheckedUpdateWithoutPlacementsInput>
    create: XOR<ProvidersCreateWithoutPlacementsInput, ProvidersUncheckedCreateWithoutPlacementsInput>
    where?: ProvidersWhereInput
  }

  export type ProvidersUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: ProvidersWhereInput
    data: XOR<ProvidersUpdateWithoutPlacementsInput, ProvidersUncheckedUpdateWithoutPlacementsInput>
  }

  export type ProvidersUpdateWithoutPlacementsInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutProviderNestedInput
  }

  export type ProvidersUncheckedUpdateWithoutPlacementsInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUncheckedUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUncheckedUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type StudentUsersUpsertWithoutPlacementsInput = {
    update: XOR<StudentUsersUpdateWithoutPlacementsInput, StudentUsersUncheckedUpdateWithoutPlacementsInput>
    create: XOR<StudentUsersCreateWithoutPlacementsInput, StudentUsersUncheckedCreateWithoutPlacementsInput>
    where?: StudentUsersWhereInput
  }

  export type StudentUsersUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: StudentUsersWhereInput
    data: XOR<StudentUsersUpdateWithoutPlacementsInput, StudentUsersUncheckedUpdateWithoutPlacementsInput>
  }

  export type StudentUsersUpdateWithoutPlacementsInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUpdateManyWithoutStudentUserNestedInput
  }

  export type StudentUsersUncheckedUpdateWithoutPlacementsInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUncheckedUpdateManyWithoutStudentUserNestedInput
  }

  export type InstituteStudentUserGroupsUpsertWithoutPlacementsInput = {
    update: XOR<InstituteStudentUserGroupsUpdateWithoutPlacementsInput, InstituteStudentUserGroupsUncheckedUpdateWithoutPlacementsInput>
    create: XOR<InstituteStudentUserGroupsCreateWithoutPlacementsInput, InstituteStudentUserGroupsUncheckedCreateWithoutPlacementsInput>
    where?: InstituteStudentUserGroupsWhereInput
  }

  export type InstituteStudentUserGroupsUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: InstituteStudentUserGroupsWhereInput
    data: XOR<InstituteStudentUserGroupsUpdateWithoutPlacementsInput, InstituteStudentUserGroupsUncheckedUpdateWithoutPlacementsInput>
  }

  export type InstituteStudentUserGroupsUpdateWithoutPlacementsInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutStudentUserGroupsNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStudentUserGroupsUncheckedUpdateWithoutPlacementsInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutUserGroupNestedInput
  }

  export type AddressesCreateWithoutProviderInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    institute?: InstitutesCreateNestedOneWithoutAddressesInput
    Contacts?: ContactsCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutAddressInput
    Placements?: PlacementsCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutAddressInput
  }

  export type AddressesUncheckedCreateWithoutProviderInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    instituteId?: string | null
    Contacts?: ContactsUncheckedCreateNestedManyWithoutAddressInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutAddressInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutAddressInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressesCreateOrConnectWithoutProviderInput = {
    where: AddressesWhereUniqueInput
    create: XOR<AddressesCreateWithoutProviderInput, AddressesUncheckedCreateWithoutProviderInput>
  }

  export type AddressesCreateManyProviderInputEnvelope = {
    data: AddressesCreateManyProviderInput | AddressesCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type PlacementListingsCreateWithoutProviderInput = {
    placementListingId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
    address: AddressesCreateNestedOneWithoutPlacementListingsInput
  }

  export type PlacementListingsUncheckedCreateWithoutProviderInput = {
    placementListingId: string
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementListingsCreateOrConnectWithoutProviderInput = {
    where: PlacementListingsWhereUniqueInput
    create: XOR<PlacementListingsCreateWithoutProviderInput, PlacementListingsUncheckedCreateWithoutProviderInput>
  }

  export type PlacementListingsCreateManyProviderInputEnvelope = {
    data: PlacementListingsCreateManyProviderInput | PlacementListingsCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type PlacementsCreateWithoutProviderInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    Logs?: LogsCreateNestedManyWithoutPlacementInput
    address: AddressesCreateNestedOneWithoutPlacementsInput
    institute: InstitutesCreateNestedOneWithoutPlacementsInput
    instituteStudent: InstituteStudentsCreateNestedOneWithoutPlacementsInput
    student: StudentUsersCreateNestedOneWithoutPlacementsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementsUncheckedCreateWithoutProviderInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    studentId: string
    userGroupId: string
    Logs?: LogsUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementsCreateOrConnectWithoutProviderInput = {
    where: PlacementsWhereUniqueInput
    create: XOR<PlacementsCreateWithoutProviderInput, PlacementsUncheckedCreateWithoutProviderInput>
  }

  export type PlacementsCreateManyProviderInputEnvelope = {
    data: PlacementsCreateManyProviderInput | PlacementsCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ProviderStaffCreateWithoutProviderInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userGroup: ProviderUserGroupsCreateNestedOneWithoutProviderStaffInput
  }

  export type ProviderStaffUncheckedCreateWithoutProviderInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userGroupId: string
  }

  export type ProviderStaffCreateOrConnectWithoutProviderInput = {
    where: ProviderStaffWhereUniqueInput
    create: XOR<ProviderStaffCreateWithoutProviderInput, ProviderStaffUncheckedCreateWithoutProviderInput>
  }

  export type ProviderStaffCreateManyProviderInputEnvelope = {
    data: ProviderStaffCreateManyProviderInput | ProviderStaffCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ProviderUserGroupsCreateWithoutProviderInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    ProviderStaff?: ProviderStaffCreateNestedManyWithoutUserGroupInput
  }

  export type ProviderUserGroupsUncheckedCreateWithoutProviderInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    ProviderStaff?: ProviderStaffUncheckedCreateNestedManyWithoutUserGroupInput
  }

  export type ProviderUserGroupsCreateOrConnectWithoutProviderInput = {
    where: ProviderUserGroupsWhereUniqueInput
    create: XOR<ProviderUserGroupsCreateWithoutProviderInput, ProviderUserGroupsUncheckedCreateWithoutProviderInput>
  }

  export type ProviderUserGroupsCreateManyProviderInputEnvelope = {
    data: ProviderUserGroupsCreateManyProviderInput | ProviderUserGroupsCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ProviderCohortsCreateWithoutProviderInput = {
    cohortId: string
    stage: string
    name: string
    address: AddressesCreateNestedOneWithoutProviderCohortsInput
  }

  export type ProviderCohortsUncheckedCreateWithoutProviderInput = {
    cohortId: string
    stage: string
    name: string
    addressId: string
  }

  export type ProviderCohortsCreateOrConnectWithoutProviderInput = {
    where: ProviderCohortsWhereUniqueInput
    create: XOR<ProviderCohortsCreateWithoutProviderInput, ProviderCohortsUncheckedCreateWithoutProviderInput>
  }

  export type ProviderCohortsCreateManyProviderInputEnvelope = {
    data: ProviderCohortsCreateManyProviderInput | ProviderCohortsCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type AddressesUpsertWithWhereUniqueWithoutProviderInput = {
    where: AddressesWhereUniqueInput
    update: XOR<AddressesUpdateWithoutProviderInput, AddressesUncheckedUpdateWithoutProviderInput>
    create: XOR<AddressesCreateWithoutProviderInput, AddressesUncheckedCreateWithoutProviderInput>
  }

  export type AddressesUpdateWithWhereUniqueWithoutProviderInput = {
    where: AddressesWhereUniqueInput
    data: XOR<AddressesUpdateWithoutProviderInput, AddressesUncheckedUpdateWithoutProviderInput>
  }

  export type AddressesUpdateManyWithWhereWithoutProviderInput = {
    where: AddressesScalarWhereInput
    data: XOR<AddressesUpdateManyMutationInput, AddressesUncheckedUpdateManyWithoutProviderInput>
  }

  export type PlacementListingsUpsertWithWhereUniqueWithoutProviderInput = {
    where: PlacementListingsWhereUniqueInput
    update: XOR<PlacementListingsUpdateWithoutProviderInput, PlacementListingsUncheckedUpdateWithoutProviderInput>
    create: XOR<PlacementListingsCreateWithoutProviderInput, PlacementListingsUncheckedCreateWithoutProviderInput>
  }

  export type PlacementListingsUpdateWithWhereUniqueWithoutProviderInput = {
    where: PlacementListingsWhereUniqueInput
    data: XOR<PlacementListingsUpdateWithoutProviderInput, PlacementListingsUncheckedUpdateWithoutProviderInput>
  }

  export type PlacementListingsUpdateManyWithWhereWithoutProviderInput = {
    where: PlacementListingsScalarWhereInput
    data: XOR<PlacementListingsUpdateManyMutationInput, PlacementListingsUncheckedUpdateManyWithoutProviderInput>
  }

  export type PlacementsUpsertWithWhereUniqueWithoutProviderInput = {
    where: PlacementsWhereUniqueInput
    update: XOR<PlacementsUpdateWithoutProviderInput, PlacementsUncheckedUpdateWithoutProviderInput>
    create: XOR<PlacementsCreateWithoutProviderInput, PlacementsUncheckedCreateWithoutProviderInput>
  }

  export type PlacementsUpdateWithWhereUniqueWithoutProviderInput = {
    where: PlacementsWhereUniqueInput
    data: XOR<PlacementsUpdateWithoutProviderInput, PlacementsUncheckedUpdateWithoutProviderInput>
  }

  export type PlacementsUpdateManyWithWhereWithoutProviderInput = {
    where: PlacementsScalarWhereInput
    data: XOR<PlacementsUpdateManyMutationInput, PlacementsUncheckedUpdateManyWithoutProviderInput>
  }

  export type ProviderStaffUpsertWithWhereUniqueWithoutProviderInput = {
    where: ProviderStaffWhereUniqueInput
    update: XOR<ProviderStaffUpdateWithoutProviderInput, ProviderStaffUncheckedUpdateWithoutProviderInput>
    create: XOR<ProviderStaffCreateWithoutProviderInput, ProviderStaffUncheckedCreateWithoutProviderInput>
  }

  export type ProviderStaffUpdateWithWhereUniqueWithoutProviderInput = {
    where: ProviderStaffWhereUniqueInput
    data: XOR<ProviderStaffUpdateWithoutProviderInput, ProviderStaffUncheckedUpdateWithoutProviderInput>
  }

  export type ProviderStaffUpdateManyWithWhereWithoutProviderInput = {
    where: ProviderStaffScalarWhereInput
    data: XOR<ProviderStaffUpdateManyMutationInput, ProviderStaffUncheckedUpdateManyWithoutProviderInput>
  }

  export type ProviderStaffScalarWhereInput = {
    AND?: ProviderStaffScalarWhereInput | ProviderStaffScalarWhereInput[]
    OR?: ProviderStaffScalarWhereInput[]
    NOT?: ProviderStaffScalarWhereInput | ProviderStaffScalarWhereInput[]
    providerStaffId?: StringFilter<"ProviderStaff"> | string
    created?: StringFilter<"ProviderStaff"> | string
    details?: JsonFilter<"ProviderStaff">
    email?: StringFilter<"ProviderStaff"> | string
    notes?: JsonNullableFilter<"ProviderStaff">
    status?: StringFilter<"ProviderStaff"> | string
    providerId?: StringFilter<"ProviderStaff"> | string
    userGroupId?: StringFilter<"ProviderStaff"> | string
  }

  export type ProviderUserGroupsUpsertWithWhereUniqueWithoutProviderInput = {
    where: ProviderUserGroupsWhereUniqueInput
    update: XOR<ProviderUserGroupsUpdateWithoutProviderInput, ProviderUserGroupsUncheckedUpdateWithoutProviderInput>
    create: XOR<ProviderUserGroupsCreateWithoutProviderInput, ProviderUserGroupsUncheckedCreateWithoutProviderInput>
  }

  export type ProviderUserGroupsUpdateWithWhereUniqueWithoutProviderInput = {
    where: ProviderUserGroupsWhereUniqueInput
    data: XOR<ProviderUserGroupsUpdateWithoutProviderInput, ProviderUserGroupsUncheckedUpdateWithoutProviderInput>
  }

  export type ProviderUserGroupsUpdateManyWithWhereWithoutProviderInput = {
    where: ProviderUserGroupsScalarWhereInput
    data: XOR<ProviderUserGroupsUpdateManyMutationInput, ProviderUserGroupsUncheckedUpdateManyWithoutProviderInput>
  }

  export type ProviderUserGroupsScalarWhereInput = {
    AND?: ProviderUserGroupsScalarWhereInput | ProviderUserGroupsScalarWhereInput[]
    OR?: ProviderUserGroupsScalarWhereInput[]
    NOT?: ProviderUserGroupsScalarWhereInput | ProviderUserGroupsScalarWhereInput[]
    userGroupId?: StringFilter<"ProviderUserGroups"> | string
    default?: BoolFilter<"ProviderUserGroups"> | boolean
    name?: StringFilter<"ProviderUserGroups"> | string
    updated?: StringFilter<"ProviderUserGroups"> | string
    providerId?: StringFilter<"ProviderUserGroups"> | string
  }

  export type ProviderCohortsUpsertWithWhereUniqueWithoutProviderInput = {
    where: ProviderCohortsWhereUniqueInput
    update: XOR<ProviderCohortsUpdateWithoutProviderInput, ProviderCohortsUncheckedUpdateWithoutProviderInput>
    create: XOR<ProviderCohortsCreateWithoutProviderInput, ProviderCohortsUncheckedCreateWithoutProviderInput>
  }

  export type ProviderCohortsUpdateWithWhereUniqueWithoutProviderInput = {
    where: ProviderCohortsWhereUniqueInput
    data: XOR<ProviderCohortsUpdateWithoutProviderInput, ProviderCohortsUncheckedUpdateWithoutProviderInput>
  }

  export type ProviderCohortsUpdateManyWithWhereWithoutProviderInput = {
    where: ProviderCohortsScalarWhereInput
    data: XOR<ProviderCohortsUpdateManyMutationInput, ProviderCohortsUncheckedUpdateManyWithoutProviderInput>
  }

  export type InstitutesCreateWithoutStudentUserGroupsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateWithoutStudentUserGroupsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsUncheckedCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesCreateOrConnectWithoutStudentUserGroupsInput = {
    where: InstitutesWhereUniqueInput
    create: XOR<InstitutesCreateWithoutStudentUserGroupsInput, InstitutesUncheckedCreateWithoutStudentUserGroupsInput>
  }

  export type InstituteStudentsCreateWithoutUserGroupInput = {
    instituteStudentId: string
    activated: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    Contacts?: ContactsCreateNestedManyWithoutInstitutestudentUserInput
    cohort: CohortsCreateNestedOneWithoutInstituteStudentsInput
    institute: InstitutesCreateNestedOneWithoutInstituteStudentsInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsUncheckedCreateWithoutUserGroupInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    instituteId: string
    Contacts?: ContactsUncheckedCreateNestedManyWithoutInstitutestudentUserInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteStudentInput
  }

  export type InstituteStudentsCreateOrConnectWithoutUserGroupInput = {
    where: InstituteStudentsWhereUniqueInput
    create: XOR<InstituteStudentsCreateWithoutUserGroupInput, InstituteStudentsUncheckedCreateWithoutUserGroupInput>
  }

  export type InstituteStudentsCreateManyUserGroupInputEnvelope = {
    data: InstituteStudentsCreateManyUserGroupInput | InstituteStudentsCreateManyUserGroupInput[]
    skipDuplicates?: boolean
  }

  export type PlacementsCreateWithoutUserGroupInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    Logs?: LogsCreateNestedManyWithoutPlacementInput
    address: AddressesCreateNestedOneWithoutPlacementsInput
    institute: InstitutesCreateNestedOneWithoutPlacementsInput
    instituteStudent: InstituteStudentsCreateNestedOneWithoutPlacementsInput
    provider: ProvidersCreateNestedOneWithoutPlacementsInput
    student: StudentUsersCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementsUncheckedCreateWithoutUserGroupInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    Logs?: LogsUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementsCreateOrConnectWithoutUserGroupInput = {
    where: PlacementsWhereUniqueInput
    create: XOR<PlacementsCreateWithoutUserGroupInput, PlacementsUncheckedCreateWithoutUserGroupInput>
  }

  export type PlacementsCreateManyUserGroupInputEnvelope = {
    data: PlacementsCreateManyUserGroupInput | PlacementsCreateManyUserGroupInput[]
    skipDuplicates?: boolean
  }

  export type InstitutesUpsertWithoutStudentUserGroupsInput = {
    update: XOR<InstitutesUpdateWithoutStudentUserGroupsInput, InstitutesUncheckedUpdateWithoutStudentUserGroupsInput>
    create: XOR<InstitutesCreateWithoutStudentUserGroupsInput, InstitutesUncheckedCreateWithoutStudentUserGroupsInput>
    where?: InstitutesWhereInput
  }

  export type InstitutesUpdateToOneWithWhereWithoutStudentUserGroupsInput = {
    where?: InstitutesWhereInput
    data: XOR<InstitutesUpdateWithoutStudentUserGroupsInput, InstitutesUncheckedUpdateWithoutStudentUserGroupsInput>
  }

  export type InstitutesUpdateWithoutStudentUserGroupsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateWithoutStudentUserGroupsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUncheckedUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type InstituteStudentsUpsertWithWhereUniqueWithoutUserGroupInput = {
    where: InstituteStudentsWhereUniqueInput
    update: XOR<InstituteStudentsUpdateWithoutUserGroupInput, InstituteStudentsUncheckedUpdateWithoutUserGroupInput>
    create: XOR<InstituteStudentsCreateWithoutUserGroupInput, InstituteStudentsUncheckedCreateWithoutUserGroupInput>
  }

  export type InstituteStudentsUpdateWithWhereUniqueWithoutUserGroupInput = {
    where: InstituteStudentsWhereUniqueInput
    data: XOR<InstituteStudentsUpdateWithoutUserGroupInput, InstituteStudentsUncheckedUpdateWithoutUserGroupInput>
  }

  export type InstituteStudentsUpdateManyWithWhereWithoutUserGroupInput = {
    where: InstituteStudentsScalarWhereInput
    data: XOR<InstituteStudentsUpdateManyMutationInput, InstituteStudentsUncheckedUpdateManyWithoutUserGroupInput>
  }

  export type PlacementsUpsertWithWhereUniqueWithoutUserGroupInput = {
    where: PlacementsWhereUniqueInput
    update: XOR<PlacementsUpdateWithoutUserGroupInput, PlacementsUncheckedUpdateWithoutUserGroupInput>
    create: XOR<PlacementsCreateWithoutUserGroupInput, PlacementsUncheckedCreateWithoutUserGroupInput>
  }

  export type PlacementsUpdateWithWhereUniqueWithoutUserGroupInput = {
    where: PlacementsWhereUniqueInput
    data: XOR<PlacementsUpdateWithoutUserGroupInput, PlacementsUncheckedUpdateWithoutUserGroupInput>
  }

  export type PlacementsUpdateManyWithWhereWithoutUserGroupInput = {
    where: PlacementsScalarWhereInput
    data: XOR<PlacementsUpdateManyMutationInput, PlacementsUncheckedUpdateManyWithoutUserGroupInput>
  }

  export type InstituteStaffCreateWithoutUserGroupInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    institute: InstitutesCreateNestedOneWithoutInstituteStaffInput
  }

  export type InstituteStaffUncheckedCreateWithoutUserGroupInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    instituteId: string
  }

  export type InstituteStaffCreateOrConnectWithoutUserGroupInput = {
    where: InstituteStaffWhereUniqueInput
    create: XOR<InstituteStaffCreateWithoutUserGroupInput, InstituteStaffUncheckedCreateWithoutUserGroupInput>
  }

  export type InstituteStaffCreateManyUserGroupInputEnvelope = {
    data: InstituteStaffCreateManyUserGroupInput | InstituteStaffCreateManyUserGroupInput[]
    skipDuplicates?: boolean
  }

  export type InstitutesCreateWithoutStaffUserGroupsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateWithoutStaffUserGroupsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsUncheckedCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesCreateOrConnectWithoutStaffUserGroupsInput = {
    where: InstitutesWhereUniqueInput
    create: XOR<InstitutesCreateWithoutStaffUserGroupsInput, InstitutesUncheckedCreateWithoutStaffUserGroupsInput>
  }

  export type InstituteStaffUpsertWithWhereUniqueWithoutUserGroupInput = {
    where: InstituteStaffWhereUniqueInput
    update: XOR<InstituteStaffUpdateWithoutUserGroupInput, InstituteStaffUncheckedUpdateWithoutUserGroupInput>
    create: XOR<InstituteStaffCreateWithoutUserGroupInput, InstituteStaffUncheckedCreateWithoutUserGroupInput>
  }

  export type InstituteStaffUpdateWithWhereUniqueWithoutUserGroupInput = {
    where: InstituteStaffWhereUniqueInput
    data: XOR<InstituteStaffUpdateWithoutUserGroupInput, InstituteStaffUncheckedUpdateWithoutUserGroupInput>
  }

  export type InstituteStaffUpdateManyWithWhereWithoutUserGroupInput = {
    where: InstituteStaffScalarWhereInput
    data: XOR<InstituteStaffUpdateManyMutationInput, InstituteStaffUncheckedUpdateManyWithoutUserGroupInput>
  }

  export type InstitutesUpsertWithoutStaffUserGroupsInput = {
    update: XOR<InstitutesUpdateWithoutStaffUserGroupsInput, InstitutesUncheckedUpdateWithoutStaffUserGroupsInput>
    create: XOR<InstitutesCreateWithoutStaffUserGroupsInput, InstitutesUncheckedCreateWithoutStaffUserGroupsInput>
    where?: InstitutesWhereInput
  }

  export type InstitutesUpdateToOneWithWhereWithoutStaffUserGroupsInput = {
    where?: InstitutesWhereInput
    data: XOR<InstitutesUpdateWithoutStaffUserGroupsInput, InstitutesUncheckedUpdateWithoutStaffUserGroupsInput>
  }

  export type InstitutesUpdateWithoutStaffUserGroupsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateWithoutStaffUserGroupsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUncheckedUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type ProviderStaffCreateWithoutUserGroupInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    provider: ProvidersCreateNestedOneWithoutProviderStaffInput
  }

  export type ProviderStaffUncheckedCreateWithoutUserGroupInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    providerId: string
  }

  export type ProviderStaffCreateOrConnectWithoutUserGroupInput = {
    where: ProviderStaffWhereUniqueInput
    create: XOR<ProviderStaffCreateWithoutUserGroupInput, ProviderStaffUncheckedCreateWithoutUserGroupInput>
  }

  export type ProviderStaffCreateManyUserGroupInputEnvelope = {
    data: ProviderStaffCreateManyUserGroupInput | ProviderStaffCreateManyUserGroupInput[]
    skipDuplicates?: boolean
  }

  export type ProvidersCreateWithoutProviderUserGroupsInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutProviderInput
    Placements?: PlacementsCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutProviderInput
  }

  export type ProvidersUncheckedCreateWithoutProviderUserGroupsInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesUncheckedCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutProviderInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutProviderInput
    ProviderStaff?: ProviderStaffUncheckedCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProvidersCreateOrConnectWithoutProviderUserGroupsInput = {
    where: ProvidersWhereUniqueInput
    create: XOR<ProvidersCreateWithoutProviderUserGroupsInput, ProvidersUncheckedCreateWithoutProviderUserGroupsInput>
  }

  export type ProviderStaffUpsertWithWhereUniqueWithoutUserGroupInput = {
    where: ProviderStaffWhereUniqueInput
    update: XOR<ProviderStaffUpdateWithoutUserGroupInput, ProviderStaffUncheckedUpdateWithoutUserGroupInput>
    create: XOR<ProviderStaffCreateWithoutUserGroupInput, ProviderStaffUncheckedCreateWithoutUserGroupInput>
  }

  export type ProviderStaffUpdateWithWhereUniqueWithoutUserGroupInput = {
    where: ProviderStaffWhereUniqueInput
    data: XOR<ProviderStaffUpdateWithoutUserGroupInput, ProviderStaffUncheckedUpdateWithoutUserGroupInput>
  }

  export type ProviderStaffUpdateManyWithWhereWithoutUserGroupInput = {
    where: ProviderStaffScalarWhereInput
    data: XOR<ProviderStaffUpdateManyMutationInput, ProviderStaffUncheckedUpdateManyWithoutUserGroupInput>
  }

  export type ProvidersUpsertWithoutProviderUserGroupsInput = {
    update: XOR<ProvidersUpdateWithoutProviderUserGroupsInput, ProvidersUncheckedUpdateWithoutProviderUserGroupsInput>
    create: XOR<ProvidersCreateWithoutProviderUserGroupsInput, ProvidersUncheckedCreateWithoutProviderUserGroupsInput>
    where?: ProvidersWhereInput
  }

  export type ProvidersUpdateToOneWithWhereWithoutProviderUserGroupsInput = {
    where?: ProvidersWhereInput
    data: XOR<ProvidersUpdateWithoutProviderUserGroupsInput, ProvidersUncheckedUpdateWithoutProviderUserGroupsInput>
  }

  export type ProvidersUpdateWithoutProviderUserGroupsInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutProviderNestedInput
  }

  export type ProvidersUncheckedUpdateWithoutProviderUserGroupsInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUncheckedUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderStaff?: ProviderStaffUncheckedUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ContactsCreateWithoutStudentUserInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstitutestudentUser: InstituteStudentsCreateNestedOneWithoutContactsInput
    address: AddressesCreateNestedOneWithoutContactsInput
  }

  export type ContactsUncheckedCreateWithoutStudentUserInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstituteStudentUserId: string
    addressId: string
  }

  export type ContactsCreateOrConnectWithoutStudentUserInput = {
    where: ContactsWhereUniqueInput
    create: XOR<ContactsCreateWithoutStudentUserInput, ContactsUncheckedCreateWithoutStudentUserInput>
  }

  export type ContactsCreateManyStudentUserInputEnvelope = {
    data: ContactsCreateManyStudentUserInput | ContactsCreateManyStudentUserInput[]
    skipDuplicates?: boolean
  }

  export type PlacementsCreateWithoutStudentInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    Logs?: LogsCreateNestedManyWithoutPlacementInput
    address: AddressesCreateNestedOneWithoutPlacementsInput
    institute: InstitutesCreateNestedOneWithoutPlacementsInput
    instituteStudent: InstituteStudentsCreateNestedOneWithoutPlacementsInput
    provider: ProvidersCreateNestedOneWithoutPlacementsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementsUncheckedCreateWithoutStudentInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    userGroupId: string
    Logs?: LogsUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementsCreateOrConnectWithoutStudentInput = {
    where: PlacementsWhereUniqueInput
    create: XOR<PlacementsCreateWithoutStudentInput, PlacementsUncheckedCreateWithoutStudentInput>
  }

  export type PlacementsCreateManyStudentInputEnvelope = {
    data: PlacementsCreateManyStudentInput | PlacementsCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ContactsUpsertWithWhereUniqueWithoutStudentUserInput = {
    where: ContactsWhereUniqueInput
    update: XOR<ContactsUpdateWithoutStudentUserInput, ContactsUncheckedUpdateWithoutStudentUserInput>
    create: XOR<ContactsCreateWithoutStudentUserInput, ContactsUncheckedCreateWithoutStudentUserInput>
  }

  export type ContactsUpdateWithWhereUniqueWithoutStudentUserInput = {
    where: ContactsWhereUniqueInput
    data: XOR<ContactsUpdateWithoutStudentUserInput, ContactsUncheckedUpdateWithoutStudentUserInput>
  }

  export type ContactsUpdateManyWithWhereWithoutStudentUserInput = {
    where: ContactsScalarWhereInput
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyWithoutStudentUserInput>
  }

  export type PlacementsUpsertWithWhereUniqueWithoutStudentInput = {
    where: PlacementsWhereUniqueInput
    update: XOR<PlacementsUpdateWithoutStudentInput, PlacementsUncheckedUpdateWithoutStudentInput>
    create: XOR<PlacementsCreateWithoutStudentInput, PlacementsUncheckedCreateWithoutStudentInput>
  }

  export type PlacementsUpdateWithWhereUniqueWithoutStudentInput = {
    where: PlacementsWhereUniqueInput
    data: XOR<PlacementsUpdateWithoutStudentInput, PlacementsUncheckedUpdateWithoutStudentInput>
  }

  export type PlacementsUpdateManyWithWhereWithoutStudentInput = {
    where: PlacementsScalarWhereInput
    data: XOR<PlacementsUpdateManyMutationInput, PlacementsUncheckedUpdateManyWithoutStudentInput>
  }

  export type InstitutesCreateWithoutInstituteStaffInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateWithoutInstituteStaffInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsUncheckedCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStudents?: InstituteStudentsUncheckedCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesCreateOrConnectWithoutInstituteStaffInput = {
    where: InstitutesWhereUniqueInput
    create: XOR<InstitutesCreateWithoutInstituteStaffInput, InstitutesUncheckedCreateWithoutInstituteStaffInput>
  }

  export type InstituteStaffUserGroupsCreateWithoutInstituteStaffInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    institute: InstitutesCreateNestedOneWithoutStaffUserGroupsInput
  }

  export type InstituteStaffUserGroupsUncheckedCreateWithoutInstituteStaffInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
  }

  export type InstituteStaffUserGroupsCreateOrConnectWithoutInstituteStaffInput = {
    where: InstituteStaffUserGroupsWhereUniqueInput
    create: XOR<InstituteStaffUserGroupsCreateWithoutInstituteStaffInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteStaffInput>
  }

  export type InstitutesUpsertWithoutInstituteStaffInput = {
    update: XOR<InstitutesUpdateWithoutInstituteStaffInput, InstitutesUncheckedUpdateWithoutInstituteStaffInput>
    create: XOR<InstitutesCreateWithoutInstituteStaffInput, InstitutesUncheckedCreateWithoutInstituteStaffInput>
    where?: InstitutesWhereInput
  }

  export type InstitutesUpdateToOneWithWhereWithoutInstituteStaffInput = {
    where?: InstitutesWhereInput
    data: XOR<InstitutesUpdateWithoutInstituteStaffInput, InstitutesUncheckedUpdateWithoutInstituteStaffInput>
  }

  export type InstitutesUpdateWithoutInstituteStaffInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateWithoutInstituteStaffInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUncheckedUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type InstituteStaffUserGroupsUpsertWithoutInstituteStaffInput = {
    update: XOR<InstituteStaffUserGroupsUpdateWithoutInstituteStaffInput, InstituteStaffUserGroupsUncheckedUpdateWithoutInstituteStaffInput>
    create: XOR<InstituteStaffUserGroupsCreateWithoutInstituteStaffInput, InstituteStaffUserGroupsUncheckedCreateWithoutInstituteStaffInput>
    where?: InstituteStaffUserGroupsWhereInput
  }

  export type InstituteStaffUserGroupsUpdateToOneWithWhereWithoutInstituteStaffInput = {
    where?: InstituteStaffUserGroupsWhereInput
    data: XOR<InstituteStaffUserGroupsUpdateWithoutInstituteStaffInput, InstituteStaffUserGroupsUncheckedUpdateWithoutInstituteStaffInput>
  }

  export type InstituteStaffUserGroupsUpdateWithoutInstituteStaffInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutStaffUserGroupsNestedInput
  }

  export type InstituteStaffUserGroupsUncheckedUpdateWithoutInstituteStaffInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsCreateWithoutInstitutestudentUserInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    address: AddressesCreateNestedOneWithoutContactsInput
    studentUser: StudentUsersCreateNestedOneWithoutContactsInput
  }

  export type ContactsUncheckedCreateWithoutInstitutestudentUserInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    addressId: string
    studentUserId: string
  }

  export type ContactsCreateOrConnectWithoutInstitutestudentUserInput = {
    where: ContactsWhereUniqueInput
    create: XOR<ContactsCreateWithoutInstitutestudentUserInput, ContactsUncheckedCreateWithoutInstitutestudentUserInput>
  }

  export type ContactsCreateManyInstitutestudentUserInputEnvelope = {
    data: ContactsCreateManyInstitutestudentUserInput | ContactsCreateManyInstitutestudentUserInput[]
    skipDuplicates?: boolean
  }

  export type CohortsCreateWithoutInstituteStudentsInput = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
    institute: InstitutesCreateNestedOneWithoutCohortsInput
  }

  export type CohortsUncheckedCreateWithoutInstituteStudentsInput = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
    instituteId: string
  }

  export type CohortsCreateOrConnectWithoutInstituteStudentsInput = {
    where: CohortsWhereUniqueInput
    create: XOR<CohortsCreateWithoutInstituteStudentsInput, CohortsUncheckedCreateWithoutInstituteStudentsInput>
  }

  export type InstitutesCreateWithoutInstituteStudentsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesUncheckedCreateWithoutInstituteStudentsInput = {
    instituteId: string
    admin: string
    externalProviderUploads: boolean
    name: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedCreateNestedManyWithoutInstituteInput
    Cohorts?: CohortsUncheckedCreateNestedManyWithoutInstituteInput
    Forms?: InstituteFormsUncheckedCreateNestedManyWithoutInstituteInput
    InstituteStaff?: InstituteStaffUncheckedCreateNestedManyWithoutInstituteInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedCreateNestedManyWithoutInstituteInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutInstituteInput
  }

  export type InstitutesCreateOrConnectWithoutInstituteStudentsInput = {
    where: InstitutesWhereUniqueInput
    create: XOR<InstitutesCreateWithoutInstituteStudentsInput, InstitutesUncheckedCreateWithoutInstituteStudentsInput>
  }

  export type InstituteStudentUserGroupsCreateWithoutInstituteStudentsInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    institute: InstitutesCreateNestedOneWithoutStudentUserGroupsInput
    Placements?: PlacementsCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStudentUserGroupsUncheckedCreateWithoutInstituteStudentsInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    instituteId: string
    Placements?: PlacementsUncheckedCreateNestedManyWithoutUserGroupInput
  }

  export type InstituteStudentUserGroupsCreateOrConnectWithoutInstituteStudentsInput = {
    where: InstituteStudentUserGroupsWhereUniqueInput
    create: XOR<InstituteStudentUserGroupsCreateWithoutInstituteStudentsInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteStudentsInput>
  }

  export type PlacementsCreateWithoutInstituteStudentInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    Logs?: LogsCreateNestedManyWithoutPlacementInput
    address: AddressesCreateNestedOneWithoutPlacementsInput
    institute: InstitutesCreateNestedOneWithoutPlacementsInput
    provider: ProvidersCreateNestedOneWithoutPlacementsInput
    student: StudentUsersCreateNestedOneWithoutPlacementsInput
    userGroup: InstituteStudentUserGroupsCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementsUncheckedCreateWithoutInstituteStudentInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    providerId: string
    studentId: string
    userGroupId: string
    Logs?: LogsUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementsCreateOrConnectWithoutInstituteStudentInput = {
    where: PlacementsWhereUniqueInput
    create: XOR<PlacementsCreateWithoutInstituteStudentInput, PlacementsUncheckedCreateWithoutInstituteStudentInput>
  }

  export type PlacementsCreateManyInstituteStudentInputEnvelope = {
    data: PlacementsCreateManyInstituteStudentInput | PlacementsCreateManyInstituteStudentInput[]
    skipDuplicates?: boolean
  }

  export type ContactsUpsertWithWhereUniqueWithoutInstitutestudentUserInput = {
    where: ContactsWhereUniqueInput
    update: XOR<ContactsUpdateWithoutInstitutestudentUserInput, ContactsUncheckedUpdateWithoutInstitutestudentUserInput>
    create: XOR<ContactsCreateWithoutInstitutestudentUserInput, ContactsUncheckedCreateWithoutInstitutestudentUserInput>
  }

  export type ContactsUpdateWithWhereUniqueWithoutInstitutestudentUserInput = {
    where: ContactsWhereUniqueInput
    data: XOR<ContactsUpdateWithoutInstitutestudentUserInput, ContactsUncheckedUpdateWithoutInstitutestudentUserInput>
  }

  export type ContactsUpdateManyWithWhereWithoutInstitutestudentUserInput = {
    where: ContactsScalarWhereInput
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyWithoutInstitutestudentUserInput>
  }

  export type CohortsUpsertWithoutInstituteStudentsInput = {
    update: XOR<CohortsUpdateWithoutInstituteStudentsInput, CohortsUncheckedUpdateWithoutInstituteStudentsInput>
    create: XOR<CohortsCreateWithoutInstituteStudentsInput, CohortsUncheckedCreateWithoutInstituteStudentsInput>
    where?: CohortsWhereInput
  }

  export type CohortsUpdateToOneWithWhereWithoutInstituteStudentsInput = {
    where?: CohortsWhereInput
    data: XOR<CohortsUpdateWithoutInstituteStudentsInput, CohortsUncheckedUpdateWithoutInstituteStudentsInput>
  }

  export type CohortsUpdateWithoutInstituteStudentsInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutCohortsNestedInput
  }

  export type CohortsUncheckedUpdateWithoutInstituteStudentsInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type InstitutesUpsertWithoutInstituteStudentsInput = {
    update: XOR<InstitutesUpdateWithoutInstituteStudentsInput, InstitutesUncheckedUpdateWithoutInstituteStudentsInput>
    create: XOR<InstitutesCreateWithoutInstituteStudentsInput, InstitutesUncheckedCreateWithoutInstituteStudentsInput>
    where?: InstitutesWhereInput
  }

  export type InstitutesUpdateToOneWithWhereWithoutInstituteStudentsInput = {
    where?: InstitutesWhereInput
    data: XOR<InstitutesUpdateWithoutInstituteStudentsInput, InstitutesUncheckedUpdateWithoutInstituteStudentsInput>
  }

  export type InstitutesUpdateWithoutInstituteStudentsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteNestedInput
  }

  export type InstitutesUncheckedUpdateWithoutInstituteStudentsInput = {
    instituteId?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
    Addresses?: AddressesUncheckedUpdateManyWithoutInstituteNestedInput
    Cohorts?: CohortsUncheckedUpdateManyWithoutInstituteNestedInput
    Forms?: InstituteFormsUncheckedUpdateManyWithoutInstituteNestedInput
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutInstituteNestedInput
    StaffUserGroups?: InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    StudentUserGroups?: InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteNestedInput
  }

  export type InstituteStudentUserGroupsUpsertWithoutInstituteStudentsInput = {
    update: XOR<InstituteStudentUserGroupsUpdateWithoutInstituteStudentsInput, InstituteStudentUserGroupsUncheckedUpdateWithoutInstituteStudentsInput>
    create: XOR<InstituteStudentUserGroupsCreateWithoutInstituteStudentsInput, InstituteStudentUserGroupsUncheckedCreateWithoutInstituteStudentsInput>
    where?: InstituteStudentUserGroupsWhereInput
  }

  export type InstituteStudentUserGroupsUpdateToOneWithWhereWithoutInstituteStudentsInput = {
    where?: InstituteStudentUserGroupsWhereInput
    data: XOR<InstituteStudentUserGroupsUpdateWithoutInstituteStudentsInput, InstituteStudentUserGroupsUncheckedUpdateWithoutInstituteStudentsInput>
  }

  export type InstituteStudentUserGroupsUpdateWithoutInstituteStudentsInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutStudentUserGroupsNestedInput
    Placements?: PlacementsUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStudentUserGroupsUncheckedUpdateWithoutInstituteStudentsInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    Placements?: PlacementsUncheckedUpdateManyWithoutUserGroupNestedInput
  }

  export type PlacementsUpsertWithWhereUniqueWithoutInstituteStudentInput = {
    where: PlacementsWhereUniqueInput
    update: XOR<PlacementsUpdateWithoutInstituteStudentInput, PlacementsUncheckedUpdateWithoutInstituteStudentInput>
    create: XOR<PlacementsCreateWithoutInstituteStudentInput, PlacementsUncheckedCreateWithoutInstituteStudentInput>
  }

  export type PlacementsUpdateWithWhereUniqueWithoutInstituteStudentInput = {
    where: PlacementsWhereUniqueInput
    data: XOR<PlacementsUpdateWithoutInstituteStudentInput, PlacementsUncheckedUpdateWithoutInstituteStudentInput>
  }

  export type PlacementsUpdateManyWithWhereWithoutInstituteStudentInput = {
    where: PlacementsScalarWhereInput
    data: XOR<PlacementsUpdateManyMutationInput, PlacementsUncheckedUpdateManyWithoutInstituteStudentInput>
  }

  export type ProvidersCreateWithoutProviderStaffInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsCreateNestedManyWithoutProviderInput
    Placements?: PlacementsCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsCreateNestedManyWithoutProviderInput
  }

  export type ProvidersUncheckedCreateWithoutProviderStaffInput = {
    providerId: string
    contactForename: string
    contactSurname: string
    email: string
    mapConsent?: boolean | null
    insurance?: boolean | null
    mapConsentDate?: string | null
    name: string
    phone: string
    rememberConsent?: boolean | null
    rememberConsentDate?: string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector: string
    referral?: string | null
    subsector: string
    uploadedBy: string
    website?: string | null
    activationCode?: number
    status: string
    Addresses?: AddressesUncheckedCreateNestedManyWithoutProviderInput
    PlacementListings?: PlacementListingsUncheckedCreateNestedManyWithoutProviderInput
    Placements?: PlacementsUncheckedCreateNestedManyWithoutProviderInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedCreateNestedManyWithoutProviderInput
    ProviderCohorts?: ProviderCohortsUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProvidersCreateOrConnectWithoutProviderStaffInput = {
    where: ProvidersWhereUniqueInput
    create: XOR<ProvidersCreateWithoutProviderStaffInput, ProvidersUncheckedCreateWithoutProviderStaffInput>
  }

  export type ProviderUserGroupsCreateWithoutProviderStaffInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    provider: ProvidersCreateNestedOneWithoutProviderUserGroupsInput
  }

  export type ProviderUserGroupsUncheckedCreateWithoutProviderStaffInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
    providerId: string
  }

  export type ProviderUserGroupsCreateOrConnectWithoutProviderStaffInput = {
    where: ProviderUserGroupsWhereUniqueInput
    create: XOR<ProviderUserGroupsCreateWithoutProviderStaffInput, ProviderUserGroupsUncheckedCreateWithoutProviderStaffInput>
  }

  export type ProvidersUpsertWithoutProviderStaffInput = {
    update: XOR<ProvidersUpdateWithoutProviderStaffInput, ProvidersUncheckedUpdateWithoutProviderStaffInput>
    create: XOR<ProvidersCreateWithoutProviderStaffInput, ProvidersUncheckedCreateWithoutProviderStaffInput>
    where?: ProvidersWhereInput
  }

  export type ProvidersUpdateToOneWithWhereWithoutProviderStaffInput = {
    where?: ProvidersWhereInput
    data: XOR<ProvidersUpdateWithoutProviderStaffInput, ProvidersUncheckedUpdateWithoutProviderStaffInput>
  }

  export type ProvidersUpdateWithoutProviderStaffInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutProviderNestedInput
  }

  export type ProvidersUncheckedUpdateWithoutProviderStaffInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mapConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rememberConsentDate?: NullableStringFieldUpdateOperationsInput | string | null
    savedBy?: NullableJsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    activationCode?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    Addresses?: AddressesUncheckedUpdateManyWithoutProviderNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutProviderNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderUserGroups?: ProviderUserGroupsUncheckedUpdateManyWithoutProviderNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUserGroupsUpsertWithoutProviderStaffInput = {
    update: XOR<ProviderUserGroupsUpdateWithoutProviderStaffInput, ProviderUserGroupsUncheckedUpdateWithoutProviderStaffInput>
    create: XOR<ProviderUserGroupsCreateWithoutProviderStaffInput, ProviderUserGroupsUncheckedCreateWithoutProviderStaffInput>
    where?: ProviderUserGroupsWhereInput
  }

  export type ProviderUserGroupsUpdateToOneWithWhereWithoutProviderStaffInput = {
    where?: ProviderUserGroupsWhereInput
    data: XOR<ProviderUserGroupsUpdateWithoutProviderStaffInput, ProviderUserGroupsUncheckedUpdateWithoutProviderStaffInput>
  }

  export type ProviderUserGroupsUpdateWithoutProviderStaffInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    provider?: ProvidersUpdateOneRequiredWithoutProviderUserGroupsNestedInput
  }

  export type ProviderUserGroupsUncheckedUpdateWithoutProviderStaffInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type pointOfOriginCreateWithoutPotentialprovidersInput = {
    poid: string
    Name: string
    geoHash: string
  }

  export type pointOfOriginUncheckedCreateWithoutPotentialprovidersInput = {
    poid: string
    Name: string
    geoHash: string
  }

  export type pointOfOriginCreateOrConnectWithoutPotentialprovidersInput = {
    where: pointOfOriginWhereUniqueInput
    create: XOR<pointOfOriginCreateWithoutPotentialprovidersInput, pointOfOriginUncheckedCreateWithoutPotentialprovidersInput>
  }

  export type pointOfOriginUpsertWithoutPotentialprovidersInput = {
    update: XOR<pointOfOriginUpdateWithoutPotentialprovidersInput, pointOfOriginUncheckedUpdateWithoutPotentialprovidersInput>
    create: XOR<pointOfOriginCreateWithoutPotentialprovidersInput, pointOfOriginUncheckedCreateWithoutPotentialprovidersInput>
    where?: pointOfOriginWhereInput
  }

  export type pointOfOriginUpdateToOneWithWhereWithoutPotentialprovidersInput = {
    where?: pointOfOriginWhereInput
    data: XOR<pointOfOriginUpdateWithoutPotentialprovidersInput, pointOfOriginUncheckedUpdateWithoutPotentialprovidersInput>
  }

  export type pointOfOriginUpdateWithoutPotentialprovidersInput = {
    poid?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
  }

  export type pointOfOriginUncheckedUpdateWithoutPotentialprovidersInput = {
    poid?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
  }

  export type PotentialprovidersCreateWithoutPointOfOriginInput = {
    id: string
    types?: PotentialprovidersCreatetypesInput | string[]
    geoHash: string
    nationalPhoneNumber: string
    email?: PotentialprovidersCreateemailInput | string[]
    formattedAddress: string
    websiteUri: string
    name: string
  }

  export type PotentialprovidersUncheckedCreateWithoutPointOfOriginInput = {
    id: string
    types?: PotentialprovidersCreatetypesInput | string[]
    geoHash: string
    nationalPhoneNumber: string
    email?: PotentialprovidersCreateemailInput | string[]
    formattedAddress: string
    websiteUri: string
    name: string
  }

  export type PotentialprovidersCreateOrConnectWithoutPointOfOriginInput = {
    where: PotentialprovidersWhereUniqueInput
    create: XOR<PotentialprovidersCreateWithoutPointOfOriginInput, PotentialprovidersUncheckedCreateWithoutPointOfOriginInput>
  }

  export type PotentialprovidersCreateManyPointOfOriginInputEnvelope = {
    data: PotentialprovidersCreateManyPointOfOriginInput | PotentialprovidersCreateManyPointOfOriginInput[]
    skipDuplicates?: boolean
  }

  export type PotentialprovidersUpsertWithWhereUniqueWithoutPointOfOriginInput = {
    where: PotentialprovidersWhereUniqueInput
    update: XOR<PotentialprovidersUpdateWithoutPointOfOriginInput, PotentialprovidersUncheckedUpdateWithoutPointOfOriginInput>
    create: XOR<PotentialprovidersCreateWithoutPointOfOriginInput, PotentialprovidersUncheckedCreateWithoutPointOfOriginInput>
  }

  export type PotentialprovidersUpdateWithWhereUniqueWithoutPointOfOriginInput = {
    where: PotentialprovidersWhereUniqueInput
    data: XOR<PotentialprovidersUpdateWithoutPointOfOriginInput, PotentialprovidersUncheckedUpdateWithoutPointOfOriginInput>
  }

  export type PotentialprovidersUpdateManyWithWhereWithoutPointOfOriginInput = {
    where: PotentialprovidersScalarWhereInput
    data: XOR<PotentialprovidersUpdateManyMutationInput, PotentialprovidersUncheckedUpdateManyWithoutPointOfOriginInput>
  }

  export type PotentialprovidersScalarWhereInput = {
    AND?: PotentialprovidersScalarWhereInput | PotentialprovidersScalarWhereInput[]
    OR?: PotentialprovidersScalarWhereInput[]
    NOT?: PotentialprovidersScalarWhereInput | PotentialprovidersScalarWhereInput[]
    id?: StringFilter<"Potentialproviders"> | string
    types?: StringNullableListFilter<"Potentialproviders">
    geoHash?: StringFilter<"Potentialproviders"> | string
    nationalPhoneNumber?: StringFilter<"Potentialproviders"> | string
    email?: StringNullableListFilter<"Potentialproviders">
    formattedAddress?: StringFilter<"Potentialproviders"> | string
    websiteUri?: StringFilter<"Potentialproviders"> | string
    name?: StringFilter<"Potentialproviders"> | string
    poid?: StringFilter<"Potentialproviders"> | string
  }

  export type ContactsCreateManyAddressInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstituteStudentUserId: string
    studentUserId: string
  }

  export type PlacementListingsCreateManyAddressInput = {
    placementListingId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementsCreateManyAddressInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    userGroupId: string
  }

  export type ProviderCohortsCreateManyAddressInput = {
    cohortId: string
    stage: string
    name: string
    providerId: string
  }

  export type ContactsUpdateWithoutAddressInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstitutestudentUser?: InstituteStudentsUpdateOneRequiredWithoutContactsNestedInput
    studentUser?: StudentUsersUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactsUncheckedUpdateWithoutAddressInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstituteStudentUserId?: StringFieldUpdateOperationsInput | string
    studentUserId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsUncheckedUpdateManyWithoutAddressInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstituteStudentUserId?: StringFieldUpdateOperationsInput | string
    studentUserId?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsUpdateWithoutAddressInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    provider?: ProvidersUpdateOneRequiredWithoutPlacementListingsNestedInput
  }

  export type PlacementListingsUncheckedUpdateWithoutAddressInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsUncheckedUpdateManyWithoutAddressInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsUpdateWithoutAddressInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUpdateManyWithoutPlacementNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutPlacementsNestedInput
    instituteStudent?: InstituteStudentsUpdateOneRequiredWithoutPlacementsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutPlacementsNestedInput
    student?: StudentUsersUpdateOneRequiredWithoutPlacementsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementsUncheckedUpdateWithoutAddressInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementsUncheckedUpdateManyWithoutAddressInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCohortsUpdateWithoutAddressInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: ProvidersUpdateOneRequiredWithoutProviderCohortsNestedInput
  }

  export type ProviderCohortsUncheckedUpdateWithoutAddressInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCohortsUncheckedUpdateManyWithoutAddressInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsCreateManyCohortInput = {
    instituteStudentId: string
    activated: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    instituteId: string
    userGroupId: string
  }

  export type InstituteStudentsUpdateWithoutCohortInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUpdateManyWithoutInstitutestudentUserNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutInstituteStudentsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsUncheckedUpdateWithoutCohortInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUncheckedUpdateManyWithoutInstitutestudentUserNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsUncheckedUpdateManyWithoutCohortInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressesCreateManyInstituteInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    providerId?: string | null
  }

  export type CohortsCreateManyInstituteInput = {
    cohortId: string
    designatedStaff: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
  }

  export type InstituteFormsCreateManyInstituteInput = {
    formId: string
    form: JsonNullValueInput | InputJsonValue
    updated: string
  }

  export type InstituteStaffCreateManyInstituteInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    userGroupId: string
  }

  export type InstituteStaffUserGroupsCreateManyInstituteInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
  }

  export type InstituteStudentUserGroupsCreateManyInstituteInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
  }

  export type InstituteStudentsCreateManyInstituteInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    userGroupId: string
  }

  export type PlacementsCreateManyInstituteInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteStudentId: string
    providerId: string
    studentId: string
    userGroupId: string
  }

  export type AddressesUpdateWithoutInstituteInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: ProvidersUpdateOneWithoutAddressesNestedInput
    Contacts?: ContactsUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutInstituteInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    Contacts?: ContactsUncheckedUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateManyWithoutInstituteInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CohortsUpdateWithoutInstituteInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
    InstituteStudents?: InstituteStudentsUpdateManyWithoutCohortNestedInput
  }

  export type CohortsUncheckedUpdateWithoutInstituteInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutCohortNestedInput
  }

  export type CohortsUncheckedUpdateManyWithoutInstituteInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    designatedStaff?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteFormsUpdateWithoutInstituteInput = {
    formId?: StringFieldUpdateOperationsInput | string
    form?: JsonNullValueInput | InputJsonValue
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteFormsUncheckedUpdateWithoutInstituteInput = {
    formId?: StringFieldUpdateOperationsInput | string
    form?: JsonNullValueInput | InputJsonValue
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteFormsUncheckedUpdateManyWithoutInstituteInput = {
    formId?: StringFieldUpdateOperationsInput | string
    form?: JsonNullValueInput | InputJsonValue
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUpdateWithoutInstituteInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userGroup?: InstituteStaffUserGroupsUpdateOneRequiredWithoutInstituteStaffNestedInput
  }

  export type InstituteStaffUncheckedUpdateWithoutInstituteInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUncheckedUpdateManyWithoutInstituteInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUserGroupsUpdateWithoutInstituteInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    InstituteStaff?: InstituteStaffUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStaffUserGroupsUncheckedUpdateWithoutInstituteInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    InstituteStaff?: InstituteStaffUncheckedUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStaffUserGroupsUncheckedUpdateManyWithoutInstituteInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentUserGroupsUpdateWithoutInstituteInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    InstituteStudents?: InstituteStudentsUpdateManyWithoutUserGroupNestedInput
    Placements?: PlacementsUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStudentUserGroupsUncheckedUpdateWithoutInstituteInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    InstituteStudents?: InstituteStudentsUncheckedUpdateManyWithoutUserGroupNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutUserGroupNestedInput
  }

  export type InstituteStudentUserGroupsUncheckedUpdateManyWithoutInstituteInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsUpdateWithoutInstituteInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUpdateManyWithoutInstitutestudentUserNestedInput
    cohort?: CohortsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsUncheckedUpdateWithoutInstituteInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUncheckedUpdateManyWithoutInstitutestudentUserNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsUncheckedUpdateManyWithoutInstituteInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsUpdateWithoutInstituteInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUpdateManyWithoutPlacementNestedInput
    address?: AddressesUpdateOneRequiredWithoutPlacementsNestedInput
    instituteStudent?: InstituteStudentsUpdateOneRequiredWithoutPlacementsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutPlacementsNestedInput
    student?: StudentUsersUpdateOneRequiredWithoutPlacementsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementsUncheckedUpdateWithoutInstituteInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementsUncheckedUpdateManyWithoutInstituteInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type LogsCreateManyPlacementInput = {
    logId: string
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
  }

  export type LogsUpdateWithoutPlacementInput = {
    logId?: StringFieldUpdateOperationsInput | string
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type LogsUncheckedUpdateWithoutPlacementInput = {
    logId?: StringFieldUpdateOperationsInput | string
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type LogsUncheckedUpdateManyWithoutPlacementInput = {
    logId?: StringFieldUpdateOperationsInput | string
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type AddressesCreateManyProviderInput = {
    addressId: string
    name: string
    stage?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    contactForename?: string | null
    contactSurname?: string | null
    country?: string | null
    email?: string | null
    geoHash?: string | null
    locality?: string | null
    phone?: string | null
    postal_code?: string | null
    instituteId?: string | null
  }

  export type PlacementListingsCreateManyProviderInput = {
    placementListingId: string
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementsCreateManyProviderInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    studentId: string
    userGroupId: string
  }

  export type ProviderStaffCreateManyProviderInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userGroupId: string
  }

  export type ProviderUserGroupsCreateManyProviderInput = {
    userGroupId: string
    default: boolean
    name: string
    updated: string
  }

  export type ProviderCohortsCreateManyProviderInput = {
    cohortId: string
    stage: string
    name: string
    addressId: string
  }

  export type AddressesUpdateWithoutProviderInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    institute?: InstitutesUpdateOneWithoutAddressesNestedInput
    Contacts?: ContactsUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateWithoutProviderInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: NullableStringFieldUpdateOperationsInput | string | null
    Contacts?: ContactsUncheckedUpdateManyWithoutAddressNestedInput
    PlacementListings?: PlacementListingsUncheckedUpdateManyWithoutAddressNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutAddressNestedInput
    ProviderCohorts?: ProviderCohortsUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressesUncheckedUpdateManyWithoutProviderInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    contactForename?: NullableStringFieldUpdateOperationsInput | string | null
    contactSurname?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    geoHash?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlacementListingsUpdateWithoutProviderInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    address?: AddressesUpdateOneRequiredWithoutPlacementListingsNestedInput
  }

  export type PlacementListingsUncheckedUpdateWithoutProviderInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsUncheckedUpdateManyWithoutProviderInput = {
    placementListingId?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsUpdateWithoutProviderInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUpdateManyWithoutPlacementNestedInput
    address?: AddressesUpdateOneRequiredWithoutPlacementsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutPlacementsNestedInput
    instituteStudent?: InstituteStudentsUpdateOneRequiredWithoutPlacementsNestedInput
    student?: StudentUsersUpdateOneRequiredWithoutPlacementsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementsUncheckedUpdateWithoutProviderInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementsUncheckedUpdateManyWithoutProviderInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffUpdateWithoutProviderInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: ProviderUserGroupsUpdateOneRequiredWithoutProviderStaffNestedInput
  }

  export type ProviderStaffUncheckedUpdateWithoutProviderInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffUncheckedUpdateManyWithoutProviderInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderUserGroupsUpdateWithoutProviderInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    ProviderStaff?: ProviderStaffUpdateManyWithoutUserGroupNestedInput
  }

  export type ProviderUserGroupsUncheckedUpdateWithoutProviderInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
    ProviderStaff?: ProviderStaffUncheckedUpdateManyWithoutUserGroupNestedInput
  }

  export type ProviderUserGroupsUncheckedUpdateManyWithoutProviderInput = {
    userGroupId?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCohortsUpdateWithoutProviderInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressesUpdateOneRequiredWithoutProviderCohortsNestedInput
  }

  export type ProviderCohortsUncheckedUpdateWithoutProviderInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCohortsUncheckedUpdateManyWithoutProviderInput = {
    cohortId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsCreateManyUserGroupInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: string
    resetExpiry: Date | string
    status: string
    userType: string
    instituteId: string
  }

  export type PlacementsCreateManyUserGroupInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    studentId: string
  }

  export type InstituteStudentsUpdateWithoutUserGroupInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUpdateManyWithoutInstitutestudentUserNestedInput
    cohort?: CohortsUpdateOneRequiredWithoutInstituteStudentsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutInstituteStudentsNestedInput
    Placements?: PlacementsUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsUncheckedUpdateWithoutUserGroupInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    Contacts?: ContactsUncheckedUpdateManyWithoutInstitutestudentUserNestedInput
    Placements?: PlacementsUncheckedUpdateManyWithoutInstituteStudentNestedInput
  }

  export type InstituteStudentsUncheckedUpdateManyWithoutUserGroupInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: StringFieldUpdateOperationsInput | string
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsUpdateWithoutUserGroupInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUpdateManyWithoutPlacementNestedInput
    address?: AddressesUpdateOneRequiredWithoutPlacementsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutPlacementsNestedInput
    instituteStudent?: InstituteStudentsUpdateOneRequiredWithoutPlacementsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutPlacementsNestedInput
    student?: StudentUsersUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementsUncheckedUpdateWithoutUserGroupInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementsUncheckedUpdateManyWithoutUserGroupInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffCreateManyUserGroupInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userType: string
    instituteId: string
  }

  export type InstituteStaffUpdateWithoutUserGroupInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    institute?: InstitutesUpdateOneRequiredWithoutInstituteStaffNestedInput
  }

  export type InstituteStaffUncheckedUpdateWithoutUserGroupInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUncheckedUpdateManyWithoutUserGroupInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffCreateManyUserGroupInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status: string
    providerId: string
  }

  export type ProviderStaffUpdateWithoutUserGroupInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    provider?: ProvidersUpdateOneRequiredWithoutProviderStaffNestedInput
  }

  export type ProviderStaffUncheckedUpdateWithoutUserGroupInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffUncheckedUpdateManyWithoutUserGroupInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    notes?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsCreateManyStudentUserInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    InstituteStudentUserId: string
    addressId: string
  }

  export type PlacementsCreateManyStudentInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    instituteStudentId: string
    providerId: string
    userGroupId: string
  }

  export type ContactsUpdateWithoutStudentUserInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstitutestudentUser?: InstituteStudentsUpdateOneRequiredWithoutContactsNestedInput
    address?: AddressesUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactsUncheckedUpdateWithoutStudentUserInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstituteStudentUserId?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsUncheckedUpdateManyWithoutStudentUserInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    InstituteStudentUserId?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsUpdateWithoutStudentInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUpdateManyWithoutPlacementNestedInput
    address?: AddressesUpdateOneRequiredWithoutPlacementsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutPlacementsNestedInput
    instituteStudent?: InstituteStudentsUpdateOneRequiredWithoutPlacementsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutPlacementsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementsUncheckedUpdateWithoutStudentInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementsUncheckedUpdateManyWithoutStudentInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsCreateManyInstitutestudentUserInput = {
    contactId: string
    contactForename: string
    contactSurname: string
    created: string
    name: string
    providerPhone: string
    addressId: string
    studentUserId: string
  }

  export type PlacementsCreateManyInstituteStudentInput = {
    placementId: string
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    cohortId: string
    contactForename: string
    contactSurname: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    name: string
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    addressId: string
    instituteId: string
    providerId: string
    studentId: string
    userGroupId: string
  }

  export type ContactsUpdateWithoutInstitutestudentUserInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    address?: AddressesUpdateOneRequiredWithoutContactsNestedInput
    studentUser?: StudentUsersUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactsUncheckedUpdateWithoutInstitutestudentUserInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    studentUserId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsUncheckedUpdateManyWithoutInstitutestudentUserInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    studentUserId?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsUpdateWithoutInstituteStudentInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUpdateManyWithoutPlacementNestedInput
    address?: AddressesUpdateOneRequiredWithoutPlacementsNestedInput
    institute?: InstitutesUpdateOneRequiredWithoutPlacementsNestedInput
    provider?: ProvidersUpdateOneRequiredWithoutPlacementsNestedInput
    student?: StudentUsersUpdateOneRequiredWithoutPlacementsNestedInput
    userGroup?: InstituteStudentUserGroupsUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementsUncheckedUpdateWithoutInstituteStudentInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
    Logs?: LogsUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementsUncheckedUpdateManyWithoutInstituteStudentInput = {
    placementId?: StringFieldUpdateOperationsInput | string
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    cohortId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userGroupId?: StringFieldUpdateOperationsInput | string
  }

  export type PotentialprovidersCreateManyPointOfOriginInput = {
    id: string
    types?: PotentialprovidersCreatetypesInput | string[]
    geoHash: string
    nationalPhoneNumber: string
    email?: PotentialprovidersCreateemailInput | string[]
    formattedAddress: string
    websiteUri: string
    name: string
  }

  export type PotentialprovidersUpdateWithoutPointOfOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    types?: PotentialprovidersUpdatetypesInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    nationalPhoneNumber?: StringFieldUpdateOperationsInput | string
    email?: PotentialprovidersUpdateemailInput | string[]
    formattedAddress?: StringFieldUpdateOperationsInput | string
    websiteUri?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PotentialprovidersUncheckedUpdateWithoutPointOfOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    types?: PotentialprovidersUpdatetypesInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    nationalPhoneNumber?: StringFieldUpdateOperationsInput | string
    email?: PotentialprovidersUpdateemailInput | string[]
    formattedAddress?: StringFieldUpdateOperationsInput | string
    websiteUri?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PotentialprovidersUncheckedUpdateManyWithoutPointOfOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    types?: PotentialprovidersUpdatetypesInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    nationalPhoneNumber?: StringFieldUpdateOperationsInput | string
    email?: PotentialprovidersUpdateemailInput | string[]
    formattedAddress?: StringFieldUpdateOperationsInput | string
    websiteUri?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AddressesCountOutputTypeDefaultArgs instead
     */
    export type AddressesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CohortsCountOutputTypeDefaultArgs instead
     */
    export type CohortsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CohortsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstitutesCountOutputTypeDefaultArgs instead
     */
    export type InstitutesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstitutesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlacementsCountOutputTypeDefaultArgs instead
     */
    export type PlacementsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlacementsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProvidersCountOutputTypeDefaultArgs instead
     */
    export type ProvidersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProvidersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStudentUserGroupsCountOutputTypeDefaultArgs instead
     */
    export type InstituteStudentUserGroupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStudentUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStaffUserGroupsCountOutputTypeDefaultArgs instead
     */
    export type InstituteStaffUserGroupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStaffUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderUserGroupsCountOutputTypeDefaultArgs instead
     */
    export type ProviderUserGroupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderUserGroupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentUsersCountOutputTypeDefaultArgs instead
     */
    export type StudentUsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentUsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStudentsCountOutputTypeDefaultArgs instead
     */
    export type InstituteStudentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStudentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PointOfOriginCountOutputTypeDefaultArgs instead
     */
    export type PointOfOriginCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PointOfOriginCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressesDefaultArgs instead
     */
    export type AddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CohortsDefaultArgs instead
     */
    export type CohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CohortsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderCohortsDefaultArgs instead
     */
    export type ProviderCohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderCohortsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactsDefaultArgs instead
     */
    export type ContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteFormsDefaultArgs instead
     */
    export type InstituteFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteFormsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstitutesDefaultArgs instead
     */
    export type InstitutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstitutesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogsDefaultArgs instead
     */
    export type LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlacementListingsDefaultArgs instead
     */
    export type PlacementListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlacementListingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlacementsDefaultArgs instead
     */
    export type PlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlacementsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProvidersDefaultArgs instead
     */
    export type ProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProvidersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStudentUserGroupsDefaultArgs instead
     */
    export type InstituteStudentUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStudentUserGroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStaffUserGroupsDefaultArgs instead
     */
    export type InstituteStaffUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStaffUserGroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderUserGroupsDefaultArgs instead
     */
    export type ProviderUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderUserGroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentUsersDefaultArgs instead
     */
    export type StudentUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentUsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStaffDefaultArgs instead
     */
    export type InstituteStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStudentsDefaultArgs instead
     */
    export type InstituteStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStudentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderStaffDefaultArgs instead
     */
    export type ProviderStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderStaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PotentialprovidersDefaultArgs instead
     */
    export type PotentialprovidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PotentialprovidersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pointOfOriginDefaultArgs instead
     */
    export type pointOfOriginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pointOfOriginDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}