
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Addresses
 * 
 */
export type Addresses = $Result.DefaultSelection<Prisma.$AddressesPayload>
/**
 * Model Blogs
 * 
 */
export type Blogs = $Result.DefaultSelection<Prisma.$BlogsPayload>
/**
 * Model BugReports
 * 
 */
export type BugReports = $Result.DefaultSelection<Prisma.$BugReportsPayload>
/**
 * Model BusinessInterest
 * 
 */
export type BusinessInterest = $Result.DefaultSelection<Prisma.$BusinessInterestPayload>
/**
 * Model Cohorts
 * 
 */
export type Cohorts = $Result.DefaultSelection<Prisma.$CohortsPayload>
/**
 * Model Contacts
 * 
 */
export type Contacts = $Result.DefaultSelection<Prisma.$ContactsPayload>
/**
 * Model Downtime
 * 
 */
export type Downtime = $Result.DefaultSelection<Prisma.$DowntimePayload>
/**
 * Model FeatureRequests
 * 
 */
export type FeatureRequests = $Result.DefaultSelection<Prisma.$FeatureRequestsPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Forms
 * 
 */
export type Forms = $Result.DefaultSelection<Prisma.$FormsPayload>
/**
 * Model Institutes
 * 
 */
export type Institutes = $Result.DefaultSelection<Prisma.$InstitutesPayload>
/**
 * Model Jobs
 * 
 */
export type Jobs = $Result.DefaultSelection<Prisma.$JobsPayload>
/**
 * Model Logs
 * 
 */
export type Logs = $Result.DefaultSelection<Prisma.$LogsPayload>
/**
 * Model PlacementListings
 * 
 */
export type PlacementListings = $Result.DefaultSelection<Prisma.$PlacementListingsPayload>
/**
 * Model Placements
 * 
 */
export type Placements = $Result.DefaultSelection<Prisma.$PlacementsPayload>
/**
 * Model Providers
 * 
 */
export type Providers = $Result.DefaultSelection<Prisma.$ProvidersPayload>
/**
 * Model Referrals
 * 
 */
export type Referrals = $Result.DefaultSelection<Prisma.$ReferralsPayload>
/**
 * Model UserGroups
 * 
 */
export type UserGroups = $Result.DefaultSelection<Prisma.$UserGroupsPayload>
/**
 * Model StudentUsers
 * 
 */
export type StudentUsers = $Result.DefaultSelection<Prisma.$StudentUsersPayload>
/**
 * Model InstituteStaff
 * 
 */
export type InstituteStaff = $Result.DefaultSelection<Prisma.$InstituteStaffPayload>
/**
 * Model InstituteStudents
 * 
 */
export type InstituteStudents = $Result.DefaultSelection<Prisma.$InstituteStudentsPayload>
/**
 * Model ProviderStaff
 * 
 */
export type ProviderStaff = $Result.DefaultSelection<Prisma.$ProviderStaffPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Addresses
 * const addresses = await prisma.addresses.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Addresses
   * const addresses = await prisma.addresses.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.addresses`: Exposes CRUD operations for the **Addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.addresses.findMany()
    * ```
    */
  get addresses(): Prisma.AddressesDelegate<ExtArgs>;

  /**
   * `prisma.blogs`: Exposes CRUD operations for the **Blogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blogs.findMany()
    * ```
    */
  get blogs(): Prisma.BlogsDelegate<ExtArgs>;

  /**
   * `prisma.bugReports`: Exposes CRUD operations for the **BugReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BugReports
    * const bugReports = await prisma.bugReports.findMany()
    * ```
    */
  get bugReports(): Prisma.BugReportsDelegate<ExtArgs>;

  /**
   * `prisma.businessInterest`: Exposes CRUD operations for the **BusinessInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessInterests
    * const businessInterests = await prisma.businessInterest.findMany()
    * ```
    */
  get businessInterest(): Prisma.BusinessInterestDelegate<ExtArgs>;

  /**
   * `prisma.cohorts`: Exposes CRUD operations for the **Cohorts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cohorts
    * const cohorts = await prisma.cohorts.findMany()
    * ```
    */
  get cohorts(): Prisma.CohortsDelegate<ExtArgs>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **Contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.ContactsDelegate<ExtArgs>;

  /**
   * `prisma.downtime`: Exposes CRUD operations for the **Downtime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Downtimes
    * const downtimes = await prisma.downtime.findMany()
    * ```
    */
  get downtime(): Prisma.DowntimeDelegate<ExtArgs>;

  /**
   * `prisma.featureRequests`: Exposes CRUD operations for the **FeatureRequests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureRequests
    * const featureRequests = await prisma.featureRequests.findMany()
    * ```
    */
  get featureRequests(): Prisma.FeatureRequestsDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.forms`: Exposes CRUD operations for the **Forms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.forms.findMany()
    * ```
    */
  get forms(): Prisma.FormsDelegate<ExtArgs>;

  /**
   * `prisma.institutes`: Exposes CRUD operations for the **Institutes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutes
    * const institutes = await prisma.institutes.findMany()
    * ```
    */
  get institutes(): Prisma.InstitutesDelegate<ExtArgs>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **Jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.JobsDelegate<ExtArgs>;

  /**
   * `prisma.logs`: Exposes CRUD operations for the **Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.LogsDelegate<ExtArgs>;

  /**
   * `prisma.placementListings`: Exposes CRUD operations for the **PlacementListings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlacementListings
    * const placementListings = await prisma.placementListings.findMany()
    * ```
    */
  get placementListings(): Prisma.PlacementListingsDelegate<ExtArgs>;

  /**
   * `prisma.placements`: Exposes CRUD operations for the **Placements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Placements
    * const placements = await prisma.placements.findMany()
    * ```
    */
  get placements(): Prisma.PlacementsDelegate<ExtArgs>;

  /**
   * `prisma.providers`: Exposes CRUD operations for the **Providers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.providers.findMany()
    * ```
    */
  get providers(): Prisma.ProvidersDelegate<ExtArgs>;

  /**
   * `prisma.referrals`: Exposes CRUD operations for the **Referrals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referrals.findMany()
    * ```
    */
  get referrals(): Prisma.ReferralsDelegate<ExtArgs>;

  /**
   * `prisma.userGroups`: Exposes CRUD operations for the **UserGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroups
    * const userGroups = await prisma.userGroups.findMany()
    * ```
    */
  get userGroups(): Prisma.UserGroupsDelegate<ExtArgs>;

  /**
   * `prisma.studentUsers`: Exposes CRUD operations for the **StudentUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentUsers
    * const studentUsers = await prisma.studentUsers.findMany()
    * ```
    */
  get studentUsers(): Prisma.StudentUsersDelegate<ExtArgs>;

  /**
   * `prisma.instituteStaff`: Exposes CRUD operations for the **InstituteStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstituteStaffs
    * const instituteStaffs = await prisma.instituteStaff.findMany()
    * ```
    */
  get instituteStaff(): Prisma.InstituteStaffDelegate<ExtArgs>;

  /**
   * `prisma.instituteStudents`: Exposes CRUD operations for the **InstituteStudents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstituteStudents
    * const instituteStudents = await prisma.instituteStudents.findMany()
    * ```
    */
  get instituteStudents(): Prisma.InstituteStudentsDelegate<ExtArgs>;

  /**
   * `prisma.providerStaff`: Exposes CRUD operations for the **ProviderStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderStaffs
    * const providerStaffs = await prisma.providerStaff.findMany()
    * ```
    */
  get providerStaff(): Prisma.ProviderStaffDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.0
   * Query Engine version: 0a83d8541752d7582de2ebc1ece46519ce72a848
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Addresses: 'Addresses',
    Blogs: 'Blogs',
    BugReports: 'BugReports',
    BusinessInterest: 'BusinessInterest',
    Cohorts: 'Cohorts',
    Contacts: 'Contacts',
    Downtime: 'Downtime',
    FeatureRequests: 'FeatureRequests',
    Feedback: 'Feedback',
    Forms: 'Forms',
    Institutes: 'Institutes',
    Jobs: 'Jobs',
    Logs: 'Logs',
    PlacementListings: 'PlacementListings',
    Placements: 'Placements',
    Providers: 'Providers',
    Referrals: 'Referrals',
    UserGroups: 'UserGroups',
    StudentUsers: 'StudentUsers',
    InstituteStaff: 'InstituteStaff',
    InstituteStudents: 'InstituteStudents',
    ProviderStaff: 'ProviderStaff'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'addresses' | 'blogs' | 'bugReports' | 'businessInterest' | 'cohorts' | 'contacts' | 'downtime' | 'featureRequests' | 'feedback' | 'forms' | 'institutes' | 'jobs' | 'logs' | 'placementListings' | 'placements' | 'providers' | 'referrals' | 'userGroups' | 'studentUsers' | 'instituteStaff' | 'instituteStudents' | 'providerStaff'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Addresses: {
        payload: Prisma.$AddressesPayload<ExtArgs>
        fields: Prisma.AddressesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          findFirst: {
            args: Prisma.AddressesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          findMany: {
            args: Prisma.AddressesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>[]
          }
          create: {
            args: Prisma.AddressesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          createMany: {
            args: Prisma.AddressesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddressesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          update: {
            args: Prisma.AddressesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          deleteMany: {
            args: Prisma.AddressesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddressesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddressesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressesPayload>
          }
          aggregate: {
            args: Prisma.AddressesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddresses>
          }
          groupBy: {
            args: Prisma.AddressesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressesCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressesCountAggregateOutputType> | number
          }
        }
      }
      Blogs: {
        payload: Prisma.$BlogsPayload<ExtArgs>
        fields: Prisma.BlogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload>
          }
          findFirst: {
            args: Prisma.BlogsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload>
          }
          findMany: {
            args: Prisma.BlogsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload>[]
          }
          create: {
            args: Prisma.BlogsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload>
          }
          createMany: {
            args: Prisma.BlogsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlogsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload>
          }
          update: {
            args: Prisma.BlogsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload>
          }
          deleteMany: {
            args: Prisma.BlogsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlogsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlogsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogsPayload>
          }
          aggregate: {
            args: Prisma.BlogsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlogs>
          }
          groupBy: {
            args: Prisma.BlogsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogsCountArgs<ExtArgs>,
            result: $Utils.Optional<BlogsCountAggregateOutputType> | number
          }
        }
      }
      BugReports: {
        payload: Prisma.$BugReportsPayload<ExtArgs>
        fields: Prisma.BugReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BugReportsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BugReportsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload>
          }
          findFirst: {
            args: Prisma.BugReportsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BugReportsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload>
          }
          findMany: {
            args: Prisma.BugReportsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload>[]
          }
          create: {
            args: Prisma.BugReportsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload>
          }
          createMany: {
            args: Prisma.BugReportsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BugReportsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload>
          }
          update: {
            args: Prisma.BugReportsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload>
          }
          deleteMany: {
            args: Prisma.BugReportsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BugReportsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BugReportsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BugReportsPayload>
          }
          aggregate: {
            args: Prisma.BugReportsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBugReports>
          }
          groupBy: {
            args: Prisma.BugReportsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BugReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BugReportsCountArgs<ExtArgs>,
            result: $Utils.Optional<BugReportsCountAggregateOutputType> | number
          }
        }
      }
      BusinessInterest: {
        payload: Prisma.$BusinessInterestPayload<ExtArgs>
        fields: Prisma.BusinessInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessInterestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessInterestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload>
          }
          findFirst: {
            args: Prisma.BusinessInterestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessInterestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload>
          }
          findMany: {
            args: Prisma.BusinessInterestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload>[]
          }
          create: {
            args: Prisma.BusinessInterestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload>
          }
          createMany: {
            args: Prisma.BusinessInterestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BusinessInterestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload>
          }
          update: {
            args: Prisma.BusinessInterestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload>
          }
          deleteMany: {
            args: Prisma.BusinessInterestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessInterestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BusinessInterestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BusinessInterestPayload>
          }
          aggregate: {
            args: Prisma.BusinessInterestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusinessInterest>
          }
          groupBy: {
            args: Prisma.BusinessInterestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusinessInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessInterestCountArgs<ExtArgs>,
            result: $Utils.Optional<BusinessInterestCountAggregateOutputType> | number
          }
        }
      }
      Cohorts: {
        payload: Prisma.$CohortsPayload<ExtArgs>
        fields: Prisma.CohortsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CohortsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CohortsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          findFirst: {
            args: Prisma.CohortsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CohortsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          findMany: {
            args: Prisma.CohortsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>[]
          }
          create: {
            args: Prisma.CohortsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          createMany: {
            args: Prisma.CohortsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CohortsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          update: {
            args: Prisma.CohortsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          deleteMany: {
            args: Prisma.CohortsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CohortsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CohortsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CohortsPayload>
          }
          aggregate: {
            args: Prisma.CohortsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCohorts>
          }
          groupBy: {
            args: Prisma.CohortsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CohortsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CohortsCountArgs<ExtArgs>,
            result: $Utils.Optional<CohortsCountAggregateOutputType> | number
          }
        }
      }
      Contacts: {
        payload: Prisma.$ContactsPayload<ExtArgs>
        fields: Prisma.ContactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findFirst: {
            args: Prisma.ContactsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findMany: {
            args: Prisma.ContactsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          create: {
            args: Prisma.ContactsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          createMany: {
            args: Prisma.ContactsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContactsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          update: {
            args: Prisma.ContactsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          deleteMany: {
            args: Prisma.ContactsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.ContactsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      Downtime: {
        payload: Prisma.$DowntimePayload<ExtArgs>
        fields: Prisma.DowntimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DowntimeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DowntimeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload>
          }
          findFirst: {
            args: Prisma.DowntimeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DowntimeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload>
          }
          findMany: {
            args: Prisma.DowntimeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload>[]
          }
          create: {
            args: Prisma.DowntimeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload>
          }
          createMany: {
            args: Prisma.DowntimeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DowntimeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload>
          }
          update: {
            args: Prisma.DowntimeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload>
          }
          deleteMany: {
            args: Prisma.DowntimeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DowntimeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DowntimeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DowntimePayload>
          }
          aggregate: {
            args: Prisma.DowntimeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDowntime>
          }
          groupBy: {
            args: Prisma.DowntimeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DowntimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DowntimeCountArgs<ExtArgs>,
            result: $Utils.Optional<DowntimeCountAggregateOutputType> | number
          }
        }
      }
      FeatureRequests: {
        payload: Prisma.$FeatureRequestsPayload<ExtArgs>
        fields: Prisma.FeatureRequestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureRequestsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureRequestsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload>
          }
          findFirst: {
            args: Prisma.FeatureRequestsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureRequestsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload>
          }
          findMany: {
            args: Prisma.FeatureRequestsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload>[]
          }
          create: {
            args: Prisma.FeatureRequestsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload>
          }
          createMany: {
            args: Prisma.FeatureRequestsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeatureRequestsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload>
          }
          update: {
            args: Prisma.FeatureRequestsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload>
          }
          deleteMany: {
            args: Prisma.FeatureRequestsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureRequestsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeatureRequestsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeatureRequestsPayload>
          }
          aggregate: {
            args: Prisma.FeatureRequestsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeatureRequests>
          }
          groupBy: {
            args: Prisma.FeatureRequestsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeatureRequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureRequestsCountArgs<ExtArgs>,
            result: $Utils.Optional<FeatureRequestsCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Forms: {
        payload: Prisma.$FormsPayload<ExtArgs>
        fields: Prisma.FormsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload>
          }
          findFirst: {
            args: Prisma.FormsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload>
          }
          findMany: {
            args: Prisma.FormsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload>[]
          }
          create: {
            args: Prisma.FormsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload>
          }
          createMany: {
            args: Prisma.FormsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload>
          }
          update: {
            args: Prisma.FormsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload>
          }
          deleteMany: {
            args: Prisma.FormsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormsPayload>
          }
          aggregate: {
            args: Prisma.FormsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateForms>
          }
          groupBy: {
            args: Prisma.FormsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormsCountArgs<ExtArgs>,
            result: $Utils.Optional<FormsCountAggregateOutputType> | number
          }
        }
      }
      Institutes: {
        payload: Prisma.$InstitutesPayload<ExtArgs>
        fields: Prisma.InstitutesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          findFirst: {
            args: Prisma.InstitutesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          findMany: {
            args: Prisma.InstitutesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>[]
          }
          create: {
            args: Prisma.InstitutesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          createMany: {
            args: Prisma.InstitutesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstitutesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          update: {
            args: Prisma.InstitutesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          deleteMany: {
            args: Prisma.InstitutesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstitutesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstitutesPayload>
          }
          aggregate: {
            args: Prisma.InstitutesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstitutes>
          }
          groupBy: {
            args: Prisma.InstitutesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstitutesGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutesCountArgs<ExtArgs>,
            result: $Utils.Optional<InstitutesCountAggregateOutputType> | number
          }
        }
      }
      Jobs: {
        payload: Prisma.$JobsPayload<ExtArgs>
        fields: Prisma.JobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findFirst: {
            args: Prisma.JobsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findMany: {
            args: Prisma.JobsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[]
          }
          create: {
            args: Prisma.JobsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          createMany: {
            args: Prisma.JobsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          update: {
            args: Prisma.JobsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          deleteMany: {
            args: Prisma.JobsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.JobsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobsCountArgs<ExtArgs>,
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      Logs: {
        payload: Prisma.$LogsPayload<ExtArgs>
        fields: Prisma.LogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findFirst: {
            args: Prisma.LogsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findMany: {
            args: Prisma.LogsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          create: {
            args: Prisma.LogsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          createMany: {
            args: Prisma.LogsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          update: {
            args: Prisma.LogsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          deleteMany: {
            args: Prisma.LogsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          aggregate: {
            args: Prisma.LogsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogs>
          }
          groupBy: {
            args: Prisma.LogsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogsCountArgs<ExtArgs>,
            result: $Utils.Optional<LogsCountAggregateOutputType> | number
          }
        }
      }
      PlacementListings: {
        payload: Prisma.$PlacementListingsPayload<ExtArgs>
        fields: Prisma.PlacementListingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlacementListingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlacementListingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          findFirst: {
            args: Prisma.PlacementListingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlacementListingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          findMany: {
            args: Prisma.PlacementListingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>[]
          }
          create: {
            args: Prisma.PlacementListingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          createMany: {
            args: Prisma.PlacementListingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlacementListingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          update: {
            args: Prisma.PlacementListingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          deleteMany: {
            args: Prisma.PlacementListingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlacementListingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlacementListingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementListingsPayload>
          }
          aggregate: {
            args: Prisma.PlacementListingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlacementListings>
          }
          groupBy: {
            args: Prisma.PlacementListingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlacementListingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlacementListingsCountArgs<ExtArgs>,
            result: $Utils.Optional<PlacementListingsCountAggregateOutputType> | number
          }
        }
      }
      Placements: {
        payload: Prisma.$PlacementsPayload<ExtArgs>
        fields: Prisma.PlacementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlacementsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlacementsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          findFirst: {
            args: Prisma.PlacementsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlacementsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          findMany: {
            args: Prisma.PlacementsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>[]
          }
          create: {
            args: Prisma.PlacementsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          createMany: {
            args: Prisma.PlacementsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlacementsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          update: {
            args: Prisma.PlacementsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          deleteMany: {
            args: Prisma.PlacementsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlacementsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlacementsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlacementsPayload>
          }
          aggregate: {
            args: Prisma.PlacementsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlacements>
          }
          groupBy: {
            args: Prisma.PlacementsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlacementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlacementsCountArgs<ExtArgs>,
            result: $Utils.Optional<PlacementsCountAggregateOutputType> | number
          }
        }
      }
      Providers: {
        payload: Prisma.$ProvidersPayload<ExtArgs>
        fields: Prisma.ProvidersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvidersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvidersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          findFirst: {
            args: Prisma.ProvidersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvidersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          findMany: {
            args: Prisma.ProvidersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>[]
          }
          create: {
            args: Prisma.ProvidersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          createMany: {
            args: Prisma.ProvidersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProvidersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          update: {
            args: Prisma.ProvidersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          deleteMany: {
            args: Prisma.ProvidersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProvidersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProvidersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProvidersPayload>
          }
          aggregate: {
            args: Prisma.ProvidersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProviders>
          }
          groupBy: {
            args: Prisma.ProvidersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProvidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvidersCountArgs<ExtArgs>,
            result: $Utils.Optional<ProvidersCountAggregateOutputType> | number
          }
        }
      }
      Referrals: {
        payload: Prisma.$ReferralsPayload<ExtArgs>
        fields: Prisma.ReferralsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          findFirst: {
            args: Prisma.ReferralsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          findMany: {
            args: Prisma.ReferralsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>[]
          }
          create: {
            args: Prisma.ReferralsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          createMany: {
            args: Prisma.ReferralsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReferralsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          update: {
            args: Prisma.ReferralsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          deleteMany: {
            args: Prisma.ReferralsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReferralsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          aggregate: {
            args: Prisma.ReferralsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReferrals>
          }
          groupBy: {
            args: Prisma.ReferralsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReferralsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralsCountArgs<ExtArgs>,
            result: $Utils.Optional<ReferralsCountAggregateOutputType> | number
          }
        }
      }
      UserGroups: {
        payload: Prisma.$UserGroupsPayload<ExtArgs>
        fields: Prisma.UserGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGroupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGroupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload>
          }
          findFirst: {
            args: Prisma.UserGroupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGroupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload>
          }
          findMany: {
            args: Prisma.UserGroupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload>[]
          }
          create: {
            args: Prisma.UserGroupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload>
          }
          createMany: {
            args: Prisma.UserGroupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserGroupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload>
          }
          update: {
            args: Prisma.UserGroupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload>
          }
          deleteMany: {
            args: Prisma.UserGroupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserGroupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserGroupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserGroupsPayload>
          }
          aggregate: {
            args: Prisma.UserGroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserGroups>
          }
          groupBy: {
            args: Prisma.UserGroupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGroupsCountArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupsCountAggregateOutputType> | number
          }
        }
      }
      StudentUsers: {
        payload: Prisma.$StudentUsersPayload<ExtArgs>
        fields: Prisma.StudentUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentUsersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentUsersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          findFirst: {
            args: Prisma.StudentUsersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentUsersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          findMany: {
            args: Prisma.StudentUsersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>[]
          }
          create: {
            args: Prisma.StudentUsersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          createMany: {
            args: Prisma.StudentUsersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentUsersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          update: {
            args: Prisma.StudentUsersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          deleteMany: {
            args: Prisma.StudentUsersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUsersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentUsersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentUsersPayload>
          }
          aggregate: {
            args: Prisma.StudentUsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentUsers>
          }
          groupBy: {
            args: Prisma.StudentUsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentUsersCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentUsersCountAggregateOutputType> | number
          }
        }
      }
      InstituteStaff: {
        payload: Prisma.$InstituteStaffPayload<ExtArgs>
        fields: Prisma.InstituteStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteStaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteStaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          findFirst: {
            args: Prisma.InstituteStaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteStaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          findMany: {
            args: Prisma.InstituteStaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>[]
          }
          create: {
            args: Prisma.InstituteStaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          createMany: {
            args: Prisma.InstituteStaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstituteStaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          update: {
            args: Prisma.InstituteStaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          deleteMany: {
            args: Prisma.InstituteStaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteStaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstituteStaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStaffPayload>
          }
          aggregate: {
            args: Prisma.InstituteStaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstituteStaff>
          }
          groupBy: {
            args: Prisma.InstituteStaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteStaffCountArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStaffCountAggregateOutputType> | number
          }
        }
      }
      InstituteStudents: {
        payload: Prisma.$InstituteStudentsPayload<ExtArgs>
        fields: Prisma.InstituteStudentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteStudentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteStudentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          findFirst: {
            args: Prisma.InstituteStudentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteStudentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          findMany: {
            args: Prisma.InstituteStudentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>[]
          }
          create: {
            args: Prisma.InstituteStudentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          createMany: {
            args: Prisma.InstituteStudentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstituteStudentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          update: {
            args: Prisma.InstituteStudentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          deleteMany: {
            args: Prisma.InstituteStudentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteStudentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstituteStudentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstituteStudentsPayload>
          }
          aggregate: {
            args: Prisma.InstituteStudentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstituteStudents>
          }
          groupBy: {
            args: Prisma.InstituteStudentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteStudentsCountArgs<ExtArgs>,
            result: $Utils.Optional<InstituteStudentsCountAggregateOutputType> | number
          }
        }
      }
      ProviderStaff: {
        payload: Prisma.$ProviderStaffPayload<ExtArgs>
        fields: Prisma.ProviderStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderStaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderStaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          findFirst: {
            args: Prisma.ProviderStaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderStaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          findMany: {
            args: Prisma.ProviderStaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>[]
          }
          create: {
            args: Prisma.ProviderStaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          createMany: {
            args: Prisma.ProviderStaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProviderStaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          update: {
            args: Prisma.ProviderStaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          deleteMany: {
            args: Prisma.ProviderStaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderStaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProviderStaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderStaffPayload>
          }
          aggregate: {
            args: Prisma.ProviderStaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProviderStaff>
          }
          groupBy: {
            args: Prisma.ProviderStaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProviderStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderStaffCountArgs<ExtArgs>,
            result: $Utils.Optional<ProviderStaffCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Addresses
   */

  export type AggregateAddresses = {
    _count: AddressesCountAggregateOutputType | null
    _avg: AddressesAvgAggregateOutputType | null
    _sum: AddressesSumAggregateOutputType | null
    _min: AddressesMinAggregateOutputType | null
    _max: AddressesMaxAggregateOutputType | null
  }

  export type AddressesAvgAggregateOutputType = {
    addressId: number | null
    oId: number | null
  }

  export type AddressesSumAggregateOutputType = {
    addressId: number | null
    oId: number | null
  }

  export type AddressesMinAggregateOutputType = {
    addressId: number | null
    address_line1: string | null
    address_line2: string | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    email: string | null
    geoHash: string | null
    locality: string | null
    oId: number | null
    product: string | null
    phone: string | null
    postal_code: string | null
  }

  export type AddressesMaxAggregateOutputType = {
    addressId: number | null
    address_line1: string | null
    address_line2: string | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    email: string | null
    geoHash: string | null
    locality: string | null
    oId: number | null
    product: string | null
    phone: string | null
    postal_code: string | null
  }

  export type AddressesCountAggregateOutputType = {
    addressId: number
    address_line1: number
    address_line2: number
    contactForename: number
    contactSurname: number
    country: number
    email: number
    geoHash: number
    locality: number
    oId: number
    product: number
    phone: number
    postal_code: number
    _all: number
  }


  export type AddressesAvgAggregateInputType = {
    addressId?: true
    oId?: true
  }

  export type AddressesSumAggregateInputType = {
    addressId?: true
    oId?: true
  }

  export type AddressesMinAggregateInputType = {
    addressId?: true
    address_line1?: true
    address_line2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    email?: true
    geoHash?: true
    locality?: true
    oId?: true
    product?: true
    phone?: true
    postal_code?: true
  }

  export type AddressesMaxAggregateInputType = {
    addressId?: true
    address_line1?: true
    address_line2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    email?: true
    geoHash?: true
    locality?: true
    oId?: true
    product?: true
    phone?: true
    postal_code?: true
  }

  export type AddressesCountAggregateInputType = {
    addressId?: true
    address_line1?: true
    address_line2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    email?: true
    geoHash?: true
    locality?: true
    oId?: true
    product?: true
    phone?: true
    postal_code?: true
    _all?: true
  }

  export type AddressesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to aggregate.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressesMaxAggregateInputType
  }

  export type GetAddressesAggregateType<T extends AddressesAggregateArgs> = {
        [P in keyof T & keyof AggregateAddresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddresses[P]>
      : GetScalarType<T[P], AggregateAddresses[P]>
  }




  export type AddressesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressesWhereInput
    orderBy?: AddressesOrderByWithAggregationInput | AddressesOrderByWithAggregationInput[]
    by: AddressesScalarFieldEnum[] | AddressesScalarFieldEnum
    having?: AddressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressesCountAggregateInputType | true
    _avg?: AddressesAvgAggregateInputType
    _sum?: AddressesSumAggregateInputType
    _min?: AddressesMinAggregateInputType
    _max?: AddressesMaxAggregateInputType
  }

  export type AddressesGroupByOutputType = {
    addressId: number
    address_line1: string
    address_line2: string
    contactForename: string
    contactSurname: string
    country: string
    email: string
    geoHash: string
    locality: string
    oId: number
    product: string
    phone: string
    postal_code: string
    _count: AddressesCountAggregateOutputType | null
    _avg: AddressesAvgAggregateOutputType | null
    _sum: AddressesSumAggregateOutputType | null
    _min: AddressesMinAggregateOutputType | null
    _max: AddressesMaxAggregateOutputType | null
  }

  type GetAddressesGroupByPayload<T extends AddressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressesGroupByOutputType[P]>
            : GetScalarType<T[P], AddressesGroupByOutputType[P]>
        }
      >
    >


  export type AddressesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    addressId?: boolean
    address_line1?: boolean
    address_line2?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    country?: boolean
    email?: boolean
    geoHash?: boolean
    locality?: boolean
    oId?: boolean
    product?: boolean
    phone?: boolean
    postal_code?: boolean
  }, ExtArgs["result"]["addresses"]>

  export type AddressesSelectScalar = {
    addressId?: boolean
    address_line1?: boolean
    address_line2?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    country?: boolean
    email?: boolean
    geoHash?: boolean
    locality?: boolean
    oId?: boolean
    product?: boolean
    phone?: boolean
    postal_code?: boolean
  }


  export type $AddressesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Addresses"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      addressId: number
      address_line1: string
      address_line2: string
      contactForename: string
      contactSurname: string
      country: string
      email: string
      geoHash: string
      locality: string
      oId: number
      product: string
      phone: string
      postal_code: string
    }, ExtArgs["result"]["addresses"]>
    composites: {}
  }


  type AddressesGetPayload<S extends boolean | null | undefined | AddressesDefaultArgs> = $Result.GetResult<Prisma.$AddressesPayload, S>

  type AddressesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressesCountAggregateInputType | true
    }

  export interface AddressesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Addresses'], meta: { name: 'Addresses' } }
    /**
     * Find zero or one Addresses that matches the filter.
     * @param {AddressesFindUniqueArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Addresses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressesFindUniqueOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindFirstArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindFirstArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindFirstOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.addresses.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.addresses.findMany({ take: 10 })
     * 
     * // Only select the `addressId`
     * const addressesWithAddressIdOnly = await prisma.addresses.findMany({ select: { addressId: true } })
     * 
    **/
    findMany<T extends AddressesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Addresses.
     * @param {AddressesCreateArgs} args - Arguments to create a Addresses.
     * @example
     * // Create one Addresses
     * const Addresses = await prisma.addresses.create({
     *   data: {
     *     // ... data to create a Addresses
     *   }
     * })
     * 
    **/
    create<T extends AddressesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesCreateArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Addresses.
     *     @param {AddressesCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const addresses = await prisma.addresses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Addresses.
     * @param {AddressesDeleteArgs} args - Arguments to delete one Addresses.
     * @example
     * // Delete one Addresses
     * const Addresses = await prisma.addresses.delete({
     *   where: {
     *     // ... filter to delete one Addresses
     *   }
     * })
     * 
    **/
    delete<T extends AddressesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesDeleteArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Addresses.
     * @param {AddressesUpdateArgs} args - Arguments to update one Addresses.
     * @example
     * // Update one Addresses
     * const addresses = await prisma.addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpdateArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressesDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const addresses = await prisma.addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Addresses.
     * @param {AddressesUpsertArgs} args - Arguments to update or create a Addresses.
     * @example
     * // Update or create a Addresses
     * const addresses = await prisma.addresses.upsert({
     *   create: {
     *     // ... data to create a Addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Addresses we want to update
     *   }
     * })
    **/
    upsert<T extends AddressesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressesUpsertArgs<ExtArgs>>
    ): Prisma__AddressesClient<$Result.GetResult<Prisma.$AddressesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.addresses.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressesCountArgs>(
      args?: Subset<T, AddressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressesAggregateArgs>(args: Subset<T, AddressesAggregateArgs>): Prisma.PrismaPromise<GetAddressesAggregateType<T>>

    /**
     * Group by Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressesGroupByArgs['orderBy'] }
        : { orderBy?: AddressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Addresses model
   */
  readonly fields: AddressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Addresses model
   */ 
  interface AddressesFieldRefs {
    readonly addressId: FieldRef<"Addresses", 'Int'>
    readonly address_line1: FieldRef<"Addresses", 'String'>
    readonly address_line2: FieldRef<"Addresses", 'String'>
    readonly contactForename: FieldRef<"Addresses", 'String'>
    readonly contactSurname: FieldRef<"Addresses", 'String'>
    readonly country: FieldRef<"Addresses", 'String'>
    readonly email: FieldRef<"Addresses", 'String'>
    readonly geoHash: FieldRef<"Addresses", 'String'>
    readonly locality: FieldRef<"Addresses", 'String'>
    readonly oId: FieldRef<"Addresses", 'Int'>
    readonly product: FieldRef<"Addresses", 'String'>
    readonly phone: FieldRef<"Addresses", 'String'>
    readonly postal_code: FieldRef<"Addresses", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Addresses findUnique
   */
  export type AddressesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where: AddressesWhereUniqueInput
  }


  /**
   * Addresses findUniqueOrThrow
   */
  export type AddressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where: AddressesWhereUniqueInput
  }


  /**
   * Addresses findFirst
   */
  export type AddressesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }


  /**
   * Addresses findFirstOrThrow
   */
  export type AddressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }


  /**
   * Addresses findMany
   */
  export type AddressesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressesOrderByWithRelationInput | AddressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }


  /**
   * Addresses create
   */
  export type AddressesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * The data needed to create a Addresses.
     */
    data: XOR<AddressesCreateInput, AddressesUncheckedCreateInput>
  }


  /**
   * Addresses createMany
   */
  export type AddressesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressesCreateManyInput | AddressesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Addresses update
   */
  export type AddressesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * The data needed to update a Addresses.
     */
    data: XOR<AddressesUpdateInput, AddressesUncheckedUpdateInput>
    /**
     * Choose, which Addresses to update.
     */
    where: AddressesWhereUniqueInput
  }


  /**
   * Addresses updateMany
   */
  export type AddressesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressesUpdateManyMutationInput, AddressesUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressesWhereInput
  }


  /**
   * Addresses upsert
   */
  export type AddressesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * The filter to search for the Addresses to update in case it exists.
     */
    where: AddressesWhereUniqueInput
    /**
     * In case the Addresses found by the `where` argument doesn't exist, create a new Addresses with this data.
     */
    create: XOR<AddressesCreateInput, AddressesUncheckedCreateInput>
    /**
     * In case the Addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressesUpdateInput, AddressesUncheckedUpdateInput>
  }


  /**
   * Addresses delete
   */
  export type AddressesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
    /**
     * Filter which Addresses to delete.
     */
    where: AddressesWhereUniqueInput
  }


  /**
   * Addresses deleteMany
   */
  export type AddressesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressesWhereInput
  }


  /**
   * Addresses without action
   */
  export type AddressesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addresses
     */
    select?: AddressesSelect<ExtArgs> | null
  }



  /**
   * Model Blogs
   */

  export type AggregateBlogs = {
    _count: BlogsCountAggregateOutputType | null
    _avg: BlogsAvgAggregateOutputType | null
    _sum: BlogsSumAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  export type BlogsAvgAggregateOutputType = {
    blogId: number | null
  }

  export type BlogsSumAggregateOutputType = {
    blogId: number | null
  }

  export type BlogsMinAggregateOutputType = {
    blogId: number | null
    author: string | null
    category: string | null
    summary: string | null
    tags: string | null
    title: string | null
    uploaded: string | null
  }

  export type BlogsMaxAggregateOutputType = {
    blogId: number | null
    author: string | null
    category: string | null
    summary: string | null
    tags: string | null
    title: string | null
    uploaded: string | null
  }

  export type BlogsCountAggregateOutputType = {
    blogId: number
    author: number
    category: number
    summary: number
    tags: number
    title: number
    uploaded: number
    body: number
    _all: number
  }


  export type BlogsAvgAggregateInputType = {
    blogId?: true
  }

  export type BlogsSumAggregateInputType = {
    blogId?: true
  }

  export type BlogsMinAggregateInputType = {
    blogId?: true
    author?: true
    category?: true
    summary?: true
    tags?: true
    title?: true
    uploaded?: true
  }

  export type BlogsMaxAggregateInputType = {
    blogId?: true
    author?: true
    category?: true
    summary?: true
    tags?: true
    title?: true
    uploaded?: true
  }

  export type BlogsCountAggregateInputType = {
    blogId?: true
    author?: true
    category?: true
    summary?: true
    tags?: true
    title?: true
    uploaded?: true
    body?: true
    _all?: true
  }

  export type BlogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to aggregate.
     */
    where?: BlogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogsOrderByWithRelationInput | BlogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogsMaxAggregateInputType
  }

  export type GetBlogsAggregateType<T extends BlogsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogs[P]>
      : GetScalarType<T[P], AggregateBlogs[P]>
  }




  export type BlogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogsWhereInput
    orderBy?: BlogsOrderByWithAggregationInput | BlogsOrderByWithAggregationInput[]
    by: BlogsScalarFieldEnum[] | BlogsScalarFieldEnum
    having?: BlogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogsCountAggregateInputType | true
    _avg?: BlogsAvgAggregateInputType
    _sum?: BlogsSumAggregateInputType
    _min?: BlogsMinAggregateInputType
    _max?: BlogsMaxAggregateInputType
  }

  export type BlogsGroupByOutputType = {
    blogId: number
    author: string
    category: string
    summary: string
    tags: string
    title: string
    uploaded: string
    body: JsonValue
    _count: BlogsCountAggregateOutputType | null
    _avg: BlogsAvgAggregateOutputType | null
    _sum: BlogsSumAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  type GetBlogsGroupByPayload<T extends BlogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogsGroupByOutputType[P]>
            : GetScalarType<T[P], BlogsGroupByOutputType[P]>
        }
      >
    >


  export type BlogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    blogId?: boolean
    author?: boolean
    category?: boolean
    summary?: boolean
    tags?: boolean
    title?: boolean
    uploaded?: boolean
    body?: boolean
  }, ExtArgs["result"]["blogs"]>

  export type BlogsSelectScalar = {
    blogId?: boolean
    author?: boolean
    category?: boolean
    summary?: boolean
    tags?: boolean
    title?: boolean
    uploaded?: boolean
    body?: boolean
  }


  export type $BlogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blogs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      blogId: number
      author: string
      category: string
      summary: string
      tags: string
      title: string
      uploaded: string
      body: Prisma.JsonValue
    }, ExtArgs["result"]["blogs"]>
    composites: {}
  }


  type BlogsGetPayload<S extends boolean | null | undefined | BlogsDefaultArgs> = $Result.GetResult<Prisma.$BlogsPayload, S>

  type BlogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogsCountAggregateInputType | true
    }

  export interface BlogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blogs'], meta: { name: 'Blogs' } }
    /**
     * Find zero or one Blogs that matches the filter.
     * @param {BlogsFindUniqueArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BlogsFindUniqueArgs<ExtArgs>>
    ): Prisma__BlogsClient<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Blogs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlogsFindUniqueOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlogsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlogsClient<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsFindFirstArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogsFindFirstArgs<ExtArgs>>
    ): Prisma__BlogsClient<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Blogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsFindFirstOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlogsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlogsClient<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blogs.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blogs.findMany({ take: 10 })
     * 
     * // Only select the `blogId`
     * const blogsWithBlogIdOnly = await prisma.blogs.findMany({ select: { blogId: true } })
     * 
    **/
    findMany<T extends BlogsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Blogs.
     * @param {BlogsCreateArgs} args - Arguments to create a Blogs.
     * @example
     * // Create one Blogs
     * const Blogs = await prisma.blogs.create({
     *   data: {
     *     // ... data to create a Blogs
     *   }
     * })
     * 
    **/
    create<T extends BlogsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogsCreateArgs<ExtArgs>>
    ): Prisma__BlogsClient<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Blogs.
     *     @param {BlogsCreateManyArgs} args - Arguments to create many Blogs.
     *     @example
     *     // Create many Blogs
     *     const blogs = await prisma.blogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blogs.
     * @param {BlogsDeleteArgs} args - Arguments to delete one Blogs.
     * @example
     * // Delete one Blogs
     * const Blogs = await prisma.blogs.delete({
     *   where: {
     *     // ... filter to delete one Blogs
     *   }
     * })
     * 
    **/
    delete<T extends BlogsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlogsDeleteArgs<ExtArgs>>
    ): Prisma__BlogsClient<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Blogs.
     * @param {BlogsUpdateArgs} args - Arguments to update one Blogs.
     * @example
     * // Update one Blogs
     * const blogs = await prisma.blogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogsUpdateArgs<ExtArgs>>
    ): Prisma__BlogsClient<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Blogs.
     * @param {BlogsDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blogs = await prisma.blogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlogsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blogs.
     * @param {BlogsUpsertArgs} args - Arguments to update or create a Blogs.
     * @example
     * // Update or create a Blogs
     * const blogs = await prisma.blogs.upsert({
     *   create: {
     *     // ... data to create a Blogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blogs we want to update
     *   }
     * })
    **/
    upsert<T extends BlogsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlogsUpsertArgs<ExtArgs>>
    ): Prisma__BlogsClient<$Result.GetResult<Prisma.$BlogsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blogs.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogsCountArgs>(
      args?: Subset<T, BlogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogsAggregateArgs>(args: Subset<T, BlogsAggregateArgs>): Prisma.PrismaPromise<GetBlogsAggregateType<T>>

    /**
     * Group by Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogsGroupByArgs['orderBy'] }
        : { orderBy?: BlogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blogs model
   */
  readonly fields: BlogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Blogs model
   */ 
  interface BlogsFieldRefs {
    readonly blogId: FieldRef<"Blogs", 'Int'>
    readonly author: FieldRef<"Blogs", 'String'>
    readonly category: FieldRef<"Blogs", 'String'>
    readonly summary: FieldRef<"Blogs", 'String'>
    readonly tags: FieldRef<"Blogs", 'String'>
    readonly title: FieldRef<"Blogs", 'String'>
    readonly uploaded: FieldRef<"Blogs", 'String'>
    readonly body: FieldRef<"Blogs", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Blogs findUnique
   */
  export type BlogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where: BlogsWhereUniqueInput
  }


  /**
   * Blogs findUniqueOrThrow
   */
  export type BlogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where: BlogsWhereUniqueInput
  }


  /**
   * Blogs findFirst
   */
  export type BlogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogsOrderByWithRelationInput | BlogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }


  /**
   * Blogs findFirstOrThrow
   */
  export type BlogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogsOrderByWithRelationInput | BlogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }


  /**
   * Blogs findMany
   */
  export type BlogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogsOrderByWithRelationInput | BlogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }


  /**
   * Blogs create
   */
  export type BlogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * The data needed to create a Blogs.
     */
    data: XOR<BlogsCreateInput, BlogsUncheckedCreateInput>
  }


  /**
   * Blogs createMany
   */
  export type BlogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogsCreateManyInput | BlogsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Blogs update
   */
  export type BlogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * The data needed to update a Blogs.
     */
    data: XOR<BlogsUpdateInput, BlogsUncheckedUpdateInput>
    /**
     * Choose, which Blogs to update.
     */
    where: BlogsWhereUniqueInput
  }


  /**
   * Blogs updateMany
   */
  export type BlogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogsUpdateManyMutationInput, BlogsUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogsWhereInput
  }


  /**
   * Blogs upsert
   */
  export type BlogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * The filter to search for the Blogs to update in case it exists.
     */
    where: BlogsWhereUniqueInput
    /**
     * In case the Blogs found by the `where` argument doesn't exist, create a new Blogs with this data.
     */
    create: XOR<BlogsCreateInput, BlogsUncheckedCreateInput>
    /**
     * In case the Blogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogsUpdateInput, BlogsUncheckedUpdateInput>
  }


  /**
   * Blogs delete
   */
  export type BlogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
    /**
     * Filter which Blogs to delete.
     */
    where: BlogsWhereUniqueInput
  }


  /**
   * Blogs deleteMany
   */
  export type BlogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogsWhereInput
  }


  /**
   * Blogs without action
   */
  export type BlogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blogs
     */
    select?: BlogsSelect<ExtArgs> | null
  }



  /**
   * Model BugReports
   */

  export type AggregateBugReports = {
    _count: BugReportsCountAggregateOutputType | null
    _avg: BugReportsAvgAggregateOutputType | null
    _sum: BugReportsSumAggregateOutputType | null
    _min: BugReportsMinAggregateOutputType | null
    _max: BugReportsMaxAggregateOutputType | null
  }

  export type BugReportsAvgAggregateOutputType = {
    bugReportId: number | null
  }

  export type BugReportsSumAggregateOutputType = {
    bugReportId: number | null
  }

  export type BugReportsMinAggregateOutputType = {
    bugReportId: number | null
    bug: string | null
    date: Date | null
    description: string | null
    severity: string | null
    status: string | null
    uid: string | null
  }

  export type BugReportsMaxAggregateOutputType = {
    bugReportId: number | null
    bug: string | null
    date: Date | null
    description: string | null
    severity: string | null
    status: string | null
    uid: string | null
  }

  export type BugReportsCountAggregateOutputType = {
    bugReportId: number
    bug: number
    date: number
    description: number
    severity: number
    status: number
    uid: number
    _all: number
  }


  export type BugReportsAvgAggregateInputType = {
    bugReportId?: true
  }

  export type BugReportsSumAggregateInputType = {
    bugReportId?: true
  }

  export type BugReportsMinAggregateInputType = {
    bugReportId?: true
    bug?: true
    date?: true
    description?: true
    severity?: true
    status?: true
    uid?: true
  }

  export type BugReportsMaxAggregateInputType = {
    bugReportId?: true
    bug?: true
    date?: true
    description?: true
    severity?: true
    status?: true
    uid?: true
  }

  export type BugReportsCountAggregateInputType = {
    bugReportId?: true
    bug?: true
    date?: true
    description?: true
    severity?: true
    status?: true
    uid?: true
    _all?: true
  }

  export type BugReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BugReports to aggregate.
     */
    where?: BugReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportsOrderByWithRelationInput | BugReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BugReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BugReports
    **/
    _count?: true | BugReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BugReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BugReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BugReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BugReportsMaxAggregateInputType
  }

  export type GetBugReportsAggregateType<T extends BugReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateBugReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBugReports[P]>
      : GetScalarType<T[P], AggregateBugReports[P]>
  }




  export type BugReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BugReportsWhereInput
    orderBy?: BugReportsOrderByWithAggregationInput | BugReportsOrderByWithAggregationInput[]
    by: BugReportsScalarFieldEnum[] | BugReportsScalarFieldEnum
    having?: BugReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BugReportsCountAggregateInputType | true
    _avg?: BugReportsAvgAggregateInputType
    _sum?: BugReportsSumAggregateInputType
    _min?: BugReportsMinAggregateInputType
    _max?: BugReportsMaxAggregateInputType
  }

  export type BugReportsGroupByOutputType = {
    bugReportId: number
    bug: string
    date: Date
    description: string
    severity: string
    status: string
    uid: string
    _count: BugReportsCountAggregateOutputType | null
    _avg: BugReportsAvgAggregateOutputType | null
    _sum: BugReportsSumAggregateOutputType | null
    _min: BugReportsMinAggregateOutputType | null
    _max: BugReportsMaxAggregateOutputType | null
  }

  type GetBugReportsGroupByPayload<T extends BugReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BugReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BugReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BugReportsGroupByOutputType[P]>
            : GetScalarType<T[P], BugReportsGroupByOutputType[P]>
        }
      >
    >


  export type BugReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bugReportId?: boolean
    bug?: boolean
    date?: boolean
    description?: boolean
    severity?: boolean
    status?: boolean
    uid?: boolean
  }, ExtArgs["result"]["bugReports"]>

  export type BugReportsSelectScalar = {
    bugReportId?: boolean
    bug?: boolean
    date?: boolean
    description?: boolean
    severity?: boolean
    status?: boolean
    uid?: boolean
  }


  export type $BugReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BugReports"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      bugReportId: number
      bug: string
      date: Date
      description: string
      severity: string
      status: string
      uid: string
    }, ExtArgs["result"]["bugReports"]>
    composites: {}
  }


  type BugReportsGetPayload<S extends boolean | null | undefined | BugReportsDefaultArgs> = $Result.GetResult<Prisma.$BugReportsPayload, S>

  type BugReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BugReportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BugReportsCountAggregateInputType | true
    }

  export interface BugReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BugReports'], meta: { name: 'BugReports' } }
    /**
     * Find zero or one BugReports that matches the filter.
     * @param {BugReportsFindUniqueArgs} args - Arguments to find a BugReports
     * @example
     * // Get one BugReports
     * const bugReports = await prisma.bugReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BugReportsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BugReportsFindUniqueArgs<ExtArgs>>
    ): Prisma__BugReportsClient<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BugReports that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BugReportsFindUniqueOrThrowArgs} args - Arguments to find a BugReports
     * @example
     * // Get one BugReports
     * const bugReports = await prisma.bugReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BugReportsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BugReportsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BugReportsClient<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BugReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportsFindFirstArgs} args - Arguments to find a BugReports
     * @example
     * // Get one BugReports
     * const bugReports = await prisma.bugReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BugReportsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BugReportsFindFirstArgs<ExtArgs>>
    ): Prisma__BugReportsClient<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BugReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportsFindFirstOrThrowArgs} args - Arguments to find a BugReports
     * @example
     * // Get one BugReports
     * const bugReports = await prisma.bugReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BugReportsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BugReportsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BugReportsClient<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BugReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BugReports
     * const bugReports = await prisma.bugReports.findMany()
     * 
     * // Get first 10 BugReports
     * const bugReports = await prisma.bugReports.findMany({ take: 10 })
     * 
     * // Only select the `bugReportId`
     * const bugReportsWithBugReportIdOnly = await prisma.bugReports.findMany({ select: { bugReportId: true } })
     * 
    **/
    findMany<T extends BugReportsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BugReportsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BugReports.
     * @param {BugReportsCreateArgs} args - Arguments to create a BugReports.
     * @example
     * // Create one BugReports
     * const BugReports = await prisma.bugReports.create({
     *   data: {
     *     // ... data to create a BugReports
     *   }
     * })
     * 
    **/
    create<T extends BugReportsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BugReportsCreateArgs<ExtArgs>>
    ): Prisma__BugReportsClient<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BugReports.
     *     @param {BugReportsCreateManyArgs} args - Arguments to create many BugReports.
     *     @example
     *     // Create many BugReports
     *     const bugReports = await prisma.bugReports.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BugReportsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BugReportsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BugReports.
     * @param {BugReportsDeleteArgs} args - Arguments to delete one BugReports.
     * @example
     * // Delete one BugReports
     * const BugReports = await prisma.bugReports.delete({
     *   where: {
     *     // ... filter to delete one BugReports
     *   }
     * })
     * 
    **/
    delete<T extends BugReportsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BugReportsDeleteArgs<ExtArgs>>
    ): Prisma__BugReportsClient<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BugReports.
     * @param {BugReportsUpdateArgs} args - Arguments to update one BugReports.
     * @example
     * // Update one BugReports
     * const bugReports = await prisma.bugReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BugReportsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BugReportsUpdateArgs<ExtArgs>>
    ): Prisma__BugReportsClient<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BugReports.
     * @param {BugReportsDeleteManyArgs} args - Arguments to filter BugReports to delete.
     * @example
     * // Delete a few BugReports
     * const { count } = await prisma.bugReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BugReportsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BugReportsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BugReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BugReports
     * const bugReports = await prisma.bugReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BugReportsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BugReportsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BugReports.
     * @param {BugReportsUpsertArgs} args - Arguments to update or create a BugReports.
     * @example
     * // Update or create a BugReports
     * const bugReports = await prisma.bugReports.upsert({
     *   create: {
     *     // ... data to create a BugReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BugReports we want to update
     *   }
     * })
    **/
    upsert<T extends BugReportsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BugReportsUpsertArgs<ExtArgs>>
    ): Prisma__BugReportsClient<$Result.GetResult<Prisma.$BugReportsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BugReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportsCountArgs} args - Arguments to filter BugReports to count.
     * @example
     * // Count the number of BugReports
     * const count = await prisma.bugReports.count({
     *   where: {
     *     // ... the filter for the BugReports we want to count
     *   }
     * })
    **/
    count<T extends BugReportsCountArgs>(
      args?: Subset<T, BugReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BugReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BugReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BugReportsAggregateArgs>(args: Subset<T, BugReportsAggregateArgs>): Prisma.PrismaPromise<GetBugReportsAggregateType<T>>

    /**
     * Group by BugReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BugReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BugReportsGroupByArgs['orderBy'] }
        : { orderBy?: BugReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BugReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBugReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BugReports model
   */
  readonly fields: BugReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BugReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BugReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BugReports model
   */ 
  interface BugReportsFieldRefs {
    readonly bugReportId: FieldRef<"BugReports", 'Int'>
    readonly bug: FieldRef<"BugReports", 'String'>
    readonly date: FieldRef<"BugReports", 'DateTime'>
    readonly description: FieldRef<"BugReports", 'String'>
    readonly severity: FieldRef<"BugReports", 'String'>
    readonly status: FieldRef<"BugReports", 'String'>
    readonly uid: FieldRef<"BugReports", 'String'>
  }
    

  // Custom InputTypes

  /**
   * BugReports findUnique
   */
  export type BugReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * Filter, which BugReports to fetch.
     */
    where: BugReportsWhereUniqueInput
  }


  /**
   * BugReports findUniqueOrThrow
   */
  export type BugReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * Filter, which BugReports to fetch.
     */
    where: BugReportsWhereUniqueInput
  }


  /**
   * BugReports findFirst
   */
  export type BugReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * Filter, which BugReports to fetch.
     */
    where?: BugReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportsOrderByWithRelationInput | BugReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BugReports.
     */
    cursor?: BugReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BugReports.
     */
    distinct?: BugReportsScalarFieldEnum | BugReportsScalarFieldEnum[]
  }


  /**
   * BugReports findFirstOrThrow
   */
  export type BugReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * Filter, which BugReports to fetch.
     */
    where?: BugReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportsOrderByWithRelationInput | BugReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BugReports.
     */
    cursor?: BugReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BugReports.
     */
    distinct?: BugReportsScalarFieldEnum | BugReportsScalarFieldEnum[]
  }


  /**
   * BugReports findMany
   */
  export type BugReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * Filter, which BugReports to fetch.
     */
    where?: BugReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportsOrderByWithRelationInput | BugReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BugReports.
     */
    cursor?: BugReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    distinct?: BugReportsScalarFieldEnum | BugReportsScalarFieldEnum[]
  }


  /**
   * BugReports create
   */
  export type BugReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * The data needed to create a BugReports.
     */
    data: XOR<BugReportsCreateInput, BugReportsUncheckedCreateInput>
  }


  /**
   * BugReports createMany
   */
  export type BugReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BugReports.
     */
    data: BugReportsCreateManyInput | BugReportsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BugReports update
   */
  export type BugReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * The data needed to update a BugReports.
     */
    data: XOR<BugReportsUpdateInput, BugReportsUncheckedUpdateInput>
    /**
     * Choose, which BugReports to update.
     */
    where: BugReportsWhereUniqueInput
  }


  /**
   * BugReports updateMany
   */
  export type BugReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BugReports.
     */
    data: XOR<BugReportsUpdateManyMutationInput, BugReportsUncheckedUpdateManyInput>
    /**
     * Filter which BugReports to update
     */
    where?: BugReportsWhereInput
  }


  /**
   * BugReports upsert
   */
  export type BugReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * The filter to search for the BugReports to update in case it exists.
     */
    where: BugReportsWhereUniqueInput
    /**
     * In case the BugReports found by the `where` argument doesn't exist, create a new BugReports with this data.
     */
    create: XOR<BugReportsCreateInput, BugReportsUncheckedCreateInput>
    /**
     * In case the BugReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BugReportsUpdateInput, BugReportsUncheckedUpdateInput>
  }


  /**
   * BugReports delete
   */
  export type BugReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
    /**
     * Filter which BugReports to delete.
     */
    where: BugReportsWhereUniqueInput
  }


  /**
   * BugReports deleteMany
   */
  export type BugReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BugReports to delete
     */
    where?: BugReportsWhereInput
  }


  /**
   * BugReports without action
   */
  export type BugReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReports
     */
    select?: BugReportsSelect<ExtArgs> | null
  }



  /**
   * Model BusinessInterest
   */

  export type AggregateBusinessInterest = {
    _count: BusinessInterestCountAggregateOutputType | null
    _avg: BusinessInterestAvgAggregateOutputType | null
    _sum: BusinessInterestSumAggregateOutputType | null
    _min: BusinessInterestMinAggregateOutputType | null
    _max: BusinessInterestMaxAggregateOutputType | null
  }

  export type BusinessInterestAvgAggregateOutputType = {
    businessInterestId: number | null
  }

  export type BusinessInterestSumAggregateOutputType = {
    businessInterestId: number | null
  }

  export type BusinessInterestMinAggregateOutputType = {
    businessInterestId: number | null
    email: string | null
    forename: string | null
    surname: string | null
    sector: string | null
    subsector: string | null
  }

  export type BusinessInterestMaxAggregateOutputType = {
    businessInterestId: number | null
    email: string | null
    forename: string | null
    surname: string | null
    sector: string | null
    subsector: string | null
  }

  export type BusinessInterestCountAggregateOutputType = {
    businessInterestId: number
    email: number
    forename: number
    surname: number
    sector: number
    subsector: number
    _all: number
  }


  export type BusinessInterestAvgAggregateInputType = {
    businessInterestId?: true
  }

  export type BusinessInterestSumAggregateInputType = {
    businessInterestId?: true
  }

  export type BusinessInterestMinAggregateInputType = {
    businessInterestId?: true
    email?: true
    forename?: true
    surname?: true
    sector?: true
    subsector?: true
  }

  export type BusinessInterestMaxAggregateInputType = {
    businessInterestId?: true
    email?: true
    forename?: true
    surname?: true
    sector?: true
    subsector?: true
  }

  export type BusinessInterestCountAggregateInputType = {
    businessInterestId?: true
    email?: true
    forename?: true
    surname?: true
    sector?: true
    subsector?: true
    _all?: true
  }

  export type BusinessInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessInterest to aggregate.
     */
    where?: BusinessInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessInterests to fetch.
     */
    orderBy?: BusinessInterestOrderByWithRelationInput | BusinessInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessInterests
    **/
    _count?: true | BusinessInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessInterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessInterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessInterestMaxAggregateInputType
  }

  export type GetBusinessInterestAggregateType<T extends BusinessInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessInterest[P]>
      : GetScalarType<T[P], AggregateBusinessInterest[P]>
  }




  export type BusinessInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessInterestWhereInput
    orderBy?: BusinessInterestOrderByWithAggregationInput | BusinessInterestOrderByWithAggregationInput[]
    by: BusinessInterestScalarFieldEnum[] | BusinessInterestScalarFieldEnum
    having?: BusinessInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessInterestCountAggregateInputType | true
    _avg?: BusinessInterestAvgAggregateInputType
    _sum?: BusinessInterestSumAggregateInputType
    _min?: BusinessInterestMinAggregateInputType
    _max?: BusinessInterestMaxAggregateInputType
  }

  export type BusinessInterestGroupByOutputType = {
    businessInterestId: number
    email: string
    forename: string
    surname: string
    sector: string | null
    subsector: string | null
    _count: BusinessInterestCountAggregateOutputType | null
    _avg: BusinessInterestAvgAggregateOutputType | null
    _sum: BusinessInterestSumAggregateOutputType | null
    _min: BusinessInterestMinAggregateOutputType | null
    _max: BusinessInterestMaxAggregateOutputType | null
  }

  type GetBusinessInterestGroupByPayload<T extends BusinessInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessInterestGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessInterestGroupByOutputType[P]>
        }
      >
    >


  export type BusinessInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    businessInterestId?: boolean
    email?: boolean
    forename?: boolean
    surname?: boolean
    sector?: boolean
    subsector?: boolean
  }, ExtArgs["result"]["businessInterest"]>

  export type BusinessInterestSelectScalar = {
    businessInterestId?: boolean
    email?: boolean
    forename?: boolean
    surname?: boolean
    sector?: boolean
    subsector?: boolean
  }


  export type $BusinessInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessInterest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      businessInterestId: number
      email: string
      forename: string
      surname: string
      sector: string | null
      subsector: string | null
    }, ExtArgs["result"]["businessInterest"]>
    composites: {}
  }


  type BusinessInterestGetPayload<S extends boolean | null | undefined | BusinessInterestDefaultArgs> = $Result.GetResult<Prisma.$BusinessInterestPayload, S>

  type BusinessInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessInterestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessInterestCountAggregateInputType | true
    }

  export interface BusinessInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessInterest'], meta: { name: 'BusinessInterest' } }
    /**
     * Find zero or one BusinessInterest that matches the filter.
     * @param {BusinessInterestFindUniqueArgs} args - Arguments to find a BusinessInterest
     * @example
     * // Get one BusinessInterest
     * const businessInterest = await prisma.businessInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessInterestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessInterestFindUniqueArgs<ExtArgs>>
    ): Prisma__BusinessInterestClient<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BusinessInterest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessInterestFindUniqueOrThrowArgs} args - Arguments to find a BusinessInterest
     * @example
     * // Get one BusinessInterest
     * const businessInterest = await prisma.businessInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessInterestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessInterestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessInterestClient<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BusinessInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessInterestFindFirstArgs} args - Arguments to find a BusinessInterest
     * @example
     * // Get one BusinessInterest
     * const businessInterest = await prisma.businessInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessInterestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessInterestFindFirstArgs<ExtArgs>>
    ): Prisma__BusinessInterestClient<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BusinessInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessInterestFindFirstOrThrowArgs} args - Arguments to find a BusinessInterest
     * @example
     * // Get one BusinessInterest
     * const businessInterest = await prisma.businessInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessInterestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessInterestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessInterestClient<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BusinessInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessInterestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessInterests
     * const businessInterests = await prisma.businessInterest.findMany()
     * 
     * // Get first 10 BusinessInterests
     * const businessInterests = await prisma.businessInterest.findMany({ take: 10 })
     * 
     * // Only select the `businessInterestId`
     * const businessInterestWithBusinessInterestIdOnly = await prisma.businessInterest.findMany({ select: { businessInterestId: true } })
     * 
    **/
    findMany<T extends BusinessInterestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessInterestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BusinessInterest.
     * @param {BusinessInterestCreateArgs} args - Arguments to create a BusinessInterest.
     * @example
     * // Create one BusinessInterest
     * const BusinessInterest = await prisma.businessInterest.create({
     *   data: {
     *     // ... data to create a BusinessInterest
     *   }
     * })
     * 
    **/
    create<T extends BusinessInterestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessInterestCreateArgs<ExtArgs>>
    ): Prisma__BusinessInterestClient<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BusinessInterests.
     *     @param {BusinessInterestCreateManyArgs} args - Arguments to create many BusinessInterests.
     *     @example
     *     // Create many BusinessInterests
     *     const businessInterest = await prisma.businessInterest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessInterestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessInterestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessInterest.
     * @param {BusinessInterestDeleteArgs} args - Arguments to delete one BusinessInterest.
     * @example
     * // Delete one BusinessInterest
     * const BusinessInterest = await prisma.businessInterest.delete({
     *   where: {
     *     // ... filter to delete one BusinessInterest
     *   }
     * })
     * 
    **/
    delete<T extends BusinessInterestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessInterestDeleteArgs<ExtArgs>>
    ): Prisma__BusinessInterestClient<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BusinessInterest.
     * @param {BusinessInterestUpdateArgs} args - Arguments to update one BusinessInterest.
     * @example
     * // Update one BusinessInterest
     * const businessInterest = await prisma.businessInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessInterestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessInterestUpdateArgs<ExtArgs>>
    ): Prisma__BusinessInterestClient<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BusinessInterests.
     * @param {BusinessInterestDeleteManyArgs} args - Arguments to filter BusinessInterests to delete.
     * @example
     * // Delete a few BusinessInterests
     * const { count } = await prisma.businessInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessInterestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessInterestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessInterests
     * const businessInterest = await prisma.businessInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessInterestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessInterestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessInterest.
     * @param {BusinessInterestUpsertArgs} args - Arguments to update or create a BusinessInterest.
     * @example
     * // Update or create a BusinessInterest
     * const businessInterest = await prisma.businessInterest.upsert({
     *   create: {
     *     // ... data to create a BusinessInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessInterest we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessInterestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessInterestUpsertArgs<ExtArgs>>
    ): Prisma__BusinessInterestClient<$Result.GetResult<Prisma.$BusinessInterestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BusinessInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessInterestCountArgs} args - Arguments to filter BusinessInterests to count.
     * @example
     * // Count the number of BusinessInterests
     * const count = await prisma.businessInterest.count({
     *   where: {
     *     // ... the filter for the BusinessInterests we want to count
     *   }
     * })
    **/
    count<T extends BusinessInterestCountArgs>(
      args?: Subset<T, BusinessInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessInterestAggregateArgs>(args: Subset<T, BusinessInterestAggregateArgs>): Prisma.PrismaPromise<GetBusinessInterestAggregateType<T>>

    /**
     * Group by BusinessInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessInterestGroupByArgs['orderBy'] }
        : { orderBy?: BusinessInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessInterest model
   */
  readonly fields: BusinessInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BusinessInterest model
   */ 
  interface BusinessInterestFieldRefs {
    readonly businessInterestId: FieldRef<"BusinessInterest", 'Int'>
    readonly email: FieldRef<"BusinessInterest", 'String'>
    readonly forename: FieldRef<"BusinessInterest", 'String'>
    readonly surname: FieldRef<"BusinessInterest", 'String'>
    readonly sector: FieldRef<"BusinessInterest", 'String'>
    readonly subsector: FieldRef<"BusinessInterest", 'String'>
  }
    

  // Custom InputTypes

  /**
   * BusinessInterest findUnique
   */
  export type BusinessInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * Filter, which BusinessInterest to fetch.
     */
    where: BusinessInterestWhereUniqueInput
  }


  /**
   * BusinessInterest findUniqueOrThrow
   */
  export type BusinessInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * Filter, which BusinessInterest to fetch.
     */
    where: BusinessInterestWhereUniqueInput
  }


  /**
   * BusinessInterest findFirst
   */
  export type BusinessInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * Filter, which BusinessInterest to fetch.
     */
    where?: BusinessInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessInterests to fetch.
     */
    orderBy?: BusinessInterestOrderByWithRelationInput | BusinessInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessInterests.
     */
    cursor?: BusinessInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessInterests.
     */
    distinct?: BusinessInterestScalarFieldEnum | BusinessInterestScalarFieldEnum[]
  }


  /**
   * BusinessInterest findFirstOrThrow
   */
  export type BusinessInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * Filter, which BusinessInterest to fetch.
     */
    where?: BusinessInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessInterests to fetch.
     */
    orderBy?: BusinessInterestOrderByWithRelationInput | BusinessInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessInterests.
     */
    cursor?: BusinessInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessInterests.
     */
    distinct?: BusinessInterestScalarFieldEnum | BusinessInterestScalarFieldEnum[]
  }


  /**
   * BusinessInterest findMany
   */
  export type BusinessInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * Filter, which BusinessInterests to fetch.
     */
    where?: BusinessInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessInterests to fetch.
     */
    orderBy?: BusinessInterestOrderByWithRelationInput | BusinessInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessInterests.
     */
    cursor?: BusinessInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessInterests.
     */
    skip?: number
    distinct?: BusinessInterestScalarFieldEnum | BusinessInterestScalarFieldEnum[]
  }


  /**
   * BusinessInterest create
   */
  export type BusinessInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * The data needed to create a BusinessInterest.
     */
    data: XOR<BusinessInterestCreateInput, BusinessInterestUncheckedCreateInput>
  }


  /**
   * BusinessInterest createMany
   */
  export type BusinessInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessInterests.
     */
    data: BusinessInterestCreateManyInput | BusinessInterestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BusinessInterest update
   */
  export type BusinessInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * The data needed to update a BusinessInterest.
     */
    data: XOR<BusinessInterestUpdateInput, BusinessInterestUncheckedUpdateInput>
    /**
     * Choose, which BusinessInterest to update.
     */
    where: BusinessInterestWhereUniqueInput
  }


  /**
   * BusinessInterest updateMany
   */
  export type BusinessInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessInterests.
     */
    data: XOR<BusinessInterestUpdateManyMutationInput, BusinessInterestUncheckedUpdateManyInput>
    /**
     * Filter which BusinessInterests to update
     */
    where?: BusinessInterestWhereInput
  }


  /**
   * BusinessInterest upsert
   */
  export type BusinessInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * The filter to search for the BusinessInterest to update in case it exists.
     */
    where: BusinessInterestWhereUniqueInput
    /**
     * In case the BusinessInterest found by the `where` argument doesn't exist, create a new BusinessInterest with this data.
     */
    create: XOR<BusinessInterestCreateInput, BusinessInterestUncheckedCreateInput>
    /**
     * In case the BusinessInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessInterestUpdateInput, BusinessInterestUncheckedUpdateInput>
  }


  /**
   * BusinessInterest delete
   */
  export type BusinessInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
    /**
     * Filter which BusinessInterest to delete.
     */
    where: BusinessInterestWhereUniqueInput
  }


  /**
   * BusinessInterest deleteMany
   */
  export type BusinessInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessInterests to delete
     */
    where?: BusinessInterestWhereInput
  }


  /**
   * BusinessInterest without action
   */
  export type BusinessInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessInterest
     */
    select?: BusinessInterestSelect<ExtArgs> | null
  }



  /**
   * Model Cohorts
   */

  export type AggregateCohorts = {
    _count: CohortsCountAggregateOutputType | null
    _avg: CohortsAvgAggregateOutputType | null
    _sum: CohortsSumAggregateOutputType | null
    _min: CohortsMinAggregateOutputType | null
    _max: CohortsMaxAggregateOutputType | null
  }

  export type CohortsAvgAggregateOutputType = {
    cohortId: number | null
    oId: number | null
  }

  export type CohortsSumAggregateOutputType = {
    cohortId: number | null
    oId: number | null
  }

  export type CohortsMinAggregateOutputType = {
    cohortId: number | null
    designatedStaff: string | null
    oId: number | null
    product: string | null
    stage: string | null
    placementType: string | null
    name: string | null
    startPlacements: string | null
    endPlacements: string | null
    startSubmission: string | null
    endSubmission: string | null
    workflow: string | null
  }

  export type CohortsMaxAggregateOutputType = {
    cohortId: number | null
    designatedStaff: string | null
    oId: number | null
    product: string | null
    stage: string | null
    placementType: string | null
    name: string | null
    startPlacements: string | null
    endPlacements: string | null
    startSubmission: string | null
    endSubmission: string | null
    workflow: string | null
  }

  export type CohortsCountAggregateOutputType = {
    cohortId: number
    designatedStaff: number
    oId: number
    product: number
    stage: number
    placementType: number
    name: number
    startPlacements: number
    endPlacements: number
    startSubmission: number
    endSubmission: number
    includedFiles: number
    includedForms: number
    workflow: number
    _all: number
  }


  export type CohortsAvgAggregateInputType = {
    cohortId?: true
    oId?: true
  }

  export type CohortsSumAggregateInputType = {
    cohortId?: true
    oId?: true
  }

  export type CohortsMinAggregateInputType = {
    cohortId?: true
    designatedStaff?: true
    oId?: true
    product?: true
    stage?: true
    placementType?: true
    name?: true
    startPlacements?: true
    endPlacements?: true
    startSubmission?: true
    endSubmission?: true
    workflow?: true
  }

  export type CohortsMaxAggregateInputType = {
    cohortId?: true
    designatedStaff?: true
    oId?: true
    product?: true
    stage?: true
    placementType?: true
    name?: true
    startPlacements?: true
    endPlacements?: true
    startSubmission?: true
    endSubmission?: true
    workflow?: true
  }

  export type CohortsCountAggregateInputType = {
    cohortId?: true
    designatedStaff?: true
    oId?: true
    product?: true
    stage?: true
    placementType?: true
    name?: true
    startPlacements?: true
    endPlacements?: true
    startSubmission?: true
    endSubmission?: true
    includedFiles?: true
    includedForms?: true
    workflow?: true
    _all?: true
  }

  export type CohortsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cohorts to aggregate.
     */
    where?: CohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cohorts
    **/
    _count?: true | CohortsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CohortsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CohortsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CohortsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CohortsMaxAggregateInputType
  }

  export type GetCohortsAggregateType<T extends CohortsAggregateArgs> = {
        [P in keyof T & keyof AggregateCohorts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCohorts[P]>
      : GetScalarType<T[P], AggregateCohorts[P]>
  }




  export type CohortsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CohortsWhereInput
    orderBy?: CohortsOrderByWithAggregationInput | CohortsOrderByWithAggregationInput[]
    by: CohortsScalarFieldEnum[] | CohortsScalarFieldEnum
    having?: CohortsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CohortsCountAggregateInputType | true
    _avg?: CohortsAvgAggregateInputType
    _sum?: CohortsSumAggregateInputType
    _min?: CohortsMinAggregateInputType
    _max?: CohortsMaxAggregateInputType
  }

  export type CohortsGroupByOutputType = {
    cohortId: number
    designatedStaff: string
    oId: number
    product: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles: string[]
    includedForms: string[]
    workflow: string
    _count: CohortsCountAggregateOutputType | null
    _avg: CohortsAvgAggregateOutputType | null
    _sum: CohortsSumAggregateOutputType | null
    _min: CohortsMinAggregateOutputType | null
    _max: CohortsMaxAggregateOutputType | null
  }

  type GetCohortsGroupByPayload<T extends CohortsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CohortsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CohortsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CohortsGroupByOutputType[P]>
            : GetScalarType<T[P], CohortsGroupByOutputType[P]>
        }
      >
    >


  export type CohortsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cohortId?: boolean
    designatedStaff?: boolean
    oId?: boolean
    product?: boolean
    stage?: boolean
    placementType?: boolean
    name?: boolean
    startPlacements?: boolean
    endPlacements?: boolean
    startSubmission?: boolean
    endSubmission?: boolean
    includedFiles?: boolean
    includedForms?: boolean
    workflow?: boolean
  }, ExtArgs["result"]["cohorts"]>

  export type CohortsSelectScalar = {
    cohortId?: boolean
    designatedStaff?: boolean
    oId?: boolean
    product?: boolean
    stage?: boolean
    placementType?: boolean
    name?: boolean
    startPlacements?: boolean
    endPlacements?: boolean
    startSubmission?: boolean
    endSubmission?: boolean
    includedFiles?: boolean
    includedForms?: boolean
    workflow?: boolean
  }


  export type $CohortsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cohorts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cohortId: number
      designatedStaff: string
      oId: number
      product: string
      stage: string
      placementType: string
      name: string
      startPlacements: string
      endPlacements: string
      startSubmission: string
      endSubmission: string
      includedFiles: string[]
      includedForms: string[]
      workflow: string
    }, ExtArgs["result"]["cohorts"]>
    composites: {}
  }


  type CohortsGetPayload<S extends boolean | null | undefined | CohortsDefaultArgs> = $Result.GetResult<Prisma.$CohortsPayload, S>

  type CohortsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CohortsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CohortsCountAggregateInputType | true
    }

  export interface CohortsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cohorts'], meta: { name: 'Cohorts' } }
    /**
     * Find zero or one Cohorts that matches the filter.
     * @param {CohortsFindUniqueArgs} args - Arguments to find a Cohorts
     * @example
     * // Get one Cohorts
     * const cohorts = await prisma.cohorts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CohortsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsFindUniqueArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cohorts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CohortsFindUniqueOrThrowArgs} args - Arguments to find a Cohorts
     * @example
     * // Get one Cohorts
     * const cohorts = await prisma.cohorts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CohortsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cohorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsFindFirstArgs} args - Arguments to find a Cohorts
     * @example
     * // Get one Cohorts
     * const cohorts = await prisma.cohorts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CohortsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsFindFirstArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cohorts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsFindFirstOrThrowArgs} args - Arguments to find a Cohorts
     * @example
     * // Get one Cohorts
     * const cohorts = await prisma.cohorts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CohortsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cohorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cohorts
     * const cohorts = await prisma.cohorts.findMany()
     * 
     * // Get first 10 Cohorts
     * const cohorts = await prisma.cohorts.findMany({ take: 10 })
     * 
     * // Only select the `cohortId`
     * const cohortsWithCohortIdOnly = await prisma.cohorts.findMany({ select: { cohortId: true } })
     * 
    **/
    findMany<T extends CohortsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cohorts.
     * @param {CohortsCreateArgs} args - Arguments to create a Cohorts.
     * @example
     * // Create one Cohorts
     * const Cohorts = await prisma.cohorts.create({
     *   data: {
     *     // ... data to create a Cohorts
     *   }
     * })
     * 
    **/
    create<T extends CohortsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsCreateArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cohorts.
     *     @param {CohortsCreateManyArgs} args - Arguments to create many Cohorts.
     *     @example
     *     // Create many Cohorts
     *     const cohorts = await prisma.cohorts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CohortsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cohorts.
     * @param {CohortsDeleteArgs} args - Arguments to delete one Cohorts.
     * @example
     * // Delete one Cohorts
     * const Cohorts = await prisma.cohorts.delete({
     *   where: {
     *     // ... filter to delete one Cohorts
     *   }
     * })
     * 
    **/
    delete<T extends CohortsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsDeleteArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cohorts.
     * @param {CohortsUpdateArgs} args - Arguments to update one Cohorts.
     * @example
     * // Update one Cohorts
     * const cohorts = await prisma.cohorts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CohortsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsUpdateArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cohorts.
     * @param {CohortsDeleteManyArgs} args - Arguments to filter Cohorts to delete.
     * @example
     * // Delete a few Cohorts
     * const { count } = await prisma.cohorts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CohortsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CohortsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cohorts
     * const cohorts = await prisma.cohorts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CohortsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cohorts.
     * @param {CohortsUpsertArgs} args - Arguments to update or create a Cohorts.
     * @example
     * // Update or create a Cohorts
     * const cohorts = await prisma.cohorts.upsert({
     *   create: {
     *     // ... data to create a Cohorts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cohorts we want to update
     *   }
     * })
    **/
    upsert<T extends CohortsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CohortsUpsertArgs<ExtArgs>>
    ): Prisma__CohortsClient<$Result.GetResult<Prisma.$CohortsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsCountArgs} args - Arguments to filter Cohorts to count.
     * @example
     * // Count the number of Cohorts
     * const count = await prisma.cohorts.count({
     *   where: {
     *     // ... the filter for the Cohorts we want to count
     *   }
     * })
    **/
    count<T extends CohortsCountArgs>(
      args?: Subset<T, CohortsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CohortsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CohortsAggregateArgs>(args: Subset<T, CohortsAggregateArgs>): Prisma.PrismaPromise<GetCohortsAggregateType<T>>

    /**
     * Group by Cohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CohortsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CohortsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CohortsGroupByArgs['orderBy'] }
        : { orderBy?: CohortsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CohortsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCohortsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cohorts model
   */
  readonly fields: CohortsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cohorts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CohortsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Cohorts model
   */ 
  interface CohortsFieldRefs {
    readonly cohortId: FieldRef<"Cohorts", 'Int'>
    readonly designatedStaff: FieldRef<"Cohorts", 'String'>
    readonly oId: FieldRef<"Cohorts", 'Int'>
    readonly product: FieldRef<"Cohorts", 'String'>
    readonly stage: FieldRef<"Cohorts", 'String'>
    readonly placementType: FieldRef<"Cohorts", 'String'>
    readonly name: FieldRef<"Cohorts", 'String'>
    readonly startPlacements: FieldRef<"Cohorts", 'String'>
    readonly endPlacements: FieldRef<"Cohorts", 'String'>
    readonly startSubmission: FieldRef<"Cohorts", 'String'>
    readonly endSubmission: FieldRef<"Cohorts", 'String'>
    readonly includedFiles: FieldRef<"Cohorts", 'String[]'>
    readonly includedForms: FieldRef<"Cohorts", 'String[]'>
    readonly workflow: FieldRef<"Cohorts", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Cohorts findUnique
   */
  export type CohortsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where: CohortsWhereUniqueInput
  }


  /**
   * Cohorts findUniqueOrThrow
   */
  export type CohortsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where: CohortsWhereUniqueInput
  }


  /**
   * Cohorts findFirst
   */
  export type CohortsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where?: CohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cohorts.
     */
    cursor?: CohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cohorts.
     */
    distinct?: CohortsScalarFieldEnum | CohortsScalarFieldEnum[]
  }


  /**
   * Cohorts findFirstOrThrow
   */
  export type CohortsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where?: CohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cohorts.
     */
    cursor?: CohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cohorts.
     */
    distinct?: CohortsScalarFieldEnum | CohortsScalarFieldEnum[]
  }


  /**
   * Cohorts findMany
   */
  export type CohortsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Filter, which Cohorts to fetch.
     */
    where?: CohortsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cohorts to fetch.
     */
    orderBy?: CohortsOrderByWithRelationInput | CohortsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cohorts.
     */
    cursor?: CohortsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cohorts.
     */
    skip?: number
    distinct?: CohortsScalarFieldEnum | CohortsScalarFieldEnum[]
  }


  /**
   * Cohorts create
   */
  export type CohortsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * The data needed to create a Cohorts.
     */
    data: XOR<CohortsCreateInput, CohortsUncheckedCreateInput>
  }


  /**
   * Cohorts createMany
   */
  export type CohortsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cohorts.
     */
    data: CohortsCreateManyInput | CohortsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Cohorts update
   */
  export type CohortsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * The data needed to update a Cohorts.
     */
    data: XOR<CohortsUpdateInput, CohortsUncheckedUpdateInput>
    /**
     * Choose, which Cohorts to update.
     */
    where: CohortsWhereUniqueInput
  }


  /**
   * Cohorts updateMany
   */
  export type CohortsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cohorts.
     */
    data: XOR<CohortsUpdateManyMutationInput, CohortsUncheckedUpdateManyInput>
    /**
     * Filter which Cohorts to update
     */
    where?: CohortsWhereInput
  }


  /**
   * Cohorts upsert
   */
  export type CohortsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * The filter to search for the Cohorts to update in case it exists.
     */
    where: CohortsWhereUniqueInput
    /**
     * In case the Cohorts found by the `where` argument doesn't exist, create a new Cohorts with this data.
     */
    create: XOR<CohortsCreateInput, CohortsUncheckedCreateInput>
    /**
     * In case the Cohorts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CohortsUpdateInput, CohortsUncheckedUpdateInput>
  }


  /**
   * Cohorts delete
   */
  export type CohortsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
    /**
     * Filter which Cohorts to delete.
     */
    where: CohortsWhereUniqueInput
  }


  /**
   * Cohorts deleteMany
   */
  export type CohortsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cohorts to delete
     */
    where?: CohortsWhereInput
  }


  /**
   * Cohorts without action
   */
  export type CohortsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cohorts
     */
    select?: CohortsSelect<ExtArgs> | null
  }



  /**
   * Model Contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsAvgAggregateOutputType = {
    contactId: number | null
  }

  export type ContactsSumAggregateOutputType = {
    contactId: number | null
  }

  export type ContactsMinAggregateOutputType = {
    contactId: number | null
    address_line1: string | null
    address_line2: string | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    created: string | null
    locality: string | null
    name: string | null
    providerEmail: string | null
    providerPhone: string | null
    postal_code: string | null
    uid: string | null
  }

  export type ContactsMaxAggregateOutputType = {
    contactId: number | null
    address_line1: string | null
    address_line2: string | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    created: string | null
    locality: string | null
    name: string | null
    providerEmail: string | null
    providerPhone: string | null
    postal_code: string | null
    uid: string | null
  }

  export type ContactsCountAggregateOutputType = {
    contactId: number
    address_line1: number
    address_line2: number
    contactForename: number
    contactSurname: number
    country: number
    created: number
    locality: number
    name: number
    providerEmail: number
    providerPhone: number
    postal_code: number
    uid: number
    _all: number
  }


  export type ContactsAvgAggregateInputType = {
    contactId?: true
  }

  export type ContactsSumAggregateInputType = {
    contactId?: true
  }

  export type ContactsMinAggregateInputType = {
    contactId?: true
    address_line1?: true
    address_line2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    created?: true
    locality?: true
    name?: true
    providerEmail?: true
    providerPhone?: true
    postal_code?: true
    uid?: true
  }

  export type ContactsMaxAggregateInputType = {
    contactId?: true
    address_line1?: true
    address_line2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    created?: true
    locality?: true
    name?: true
    providerEmail?: true
    providerPhone?: true
    postal_code?: true
    uid?: true
  }

  export type ContactsCountAggregateInputType = {
    contactId?: true
    address_line1?: true
    address_line2?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    created?: true
    locality?: true
    name?: true
    providerEmail?: true
    providerPhone?: true
    postal_code?: true
    uid?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to aggregate.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type ContactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithAggregationInput | ContactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: ContactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _avg?: ContactsAvgAggregateInputType
    _sum?: ContactsSumAggregateInputType
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    contactId: number
    address_line1: string
    address_line2: string
    contactForename: string
    contactSurname: string
    country: string
    created: string
    locality: string
    name: string
    providerEmail: string
    providerPhone: string
    postal_code: string
    uid: string
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends ContactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type ContactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    address_line1?: boolean
    address_line2?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    country?: boolean
    created?: boolean
    locality?: boolean
    name?: boolean
    providerEmail?: boolean
    providerPhone?: boolean
    postal_code?: boolean
    uid?: boolean
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectScalar = {
    contactId?: boolean
    address_line1?: boolean
    address_line2?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    country?: boolean
    created?: boolean
    locality?: boolean
    name?: boolean
    providerEmail?: boolean
    providerPhone?: boolean
    postal_code?: boolean
    uid?: boolean
  }


  export type $ContactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contacts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      contactId: number
      address_line1: string
      address_line2: string
      contactForename: string
      contactSurname: string
      country: string
      created: string
      locality: string
      name: string
      providerEmail: string
      providerPhone: string
      postal_code: string
      uid: string
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }


  type ContactsGetPayload<S extends boolean | null | undefined | ContactsDefaultArgs> = $Result.GetResult<Prisma.$ContactsPayload, S>

  type ContactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface ContactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contacts'], meta: { name: 'Contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {ContactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contacts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsFindFirstArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `contactId`
     * const contactsWithContactIdOnly = await prisma.contacts.findMany({ select: { contactId: true } })
     * 
    **/
    findMany<T extends ContactsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contacts.
     * @param {ContactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
    **/
    create<T extends ContactsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsCreateArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contacts.
     *     @param {ContactsCreateManyArgs} args - Arguments to create many Contacts.
     *     @example
     *     // Create many Contacts
     *     const contacts = await prisma.contacts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contacts.
     * @param {ContactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
    **/
    delete<T extends ContactsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsDeleteArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contacts.
     * @param {ContactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsUpdateArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contacts.
     * @param {ContactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
    **/
    upsert<T extends ContactsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactsUpsertArgs<ExtArgs>>
    ): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactsCountArgs>(
      args?: Subset<T, ContactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactsGroupByArgs['orderBy'] }
        : { orderBy?: ContactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contacts model
   */
  readonly fields: ContactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Contacts model
   */ 
  interface ContactsFieldRefs {
    readonly contactId: FieldRef<"Contacts", 'Int'>
    readonly address_line1: FieldRef<"Contacts", 'String'>
    readonly address_line2: FieldRef<"Contacts", 'String'>
    readonly contactForename: FieldRef<"Contacts", 'String'>
    readonly contactSurname: FieldRef<"Contacts", 'String'>
    readonly country: FieldRef<"Contacts", 'String'>
    readonly created: FieldRef<"Contacts", 'String'>
    readonly locality: FieldRef<"Contacts", 'String'>
    readonly name: FieldRef<"Contacts", 'String'>
    readonly providerEmail: FieldRef<"Contacts", 'String'>
    readonly providerPhone: FieldRef<"Contacts", 'String'>
    readonly postal_code: FieldRef<"Contacts", 'String'>
    readonly uid: FieldRef<"Contacts", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Contacts findUnique
   */
  export type ContactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }


  /**
   * Contacts findUniqueOrThrow
   */
  export type ContactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }


  /**
   * Contacts findFirst
   */
  export type ContactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * Contacts findFirstOrThrow
   */
  export type ContactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * Contacts findMany
   */
  export type ContactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }


  /**
   * Contacts create
   */
  export type ContactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * The data needed to create a Contacts.
     */
    data: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
  }


  /**
   * Contacts createMany
   */
  export type ContactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactsCreateManyInput | ContactsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Contacts update
   */
  export type ContactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * The data needed to update a Contacts.
     */
    data: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
    /**
     * Choose, which Contacts to update.
     */
    where: ContactsWhereUniqueInput
  }


  /**
   * Contacts updateMany
   */
  export type ContactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactsWhereInput
  }


  /**
   * Contacts upsert
   */
  export type ContactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * The filter to search for the Contacts to update in case it exists.
     */
    where: ContactsWhereUniqueInput
    /**
     * In case the Contacts found by the `where` argument doesn't exist, create a new Contacts with this data.
     */
    create: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
    /**
     * In case the Contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
  }


  /**
   * Contacts delete
   */
  export type ContactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Filter which Contacts to delete.
     */
    where: ContactsWhereUniqueInput
  }


  /**
   * Contacts deleteMany
   */
  export type ContactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactsWhereInput
  }


  /**
   * Contacts without action
   */
  export type ContactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
  }



  /**
   * Model Downtime
   */

  export type AggregateDowntime = {
    _count: DowntimeCountAggregateOutputType | null
    _avg: DowntimeAvgAggregateOutputType | null
    _sum: DowntimeSumAggregateOutputType | null
    _min: DowntimeMinAggregateOutputType | null
    _max: DowntimeMaxAggregateOutputType | null
  }

  export type DowntimeAvgAggregateOutputType = {
    downtimeId: number | null
  }

  export type DowntimeSumAggregateOutputType = {
    downtimeId: number | null
  }

  export type DowntimeMinAggregateOutputType = {
    downtimeId: number | null
    active: boolean | null
    body: string | null
    title: string | null
  }

  export type DowntimeMaxAggregateOutputType = {
    downtimeId: number | null
    active: boolean | null
    body: string | null
    title: string | null
  }

  export type DowntimeCountAggregateOutputType = {
    downtimeId: number
    active: number
    body: number
    products: number
    title: number
    _all: number
  }


  export type DowntimeAvgAggregateInputType = {
    downtimeId?: true
  }

  export type DowntimeSumAggregateInputType = {
    downtimeId?: true
  }

  export type DowntimeMinAggregateInputType = {
    downtimeId?: true
    active?: true
    body?: true
    title?: true
  }

  export type DowntimeMaxAggregateInputType = {
    downtimeId?: true
    active?: true
    body?: true
    title?: true
  }

  export type DowntimeCountAggregateInputType = {
    downtimeId?: true
    active?: true
    body?: true
    products?: true
    title?: true
    _all?: true
  }

  export type DowntimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Downtime to aggregate.
     */
    where?: DowntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Downtimes to fetch.
     */
    orderBy?: DowntimeOrderByWithRelationInput | DowntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DowntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Downtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Downtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Downtimes
    **/
    _count?: true | DowntimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DowntimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DowntimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DowntimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DowntimeMaxAggregateInputType
  }

  export type GetDowntimeAggregateType<T extends DowntimeAggregateArgs> = {
        [P in keyof T & keyof AggregateDowntime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDowntime[P]>
      : GetScalarType<T[P], AggregateDowntime[P]>
  }




  export type DowntimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DowntimeWhereInput
    orderBy?: DowntimeOrderByWithAggregationInput | DowntimeOrderByWithAggregationInput[]
    by: DowntimeScalarFieldEnum[] | DowntimeScalarFieldEnum
    having?: DowntimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DowntimeCountAggregateInputType | true
    _avg?: DowntimeAvgAggregateInputType
    _sum?: DowntimeSumAggregateInputType
    _min?: DowntimeMinAggregateInputType
    _max?: DowntimeMaxAggregateInputType
  }

  export type DowntimeGroupByOutputType = {
    downtimeId: number
    active: boolean
    body: string
    products: string[]
    title: string
    _count: DowntimeCountAggregateOutputType | null
    _avg: DowntimeAvgAggregateOutputType | null
    _sum: DowntimeSumAggregateOutputType | null
    _min: DowntimeMinAggregateOutputType | null
    _max: DowntimeMaxAggregateOutputType | null
  }

  type GetDowntimeGroupByPayload<T extends DowntimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DowntimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DowntimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DowntimeGroupByOutputType[P]>
            : GetScalarType<T[P], DowntimeGroupByOutputType[P]>
        }
      >
    >


  export type DowntimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    downtimeId?: boolean
    active?: boolean
    body?: boolean
    products?: boolean
    title?: boolean
  }, ExtArgs["result"]["downtime"]>

  export type DowntimeSelectScalar = {
    downtimeId?: boolean
    active?: boolean
    body?: boolean
    products?: boolean
    title?: boolean
  }


  export type $DowntimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Downtime"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      downtimeId: number
      active: boolean
      body: string
      products: string[]
      title: string
    }, ExtArgs["result"]["downtime"]>
    composites: {}
  }


  type DowntimeGetPayload<S extends boolean | null | undefined | DowntimeDefaultArgs> = $Result.GetResult<Prisma.$DowntimePayload, S>

  type DowntimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DowntimeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DowntimeCountAggregateInputType | true
    }

  export interface DowntimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Downtime'], meta: { name: 'Downtime' } }
    /**
     * Find zero or one Downtime that matches the filter.
     * @param {DowntimeFindUniqueArgs} args - Arguments to find a Downtime
     * @example
     * // Get one Downtime
     * const downtime = await prisma.downtime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DowntimeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DowntimeFindUniqueArgs<ExtArgs>>
    ): Prisma__DowntimeClient<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Downtime that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DowntimeFindUniqueOrThrowArgs} args - Arguments to find a Downtime
     * @example
     * // Get one Downtime
     * const downtime = await prisma.downtime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DowntimeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DowntimeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DowntimeClient<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Downtime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeFindFirstArgs} args - Arguments to find a Downtime
     * @example
     * // Get one Downtime
     * const downtime = await prisma.downtime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DowntimeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DowntimeFindFirstArgs<ExtArgs>>
    ): Prisma__DowntimeClient<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Downtime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeFindFirstOrThrowArgs} args - Arguments to find a Downtime
     * @example
     * // Get one Downtime
     * const downtime = await prisma.downtime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DowntimeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DowntimeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DowntimeClient<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Downtimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Downtimes
     * const downtimes = await prisma.downtime.findMany()
     * 
     * // Get first 10 Downtimes
     * const downtimes = await prisma.downtime.findMany({ take: 10 })
     * 
     * // Only select the `downtimeId`
     * const downtimeWithDowntimeIdOnly = await prisma.downtime.findMany({ select: { downtimeId: true } })
     * 
    **/
    findMany<T extends DowntimeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DowntimeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Downtime.
     * @param {DowntimeCreateArgs} args - Arguments to create a Downtime.
     * @example
     * // Create one Downtime
     * const Downtime = await prisma.downtime.create({
     *   data: {
     *     // ... data to create a Downtime
     *   }
     * })
     * 
    **/
    create<T extends DowntimeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DowntimeCreateArgs<ExtArgs>>
    ): Prisma__DowntimeClient<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Downtimes.
     *     @param {DowntimeCreateManyArgs} args - Arguments to create many Downtimes.
     *     @example
     *     // Create many Downtimes
     *     const downtime = await prisma.downtime.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DowntimeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DowntimeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Downtime.
     * @param {DowntimeDeleteArgs} args - Arguments to delete one Downtime.
     * @example
     * // Delete one Downtime
     * const Downtime = await prisma.downtime.delete({
     *   where: {
     *     // ... filter to delete one Downtime
     *   }
     * })
     * 
    **/
    delete<T extends DowntimeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DowntimeDeleteArgs<ExtArgs>>
    ): Prisma__DowntimeClient<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Downtime.
     * @param {DowntimeUpdateArgs} args - Arguments to update one Downtime.
     * @example
     * // Update one Downtime
     * const downtime = await prisma.downtime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DowntimeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DowntimeUpdateArgs<ExtArgs>>
    ): Prisma__DowntimeClient<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Downtimes.
     * @param {DowntimeDeleteManyArgs} args - Arguments to filter Downtimes to delete.
     * @example
     * // Delete a few Downtimes
     * const { count } = await prisma.downtime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DowntimeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DowntimeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Downtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Downtimes
     * const downtime = await prisma.downtime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DowntimeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DowntimeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Downtime.
     * @param {DowntimeUpsertArgs} args - Arguments to update or create a Downtime.
     * @example
     * // Update or create a Downtime
     * const downtime = await prisma.downtime.upsert({
     *   create: {
     *     // ... data to create a Downtime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Downtime we want to update
     *   }
     * })
    **/
    upsert<T extends DowntimeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DowntimeUpsertArgs<ExtArgs>>
    ): Prisma__DowntimeClient<$Result.GetResult<Prisma.$DowntimePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Downtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeCountArgs} args - Arguments to filter Downtimes to count.
     * @example
     * // Count the number of Downtimes
     * const count = await prisma.downtime.count({
     *   where: {
     *     // ... the filter for the Downtimes we want to count
     *   }
     * })
    **/
    count<T extends DowntimeCountArgs>(
      args?: Subset<T, DowntimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DowntimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Downtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DowntimeAggregateArgs>(args: Subset<T, DowntimeAggregateArgs>): Prisma.PrismaPromise<GetDowntimeAggregateType<T>>

    /**
     * Group by Downtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DowntimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DowntimeGroupByArgs['orderBy'] }
        : { orderBy?: DowntimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DowntimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDowntimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Downtime model
   */
  readonly fields: DowntimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Downtime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DowntimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Downtime model
   */ 
  interface DowntimeFieldRefs {
    readonly downtimeId: FieldRef<"Downtime", 'Int'>
    readonly active: FieldRef<"Downtime", 'Boolean'>
    readonly body: FieldRef<"Downtime", 'String'>
    readonly products: FieldRef<"Downtime", 'String[]'>
    readonly title: FieldRef<"Downtime", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Downtime findUnique
   */
  export type DowntimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * Filter, which Downtime to fetch.
     */
    where: DowntimeWhereUniqueInput
  }


  /**
   * Downtime findUniqueOrThrow
   */
  export type DowntimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * Filter, which Downtime to fetch.
     */
    where: DowntimeWhereUniqueInput
  }


  /**
   * Downtime findFirst
   */
  export type DowntimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * Filter, which Downtime to fetch.
     */
    where?: DowntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Downtimes to fetch.
     */
    orderBy?: DowntimeOrderByWithRelationInput | DowntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Downtimes.
     */
    cursor?: DowntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Downtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Downtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Downtimes.
     */
    distinct?: DowntimeScalarFieldEnum | DowntimeScalarFieldEnum[]
  }


  /**
   * Downtime findFirstOrThrow
   */
  export type DowntimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * Filter, which Downtime to fetch.
     */
    where?: DowntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Downtimes to fetch.
     */
    orderBy?: DowntimeOrderByWithRelationInput | DowntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Downtimes.
     */
    cursor?: DowntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Downtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Downtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Downtimes.
     */
    distinct?: DowntimeScalarFieldEnum | DowntimeScalarFieldEnum[]
  }


  /**
   * Downtime findMany
   */
  export type DowntimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * Filter, which Downtimes to fetch.
     */
    where?: DowntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Downtimes to fetch.
     */
    orderBy?: DowntimeOrderByWithRelationInput | DowntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Downtimes.
     */
    cursor?: DowntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Downtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Downtimes.
     */
    skip?: number
    distinct?: DowntimeScalarFieldEnum | DowntimeScalarFieldEnum[]
  }


  /**
   * Downtime create
   */
  export type DowntimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * The data needed to create a Downtime.
     */
    data: XOR<DowntimeCreateInput, DowntimeUncheckedCreateInput>
  }


  /**
   * Downtime createMany
   */
  export type DowntimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Downtimes.
     */
    data: DowntimeCreateManyInput | DowntimeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Downtime update
   */
  export type DowntimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * The data needed to update a Downtime.
     */
    data: XOR<DowntimeUpdateInput, DowntimeUncheckedUpdateInput>
    /**
     * Choose, which Downtime to update.
     */
    where: DowntimeWhereUniqueInput
  }


  /**
   * Downtime updateMany
   */
  export type DowntimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Downtimes.
     */
    data: XOR<DowntimeUpdateManyMutationInput, DowntimeUncheckedUpdateManyInput>
    /**
     * Filter which Downtimes to update
     */
    where?: DowntimeWhereInput
  }


  /**
   * Downtime upsert
   */
  export type DowntimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * The filter to search for the Downtime to update in case it exists.
     */
    where: DowntimeWhereUniqueInput
    /**
     * In case the Downtime found by the `where` argument doesn't exist, create a new Downtime with this data.
     */
    create: XOR<DowntimeCreateInput, DowntimeUncheckedCreateInput>
    /**
     * In case the Downtime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DowntimeUpdateInput, DowntimeUncheckedUpdateInput>
  }


  /**
   * Downtime delete
   */
  export type DowntimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
    /**
     * Filter which Downtime to delete.
     */
    where: DowntimeWhereUniqueInput
  }


  /**
   * Downtime deleteMany
   */
  export type DowntimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Downtimes to delete
     */
    where?: DowntimeWhereInput
  }


  /**
   * Downtime without action
   */
  export type DowntimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Downtime
     */
    select?: DowntimeSelect<ExtArgs> | null
  }



  /**
   * Model FeatureRequests
   */

  export type AggregateFeatureRequests = {
    _count: FeatureRequestsCountAggregateOutputType | null
    _avg: FeatureRequestsAvgAggregateOutputType | null
    _sum: FeatureRequestsSumAggregateOutputType | null
    _min: FeatureRequestsMinAggregateOutputType | null
    _max: FeatureRequestsMaxAggregateOutputType | null
  }

  export type FeatureRequestsAvgAggregateOutputType = {
    featureRequestId: number | null
  }

  export type FeatureRequestsSumAggregateOutputType = {
    featureRequestId: number | null
  }

  export type FeatureRequestsMinAggregateOutputType = {
    featureRequestId: number | null
    date: Date | null
    description: string | null
    feature: string | null
    impact: string | null
    uid: string | null
  }

  export type FeatureRequestsMaxAggregateOutputType = {
    featureRequestId: number | null
    date: Date | null
    description: string | null
    feature: string | null
    impact: string | null
    uid: string | null
  }

  export type FeatureRequestsCountAggregateOutputType = {
    featureRequestId: number
    date: number
    description: number
    feature: number
    impact: number
    uid: number
    _all: number
  }


  export type FeatureRequestsAvgAggregateInputType = {
    featureRequestId?: true
  }

  export type FeatureRequestsSumAggregateInputType = {
    featureRequestId?: true
  }

  export type FeatureRequestsMinAggregateInputType = {
    featureRequestId?: true
    date?: true
    description?: true
    feature?: true
    impact?: true
    uid?: true
  }

  export type FeatureRequestsMaxAggregateInputType = {
    featureRequestId?: true
    date?: true
    description?: true
    feature?: true
    impact?: true
    uid?: true
  }

  export type FeatureRequestsCountAggregateInputType = {
    featureRequestId?: true
    date?: true
    description?: true
    feature?: true
    impact?: true
    uid?: true
    _all?: true
  }

  export type FeatureRequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureRequests to aggregate.
     */
    where?: FeatureRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     */
    orderBy?: FeatureRequestsOrderByWithRelationInput | FeatureRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureRequests
    **/
    _count?: true | FeatureRequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureRequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureRequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureRequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureRequestsMaxAggregateInputType
  }

  export type GetFeatureRequestsAggregateType<T extends FeatureRequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureRequests[P]>
      : GetScalarType<T[P], AggregateFeatureRequests[P]>
  }




  export type FeatureRequestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureRequestsWhereInput
    orderBy?: FeatureRequestsOrderByWithAggregationInput | FeatureRequestsOrderByWithAggregationInput[]
    by: FeatureRequestsScalarFieldEnum[] | FeatureRequestsScalarFieldEnum
    having?: FeatureRequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureRequestsCountAggregateInputType | true
    _avg?: FeatureRequestsAvgAggregateInputType
    _sum?: FeatureRequestsSumAggregateInputType
    _min?: FeatureRequestsMinAggregateInputType
    _max?: FeatureRequestsMaxAggregateInputType
  }

  export type FeatureRequestsGroupByOutputType = {
    featureRequestId: number
    date: Date
    description: string
    feature: string
    impact: string
    uid: string
    _count: FeatureRequestsCountAggregateOutputType | null
    _avg: FeatureRequestsAvgAggregateOutputType | null
    _sum: FeatureRequestsSumAggregateOutputType | null
    _min: FeatureRequestsMinAggregateOutputType | null
    _max: FeatureRequestsMaxAggregateOutputType | null
  }

  type GetFeatureRequestsGroupByPayload<T extends FeatureRequestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureRequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureRequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureRequestsGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureRequestsGroupByOutputType[P]>
        }
      >
    >


  export type FeatureRequestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featureRequestId?: boolean
    date?: boolean
    description?: boolean
    feature?: boolean
    impact?: boolean
    uid?: boolean
  }, ExtArgs["result"]["featureRequests"]>

  export type FeatureRequestsSelectScalar = {
    featureRequestId?: boolean
    date?: boolean
    description?: boolean
    feature?: boolean
    impact?: boolean
    uid?: boolean
  }


  export type $FeatureRequestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureRequests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      featureRequestId: number
      date: Date
      description: string
      feature: string
      impact: string
      uid: string
    }, ExtArgs["result"]["featureRequests"]>
    composites: {}
  }


  type FeatureRequestsGetPayload<S extends boolean | null | undefined | FeatureRequestsDefaultArgs> = $Result.GetResult<Prisma.$FeatureRequestsPayload, S>

  type FeatureRequestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeatureRequestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeatureRequestsCountAggregateInputType | true
    }

  export interface FeatureRequestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureRequests'], meta: { name: 'FeatureRequests' } }
    /**
     * Find zero or one FeatureRequests that matches the filter.
     * @param {FeatureRequestsFindUniqueArgs} args - Arguments to find a FeatureRequests
     * @example
     * // Get one FeatureRequests
     * const featureRequests = await prisma.featureRequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeatureRequestsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeatureRequestsFindUniqueArgs<ExtArgs>>
    ): Prisma__FeatureRequestsClient<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeatureRequests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeatureRequestsFindUniqueOrThrowArgs} args - Arguments to find a FeatureRequests
     * @example
     * // Get one FeatureRequests
     * const featureRequests = await prisma.featureRequests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeatureRequestsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeatureRequestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeatureRequestsClient<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeatureRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestsFindFirstArgs} args - Arguments to find a FeatureRequests
     * @example
     * // Get one FeatureRequests
     * const featureRequests = await prisma.featureRequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeatureRequestsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeatureRequestsFindFirstArgs<ExtArgs>>
    ): Prisma__FeatureRequestsClient<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeatureRequests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestsFindFirstOrThrowArgs} args - Arguments to find a FeatureRequests
     * @example
     * // Get one FeatureRequests
     * const featureRequests = await prisma.featureRequests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeatureRequestsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeatureRequestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeatureRequestsClient<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeatureRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureRequests
     * const featureRequests = await prisma.featureRequests.findMany()
     * 
     * // Get first 10 FeatureRequests
     * const featureRequests = await prisma.featureRequests.findMany({ take: 10 })
     * 
     * // Only select the `featureRequestId`
     * const featureRequestsWithFeatureRequestIdOnly = await prisma.featureRequests.findMany({ select: { featureRequestId: true } })
     * 
    **/
    findMany<T extends FeatureRequestsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeatureRequestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeatureRequests.
     * @param {FeatureRequestsCreateArgs} args - Arguments to create a FeatureRequests.
     * @example
     * // Create one FeatureRequests
     * const FeatureRequests = await prisma.featureRequests.create({
     *   data: {
     *     // ... data to create a FeatureRequests
     *   }
     * })
     * 
    **/
    create<T extends FeatureRequestsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeatureRequestsCreateArgs<ExtArgs>>
    ): Prisma__FeatureRequestsClient<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FeatureRequests.
     *     @param {FeatureRequestsCreateManyArgs} args - Arguments to create many FeatureRequests.
     *     @example
     *     // Create many FeatureRequests
     *     const featureRequests = await prisma.featureRequests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeatureRequestsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeatureRequestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeatureRequests.
     * @param {FeatureRequestsDeleteArgs} args - Arguments to delete one FeatureRequests.
     * @example
     * // Delete one FeatureRequests
     * const FeatureRequests = await prisma.featureRequests.delete({
     *   where: {
     *     // ... filter to delete one FeatureRequests
     *   }
     * })
     * 
    **/
    delete<T extends FeatureRequestsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeatureRequestsDeleteArgs<ExtArgs>>
    ): Prisma__FeatureRequestsClient<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeatureRequests.
     * @param {FeatureRequestsUpdateArgs} args - Arguments to update one FeatureRequests.
     * @example
     * // Update one FeatureRequests
     * const featureRequests = await prisma.featureRequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeatureRequestsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeatureRequestsUpdateArgs<ExtArgs>>
    ): Prisma__FeatureRequestsClient<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeatureRequests.
     * @param {FeatureRequestsDeleteManyArgs} args - Arguments to filter FeatureRequests to delete.
     * @example
     * // Delete a few FeatureRequests
     * const { count } = await prisma.featureRequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeatureRequestsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeatureRequestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureRequests
     * const featureRequests = await prisma.featureRequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeatureRequestsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeatureRequestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeatureRequests.
     * @param {FeatureRequestsUpsertArgs} args - Arguments to update or create a FeatureRequests.
     * @example
     * // Update or create a FeatureRequests
     * const featureRequests = await prisma.featureRequests.upsert({
     *   create: {
     *     // ... data to create a FeatureRequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureRequests we want to update
     *   }
     * })
    **/
    upsert<T extends FeatureRequestsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeatureRequestsUpsertArgs<ExtArgs>>
    ): Prisma__FeatureRequestsClient<$Result.GetResult<Prisma.$FeatureRequestsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestsCountArgs} args - Arguments to filter FeatureRequests to count.
     * @example
     * // Count the number of FeatureRequests
     * const count = await prisma.featureRequests.count({
     *   where: {
     *     // ... the filter for the FeatureRequests we want to count
     *   }
     * })
    **/
    count<T extends FeatureRequestsCountArgs>(
      args?: Subset<T, FeatureRequestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureRequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureRequestsAggregateArgs>(args: Subset<T, FeatureRequestsAggregateArgs>): Prisma.PrismaPromise<GetFeatureRequestsAggregateType<T>>

    /**
     * Group by FeatureRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureRequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureRequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureRequestsGroupByArgs['orderBy'] }
        : { orderBy?: FeatureRequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureRequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureRequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureRequests model
   */
  readonly fields: FeatureRequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureRequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureRequestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeatureRequests model
   */ 
  interface FeatureRequestsFieldRefs {
    readonly featureRequestId: FieldRef<"FeatureRequests", 'Int'>
    readonly date: FieldRef<"FeatureRequests", 'DateTime'>
    readonly description: FieldRef<"FeatureRequests", 'String'>
    readonly feature: FieldRef<"FeatureRequests", 'String'>
    readonly impact: FieldRef<"FeatureRequests", 'String'>
    readonly uid: FieldRef<"FeatureRequests", 'String'>
  }
    

  // Custom InputTypes

  /**
   * FeatureRequests findUnique
   */
  export type FeatureRequestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequests to fetch.
     */
    where: FeatureRequestsWhereUniqueInput
  }


  /**
   * FeatureRequests findUniqueOrThrow
   */
  export type FeatureRequestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequests to fetch.
     */
    where: FeatureRequestsWhereUniqueInput
  }


  /**
   * FeatureRequests findFirst
   */
  export type FeatureRequestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequests to fetch.
     */
    where?: FeatureRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     */
    orderBy?: FeatureRequestsOrderByWithRelationInput | FeatureRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureRequests.
     */
    cursor?: FeatureRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureRequests.
     */
    distinct?: FeatureRequestsScalarFieldEnum | FeatureRequestsScalarFieldEnum[]
  }


  /**
   * FeatureRequests findFirstOrThrow
   */
  export type FeatureRequestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequests to fetch.
     */
    where?: FeatureRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     */
    orderBy?: FeatureRequestsOrderByWithRelationInput | FeatureRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureRequests.
     */
    cursor?: FeatureRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureRequests.
     */
    distinct?: FeatureRequestsScalarFieldEnum | FeatureRequestsScalarFieldEnum[]
  }


  /**
   * FeatureRequests findMany
   */
  export type FeatureRequestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * Filter, which FeatureRequests to fetch.
     */
    where?: FeatureRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureRequests to fetch.
     */
    orderBy?: FeatureRequestsOrderByWithRelationInput | FeatureRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureRequests.
     */
    cursor?: FeatureRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureRequests.
     */
    skip?: number
    distinct?: FeatureRequestsScalarFieldEnum | FeatureRequestsScalarFieldEnum[]
  }


  /**
   * FeatureRequests create
   */
  export type FeatureRequestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * The data needed to create a FeatureRequests.
     */
    data: XOR<FeatureRequestsCreateInput, FeatureRequestsUncheckedCreateInput>
  }


  /**
   * FeatureRequests createMany
   */
  export type FeatureRequestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureRequests.
     */
    data: FeatureRequestsCreateManyInput | FeatureRequestsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FeatureRequests update
   */
  export type FeatureRequestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * The data needed to update a FeatureRequests.
     */
    data: XOR<FeatureRequestsUpdateInput, FeatureRequestsUncheckedUpdateInput>
    /**
     * Choose, which FeatureRequests to update.
     */
    where: FeatureRequestsWhereUniqueInput
  }


  /**
   * FeatureRequests updateMany
   */
  export type FeatureRequestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureRequests.
     */
    data: XOR<FeatureRequestsUpdateManyMutationInput, FeatureRequestsUncheckedUpdateManyInput>
    /**
     * Filter which FeatureRequests to update
     */
    where?: FeatureRequestsWhereInput
  }


  /**
   * FeatureRequests upsert
   */
  export type FeatureRequestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * The filter to search for the FeatureRequests to update in case it exists.
     */
    where: FeatureRequestsWhereUniqueInput
    /**
     * In case the FeatureRequests found by the `where` argument doesn't exist, create a new FeatureRequests with this data.
     */
    create: XOR<FeatureRequestsCreateInput, FeatureRequestsUncheckedCreateInput>
    /**
     * In case the FeatureRequests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureRequestsUpdateInput, FeatureRequestsUncheckedUpdateInput>
  }


  /**
   * FeatureRequests delete
   */
  export type FeatureRequestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
    /**
     * Filter which FeatureRequests to delete.
     */
    where: FeatureRequestsWhereUniqueInput
  }


  /**
   * FeatureRequests deleteMany
   */
  export type FeatureRequestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureRequests to delete
     */
    where?: FeatureRequestsWhereInput
  }


  /**
   * FeatureRequests without action
   */
  export type FeatureRequestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureRequests
     */
    select?: FeatureRequestsSelect<ExtArgs> | null
  }



  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    feedbackId: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    feedbackId: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    feedbackId: number | null
    created: Date | null
    msg: string | null
    title: string | null
    uid: string | null
  }

  export type FeedbackMaxAggregateOutputType = {
    feedbackId: number | null
    created: Date | null
    msg: string | null
    title: string | null
    uid: string | null
  }

  export type FeedbackCountAggregateOutputType = {
    feedbackId: number
    created: number
    msg: number
    title: number
    uid: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    feedbackId?: true
  }

  export type FeedbackSumAggregateInputType = {
    feedbackId?: true
  }

  export type FeedbackMinAggregateInputType = {
    feedbackId?: true
    created?: true
    msg?: true
    title?: true
    uid?: true
  }

  export type FeedbackMaxAggregateInputType = {
    feedbackId?: true
    created?: true
    msg?: true
    title?: true
    uid?: true
  }

  export type FeedbackCountAggregateInputType = {
    feedbackId?: true
    created?: true
    msg?: true
    title?: true
    uid?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    feedbackId: number
    created: Date
    msg: string
    title: string
    uid: string
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    feedbackId?: boolean
    created?: boolean
    msg?: boolean
    title?: boolean
    uid?: boolean
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    feedbackId?: boolean
    created?: boolean
    msg?: boolean
    title?: boolean
    uid?: boolean
  }


  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      feedbackId: number
      created: Date
      msg: string
      title: string
      uid: string
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }


  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `feedbackId`
     * const feedbackWithFeedbackIdOnly = await prisma.feedback.findMany({ select: { feedbackId: true } })
     * 
    **/
    findMany<T extends FeedbackFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
    **/
    create<T extends FeedbackCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Feedbacks.
     *     @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     *     @example
     *     // Create many Feedbacks
     *     const feedback = await prisma.feedback.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly feedbackId: FieldRef<"Feedback", 'Int'>
    readonly created: FieldRef<"Feedback", 'DateTime'>
    readonly msg: FieldRef<"Feedback", 'String'>
    readonly title: FieldRef<"Feedback", 'String'>
    readonly uid: FieldRef<"Feedback", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }


  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }


  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }


  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }


  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
  }



  /**
   * Model Forms
   */

  export type AggregateForms = {
    _count: FormsCountAggregateOutputType | null
    _avg: FormsAvgAggregateOutputType | null
    _sum: FormsSumAggregateOutputType | null
    _min: FormsMinAggregateOutputType | null
    _max: FormsMaxAggregateOutputType | null
  }

  export type FormsAvgAggregateOutputType = {
    formId: number | null
    oId: number | null
  }

  export type FormsSumAggregateOutputType = {
    formId: number | null
    oId: number | null
  }

  export type FormsMinAggregateOutputType = {
    formId: number | null
    oId: number | null
    product: string | null
    updated: string | null
  }

  export type FormsMaxAggregateOutputType = {
    formId: number | null
    oId: number | null
    product: string | null
    updated: string | null
  }

  export type FormsCountAggregateOutputType = {
    formId: number
    form: number
    oId: number
    product: number
    updated: number
    _all: number
  }


  export type FormsAvgAggregateInputType = {
    formId?: true
    oId?: true
  }

  export type FormsSumAggregateInputType = {
    formId?: true
    oId?: true
  }

  export type FormsMinAggregateInputType = {
    formId?: true
    oId?: true
    product?: true
    updated?: true
  }

  export type FormsMaxAggregateInputType = {
    formId?: true
    oId?: true
    product?: true
    updated?: true
  }

  export type FormsCountAggregateInputType = {
    formId?: true
    form?: true
    oId?: true
    product?: true
    updated?: true
    _all?: true
  }

  export type FormsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to aggregate.
     */
    where?: FormsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormsOrderByWithRelationInput | FormsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormsMaxAggregateInputType
  }

  export type GetFormsAggregateType<T extends FormsAggregateArgs> = {
        [P in keyof T & keyof AggregateForms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForms[P]>
      : GetScalarType<T[P], AggregateForms[P]>
  }




  export type FormsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormsWhereInput
    orderBy?: FormsOrderByWithAggregationInput | FormsOrderByWithAggregationInput[]
    by: FormsScalarFieldEnum[] | FormsScalarFieldEnum
    having?: FormsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormsCountAggregateInputType | true
    _avg?: FormsAvgAggregateInputType
    _sum?: FormsSumAggregateInputType
    _min?: FormsMinAggregateInputType
    _max?: FormsMaxAggregateInputType
  }

  export type FormsGroupByOutputType = {
    formId: number
    form: JsonValue
    oId: number
    product: string
    updated: string
    _count: FormsCountAggregateOutputType | null
    _avg: FormsAvgAggregateOutputType | null
    _sum: FormsSumAggregateOutputType | null
    _min: FormsMinAggregateOutputType | null
    _max: FormsMaxAggregateOutputType | null
  }

  type GetFormsGroupByPayload<T extends FormsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormsGroupByOutputType[P]>
            : GetScalarType<T[P], FormsGroupByOutputType[P]>
        }
      >
    >


  export type FormsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    formId?: boolean
    form?: boolean
    oId?: boolean
    product?: boolean
    updated?: boolean
  }, ExtArgs["result"]["forms"]>

  export type FormsSelectScalar = {
    formId?: boolean
    form?: boolean
    oId?: boolean
    product?: boolean
    updated?: boolean
  }


  export type $FormsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Forms"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      formId: number
      form: Prisma.JsonValue
      oId: number
      product: string
      updated: string
    }, ExtArgs["result"]["forms"]>
    composites: {}
  }


  type FormsGetPayload<S extends boolean | null | undefined | FormsDefaultArgs> = $Result.GetResult<Prisma.$FormsPayload, S>

  type FormsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormsCountAggregateInputType | true
    }

  export interface FormsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Forms'], meta: { name: 'Forms' } }
    /**
     * Find zero or one Forms that matches the filter.
     * @param {FormsFindUniqueArgs} args - Arguments to find a Forms
     * @example
     * // Get one Forms
     * const forms = await prisma.forms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormsFindUniqueArgs<ExtArgs>>
    ): Prisma__FormsClient<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Forms that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormsFindUniqueOrThrowArgs} args - Arguments to find a Forms
     * @example
     * // Get one Forms
     * const forms = await prisma.forms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormsClient<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormsFindFirstArgs} args - Arguments to find a Forms
     * @example
     * // Get one Forms
     * const forms = await prisma.forms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormsFindFirstArgs<ExtArgs>>
    ): Prisma__FormsClient<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Forms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormsFindFirstOrThrowArgs} args - Arguments to find a Forms
     * @example
     * // Get one Forms
     * const forms = await prisma.forms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormsClient<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.forms.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.forms.findMany({ take: 10 })
     * 
     * // Only select the `formId`
     * const formsWithFormIdOnly = await prisma.forms.findMany({ select: { formId: true } })
     * 
    **/
    findMany<T extends FormsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Forms.
     * @param {FormsCreateArgs} args - Arguments to create a Forms.
     * @example
     * // Create one Forms
     * const Forms = await prisma.forms.create({
     *   data: {
     *     // ... data to create a Forms
     *   }
     * })
     * 
    **/
    create<T extends FormsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormsCreateArgs<ExtArgs>>
    ): Prisma__FormsClient<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Forms.
     *     @param {FormsCreateManyArgs} args - Arguments to create many Forms.
     *     @example
     *     // Create many Forms
     *     const forms = await prisma.forms.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Forms.
     * @param {FormsDeleteArgs} args - Arguments to delete one Forms.
     * @example
     * // Delete one Forms
     * const Forms = await prisma.forms.delete({
     *   where: {
     *     // ... filter to delete one Forms
     *   }
     * })
     * 
    **/
    delete<T extends FormsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormsDeleteArgs<ExtArgs>>
    ): Prisma__FormsClient<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Forms.
     * @param {FormsUpdateArgs} args - Arguments to update one Forms.
     * @example
     * // Update one Forms
     * const forms = await prisma.forms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormsUpdateArgs<ExtArgs>>
    ): Prisma__FormsClient<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Forms.
     * @param {FormsDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.forms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const forms = await prisma.forms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Forms.
     * @param {FormsUpsertArgs} args - Arguments to update or create a Forms.
     * @example
     * // Update or create a Forms
     * const forms = await prisma.forms.upsert({
     *   create: {
     *     // ... data to create a Forms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Forms we want to update
     *   }
     * })
    **/
    upsert<T extends FormsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormsUpsertArgs<ExtArgs>>
    ): Prisma__FormsClient<$Result.GetResult<Prisma.$FormsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormsCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.forms.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormsCountArgs>(
      args?: Subset<T, FormsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormsAggregateArgs>(args: Subset<T, FormsAggregateArgs>): Prisma.PrismaPromise<GetFormsAggregateType<T>>

    /**
     * Group by Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormsGroupByArgs['orderBy'] }
        : { orderBy?: FormsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Forms model
   */
  readonly fields: FormsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Forms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Forms model
   */ 
  interface FormsFieldRefs {
    readonly formId: FieldRef<"Forms", 'Int'>
    readonly form: FieldRef<"Forms", 'Json'>
    readonly oId: FieldRef<"Forms", 'Int'>
    readonly product: FieldRef<"Forms", 'String'>
    readonly updated: FieldRef<"Forms", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Forms findUnique
   */
  export type FormsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where: FormsWhereUniqueInput
  }


  /**
   * Forms findUniqueOrThrow
   */
  export type FormsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where: FormsWhereUniqueInput
  }


  /**
   * Forms findFirst
   */
  export type FormsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormsOrderByWithRelationInput | FormsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormsScalarFieldEnum | FormsScalarFieldEnum[]
  }


  /**
   * Forms findFirstOrThrow
   */
  export type FormsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormsOrderByWithRelationInput | FormsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormsScalarFieldEnum | FormsScalarFieldEnum[]
  }


  /**
   * Forms findMany
   */
  export type FormsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormsOrderByWithRelationInput | FormsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     */
    cursor?: FormsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    distinct?: FormsScalarFieldEnum | FormsScalarFieldEnum[]
  }


  /**
   * Forms create
   */
  export type FormsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * The data needed to create a Forms.
     */
    data: XOR<FormsCreateInput, FormsUncheckedCreateInput>
  }


  /**
   * Forms createMany
   */
  export type FormsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forms.
     */
    data: FormsCreateManyInput | FormsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Forms update
   */
  export type FormsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * The data needed to update a Forms.
     */
    data: XOR<FormsUpdateInput, FormsUncheckedUpdateInput>
    /**
     * Choose, which Forms to update.
     */
    where: FormsWhereUniqueInput
  }


  /**
   * Forms updateMany
   */
  export type FormsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forms.
     */
    data: XOR<FormsUpdateManyMutationInput, FormsUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormsWhereInput
  }


  /**
   * Forms upsert
   */
  export type FormsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * The filter to search for the Forms to update in case it exists.
     */
    where: FormsWhereUniqueInput
    /**
     * In case the Forms found by the `where` argument doesn't exist, create a new Forms with this data.
     */
    create: XOR<FormsCreateInput, FormsUncheckedCreateInput>
    /**
     * In case the Forms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormsUpdateInput, FormsUncheckedUpdateInput>
  }


  /**
   * Forms delete
   */
  export type FormsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
    /**
     * Filter which Forms to delete.
     */
    where: FormsWhereUniqueInput
  }


  /**
   * Forms deleteMany
   */
  export type FormsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to delete
     */
    where?: FormsWhereInput
  }


  /**
   * Forms without action
   */
  export type FormsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forms
     */
    select?: FormsSelect<ExtArgs> | null
  }



  /**
   * Model Institutes
   */

  export type AggregateInstitutes = {
    _count: InstitutesCountAggregateOutputType | null
    _avg: InstitutesAvgAggregateOutputType | null
    _sum: InstitutesSumAggregateOutputType | null
    _min: InstitutesMinAggregateOutputType | null
    _max: InstitutesMaxAggregateOutputType | null
  }

  export type InstitutesAvgAggregateOutputType = {
    instituteId: number | null
    staff: number | null
    staffActive: number | null
    students: number | null
    studentsActive: number | null
  }

  export type InstitutesSumAggregateOutputType = {
    instituteId: number | null
    staff: number | null
    staffActive: number | null
    students: number | null
    studentsActive: number | null
  }

  export type InstitutesMinAggregateOutputType = {
    instituteId: number | null
    address_line1: string | null
    address_line2: string | null
    admin: string | null
    country: string | null
    externalProviderUploads: boolean | null
    geoHash: string | null
    locality: string | null
    name: string | null
    postal_code: string | null
    referral: string | null
    status: string | null
    staff: number | null
    staffActive: number | null
    students: number | null
    studentsActive: number | null
  }

  export type InstitutesMaxAggregateOutputType = {
    instituteId: number | null
    address_line1: string | null
    address_line2: string | null
    admin: string | null
    country: string | null
    externalProviderUploads: boolean | null
    geoHash: string | null
    locality: string | null
    name: string | null
    postal_code: string | null
    referral: string | null
    status: string | null
    staff: number | null
    staffActive: number | null
    students: number | null
    studentsActive: number | null
  }

  export type InstitutesCountAggregateOutputType = {
    instituteId: number
    address_line1: number
    address_line2: number
    admin: number
    country: number
    externalProviderUploads: number
    geoHash: number
    locality: number
    name: number
    postal_code: number
    referral: number
    status: number
    studentsFields: number
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields: number
    staffGuidance: number
    studentsGuidance: number
    verifiedProviders: number
    _all: number
  }


  export type InstitutesAvgAggregateInputType = {
    instituteId?: true
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
  }

  export type InstitutesSumAggregateInputType = {
    instituteId?: true
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
  }

  export type InstitutesMinAggregateInputType = {
    instituteId?: true
    address_line1?: true
    address_line2?: true
    admin?: true
    country?: true
    externalProviderUploads?: true
    geoHash?: true
    locality?: true
    name?: true
    postal_code?: true
    referral?: true
    status?: true
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
  }

  export type InstitutesMaxAggregateInputType = {
    instituteId?: true
    address_line1?: true
    address_line2?: true
    admin?: true
    country?: true
    externalProviderUploads?: true
    geoHash?: true
    locality?: true
    name?: true
    postal_code?: true
    referral?: true
    status?: true
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
  }

  export type InstitutesCountAggregateInputType = {
    instituteId?: true
    address_line1?: true
    address_line2?: true
    admin?: true
    country?: true
    externalProviderUploads?: true
    geoHash?: true
    locality?: true
    name?: true
    postal_code?: true
    referral?: true
    status?: true
    studentsFields?: true
    staff?: true
    staffActive?: true
    students?: true
    studentsActive?: true
    staffFields?: true
    staffGuidance?: true
    studentsGuidance?: true
    verifiedProviders?: true
    _all?: true
  }

  export type InstitutesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutes to aggregate.
     */
    where?: InstitutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstitutesOrderByWithRelationInput | InstitutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutes
    **/
    _count?: true | InstitutesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstitutesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstitutesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutesMaxAggregateInputType
  }

  export type GetInstitutesAggregateType<T extends InstitutesAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitutes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitutes[P]>
      : GetScalarType<T[P], AggregateInstitutes[P]>
  }




  export type InstitutesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutesWhereInput
    orderBy?: InstitutesOrderByWithAggregationInput | InstitutesOrderByWithAggregationInput[]
    by: InstitutesScalarFieldEnum[] | InstitutesScalarFieldEnum
    having?: InstitutesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutesCountAggregateInputType | true
    _avg?: InstitutesAvgAggregateInputType
    _sum?: InstitutesSumAggregateInputType
    _min?: InstitutesMinAggregateInputType
    _max?: InstitutesMaxAggregateInputType
  }

  export type InstitutesGroupByOutputType = {
    instituteId: number
    address_line1: string
    address_line2: string
    admin: string
    country: string
    externalProviderUploads: boolean
    geoHash: string
    locality: string
    name: string
    postal_code: string
    referral: string | null
    status: string
    studentsFields: string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields: string[]
    staffGuidance: JsonValue
    studentsGuidance: JsonValue
    verifiedProviders: string[]
    _count: InstitutesCountAggregateOutputType | null
    _avg: InstitutesAvgAggregateOutputType | null
    _sum: InstitutesSumAggregateOutputType | null
    _min: InstitutesMinAggregateOutputType | null
    _max: InstitutesMaxAggregateOutputType | null
  }

  type GetInstitutesGroupByPayload<T extends InstitutesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutesGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutesGroupByOutputType[P]>
        }
      >
    >


  export type InstitutesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instituteId?: boolean
    address_line1?: boolean
    address_line2?: boolean
    admin?: boolean
    country?: boolean
    externalProviderUploads?: boolean
    geoHash?: boolean
    locality?: boolean
    name?: boolean
    postal_code?: boolean
    referral?: boolean
    status?: boolean
    studentsFields?: boolean
    staff?: boolean
    staffActive?: boolean
    students?: boolean
    studentsActive?: boolean
    staffFields?: boolean
    staffGuidance?: boolean
    studentsGuidance?: boolean
    verifiedProviders?: boolean
  }, ExtArgs["result"]["institutes"]>

  export type InstitutesSelectScalar = {
    instituteId?: boolean
    address_line1?: boolean
    address_line2?: boolean
    admin?: boolean
    country?: boolean
    externalProviderUploads?: boolean
    geoHash?: boolean
    locality?: boolean
    name?: boolean
    postal_code?: boolean
    referral?: boolean
    status?: boolean
    studentsFields?: boolean
    staff?: boolean
    staffActive?: boolean
    students?: boolean
    studentsActive?: boolean
    staffFields?: boolean
    staffGuidance?: boolean
    studentsGuidance?: boolean
    verifiedProviders?: boolean
  }


  export type $InstitutesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institutes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      instituteId: number
      address_line1: string
      address_line2: string
      admin: string
      country: string
      externalProviderUploads: boolean
      geoHash: string
      locality: string
      name: string
      postal_code: string
      referral: string | null
      status: string
      studentsFields: string[]
      staff: number
      staffActive: number
      students: number
      studentsActive: number
      staffFields: string[]
      staffGuidance: Prisma.JsonValue
      studentsGuidance: Prisma.JsonValue
      verifiedProviders: string[]
    }, ExtArgs["result"]["institutes"]>
    composites: {}
  }


  type InstitutesGetPayload<S extends boolean | null | undefined | InstitutesDefaultArgs> = $Result.GetResult<Prisma.$InstitutesPayload, S>

  type InstitutesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstitutesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstitutesCountAggregateInputType | true
    }

  export interface InstitutesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institutes'], meta: { name: 'Institutes' } }
    /**
     * Find zero or one Institutes that matches the filter.
     * @param {InstitutesFindUniqueArgs} args - Arguments to find a Institutes
     * @example
     * // Get one Institutes
     * const institutes = await prisma.institutes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstitutesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesFindUniqueArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Institutes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstitutesFindUniqueOrThrowArgs} args - Arguments to find a Institutes
     * @example
     * // Get one Institutes
     * const institutes = await prisma.institutes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstitutesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Institutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesFindFirstArgs} args - Arguments to find a Institutes
     * @example
     * // Get one Institutes
     * const institutes = await prisma.institutes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstitutesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesFindFirstArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Institutes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesFindFirstOrThrowArgs} args - Arguments to find a Institutes
     * @example
     * // Get one Institutes
     * const institutes = await prisma.institutes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstitutesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Institutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutes
     * const institutes = await prisma.institutes.findMany()
     * 
     * // Get first 10 Institutes
     * const institutes = await prisma.institutes.findMany({ take: 10 })
     * 
     * // Only select the `instituteId`
     * const institutesWithInstituteIdOnly = await prisma.institutes.findMany({ select: { instituteId: true } })
     * 
    **/
    findMany<T extends InstitutesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Institutes.
     * @param {InstitutesCreateArgs} args - Arguments to create a Institutes.
     * @example
     * // Create one Institutes
     * const Institutes = await prisma.institutes.create({
     *   data: {
     *     // ... data to create a Institutes
     *   }
     * })
     * 
    **/
    create<T extends InstitutesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesCreateArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Institutes.
     *     @param {InstitutesCreateManyArgs} args - Arguments to create many Institutes.
     *     @example
     *     // Create many Institutes
     *     const institutes = await prisma.institutes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstitutesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Institutes.
     * @param {InstitutesDeleteArgs} args - Arguments to delete one Institutes.
     * @example
     * // Delete one Institutes
     * const Institutes = await prisma.institutes.delete({
     *   where: {
     *     // ... filter to delete one Institutes
     *   }
     * })
     * 
    **/
    delete<T extends InstitutesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesDeleteArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Institutes.
     * @param {InstitutesUpdateArgs} args - Arguments to update one Institutes.
     * @example
     * // Update one Institutes
     * const institutes = await prisma.institutes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstitutesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesUpdateArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Institutes.
     * @param {InstitutesDeleteManyArgs} args - Arguments to filter Institutes to delete.
     * @example
     * // Delete a few Institutes
     * const { count } = await prisma.institutes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstitutesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstitutesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutes
     * const institutes = await prisma.institutes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstitutesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institutes.
     * @param {InstitutesUpsertArgs} args - Arguments to update or create a Institutes.
     * @example
     * // Update or create a Institutes
     * const institutes = await prisma.institutes.upsert({
     *   create: {
     *     // ... data to create a Institutes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institutes we want to update
     *   }
     * })
    **/
    upsert<T extends InstitutesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstitutesUpsertArgs<ExtArgs>>
    ): Prisma__InstitutesClient<$Result.GetResult<Prisma.$InstitutesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesCountArgs} args - Arguments to filter Institutes to count.
     * @example
     * // Count the number of Institutes
     * const count = await prisma.institutes.count({
     *   where: {
     *     // ... the filter for the Institutes we want to count
     *   }
     * })
    **/
    count<T extends InstitutesCountArgs>(
      args?: Subset<T, InstitutesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutesAggregateArgs>(args: Subset<T, InstitutesAggregateArgs>): Prisma.PrismaPromise<GetInstitutesAggregateType<T>>

    /**
     * Group by Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutesGroupByArgs['orderBy'] }
        : { orderBy?: InstitutesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institutes model
   */
  readonly fields: InstitutesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institutes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Institutes model
   */ 
  interface InstitutesFieldRefs {
    readonly instituteId: FieldRef<"Institutes", 'Int'>
    readonly address_line1: FieldRef<"Institutes", 'String'>
    readonly address_line2: FieldRef<"Institutes", 'String'>
    readonly admin: FieldRef<"Institutes", 'String'>
    readonly country: FieldRef<"Institutes", 'String'>
    readonly externalProviderUploads: FieldRef<"Institutes", 'Boolean'>
    readonly geoHash: FieldRef<"Institutes", 'String'>
    readonly locality: FieldRef<"Institutes", 'String'>
    readonly name: FieldRef<"Institutes", 'String'>
    readonly postal_code: FieldRef<"Institutes", 'String'>
    readonly referral: FieldRef<"Institutes", 'String'>
    readonly status: FieldRef<"Institutes", 'String'>
    readonly studentsFields: FieldRef<"Institutes", 'String[]'>
    readonly staff: FieldRef<"Institutes", 'Int'>
    readonly staffActive: FieldRef<"Institutes", 'Int'>
    readonly students: FieldRef<"Institutes", 'Int'>
    readonly studentsActive: FieldRef<"Institutes", 'Int'>
    readonly staffFields: FieldRef<"Institutes", 'String[]'>
    readonly staffGuidance: FieldRef<"Institutes", 'Json'>
    readonly studentsGuidance: FieldRef<"Institutes", 'Json'>
    readonly verifiedProviders: FieldRef<"Institutes", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * Institutes findUnique
   */
  export type InstitutesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where: InstitutesWhereUniqueInput
  }


  /**
   * Institutes findUniqueOrThrow
   */
  export type InstitutesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where: InstitutesWhereUniqueInput
  }


  /**
   * Institutes findFirst
   */
  export type InstitutesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where?: InstitutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstitutesOrderByWithRelationInput | InstitutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutes.
     */
    cursor?: InstitutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutes.
     */
    distinct?: InstitutesScalarFieldEnum | InstitutesScalarFieldEnum[]
  }


  /**
   * Institutes findFirstOrThrow
   */
  export type InstitutesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where?: InstitutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstitutesOrderByWithRelationInput | InstitutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutes.
     */
    cursor?: InstitutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutes.
     */
    distinct?: InstitutesScalarFieldEnum | InstitutesScalarFieldEnum[]
  }


  /**
   * Institutes findMany
   */
  export type InstitutesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where?: InstitutesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstitutesOrderByWithRelationInput | InstitutesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutes.
     */
    cursor?: InstitutesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    distinct?: InstitutesScalarFieldEnum | InstitutesScalarFieldEnum[]
  }


  /**
   * Institutes create
   */
  export type InstitutesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * The data needed to create a Institutes.
     */
    data: XOR<InstitutesCreateInput, InstitutesUncheckedCreateInput>
  }


  /**
   * Institutes createMany
   */
  export type InstitutesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutes.
     */
    data: InstitutesCreateManyInput | InstitutesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Institutes update
   */
  export type InstitutesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * The data needed to update a Institutes.
     */
    data: XOR<InstitutesUpdateInput, InstitutesUncheckedUpdateInput>
    /**
     * Choose, which Institutes to update.
     */
    where: InstitutesWhereUniqueInput
  }


  /**
   * Institutes updateMany
   */
  export type InstitutesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutes.
     */
    data: XOR<InstitutesUpdateManyMutationInput, InstitutesUncheckedUpdateManyInput>
    /**
     * Filter which Institutes to update
     */
    where?: InstitutesWhereInput
  }


  /**
   * Institutes upsert
   */
  export type InstitutesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * The filter to search for the Institutes to update in case it exists.
     */
    where: InstitutesWhereUniqueInput
    /**
     * In case the Institutes found by the `where` argument doesn't exist, create a new Institutes with this data.
     */
    create: XOR<InstitutesCreateInput, InstitutesUncheckedCreateInput>
    /**
     * In case the Institutes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutesUpdateInput, InstitutesUncheckedUpdateInput>
  }


  /**
   * Institutes delete
   */
  export type InstitutesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
    /**
     * Filter which Institutes to delete.
     */
    where: InstitutesWhereUniqueInput
  }


  /**
   * Institutes deleteMany
   */
  export type InstitutesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutes to delete
     */
    where?: InstitutesWhereInput
  }


  /**
   * Institutes without action
   */
  export type InstitutesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institutes
     */
    select?: InstitutesSelect<ExtArgs> | null
  }



  /**
   * Model Jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    jobId: number | null
    oId: number | null
  }

  export type JobsSumAggregateOutputType = {
    jobId: number | null
    oId: number | null
  }

  export type JobsMinAggregateOutputType = {
    jobId: number | null
    started: string | null
    updated: string | null
    finished: string | null
    title: string | null
    description: string | null
    status: string | null
    outputMsg: string | null
    oId: number | null
    product: string | null
  }

  export type JobsMaxAggregateOutputType = {
    jobId: number | null
    started: string | null
    updated: string | null
    finished: string | null
    title: string | null
    description: string | null
    status: string | null
    outputMsg: string | null
    oId: number | null
    product: string | null
  }

  export type JobsCountAggregateOutputType = {
    jobId: number
    started: number
    updated: number
    finished: number
    title: number
    description: number
    status: number
    logs: number
    outputMsg: number
    viewedBy: number
    oId: number
    product: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    jobId?: true
    oId?: true
  }

  export type JobsSumAggregateInputType = {
    jobId?: true
    oId?: true
  }

  export type JobsMinAggregateInputType = {
    jobId?: true
    started?: true
    updated?: true
    finished?: true
    title?: true
    description?: true
    status?: true
    outputMsg?: true
    oId?: true
    product?: true
  }

  export type JobsMaxAggregateInputType = {
    jobId?: true
    started?: true
    updated?: true
    finished?: true
    title?: true
    description?: true
    status?: true
    outputMsg?: true
    oId?: true
    product?: true
  }

  export type JobsCountAggregateInputType = {
    jobId?: true
    started?: true
    updated?: true
    finished?: true
    title?: true
    description?: true
    status?: true
    logs?: true
    outputMsg?: true
    viewedBy?: true
    oId?: true
    product?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to aggregate.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type JobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithAggregationInput | JobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: JobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    jobId: number
    started: string
    updated: string | null
    finished: string | null
    title: string
    description: string
    status: string
    logs: JsonValue
    outputMsg: string | null
    viewedBy: string[]
    oId: number
    product: string
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends JobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type JobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jobId?: boolean
    started?: boolean
    updated?: boolean
    finished?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    logs?: boolean
    outputMsg?: boolean
    viewedBy?: boolean
    oId?: boolean
    product?: boolean
  }, ExtArgs["result"]["jobs"]>

  export type JobsSelectScalar = {
    jobId?: boolean
    started?: boolean
    updated?: boolean
    finished?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    logs?: boolean
    outputMsg?: boolean
    viewedBy?: boolean
    oId?: boolean
    product?: boolean
  }


  export type $JobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      jobId: number
      started: string
      updated: string | null
      finished: string | null
      title: string
      description: string
      status: string
      logs: Prisma.JsonValue
      outputMsg: string | null
      viewedBy: string[]
      oId: number
      product: string
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }


  type JobsGetPayload<S extends boolean | null | undefined | JobsDefaultArgs> = $Result.GetResult<Prisma.$JobsPayload, S>

  type JobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface JobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobs'], meta: { name: 'Jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {JobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobsFindUniqueArgs<ExtArgs>>
    ): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Jobs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsFindFirstArgs<ExtArgs>>
    ): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `jobId`
     * const jobsWithJobIdOnly = await prisma.jobs.findMany({ select: { jobId: true } })
     * 
    **/
    findMany<T extends JobsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Jobs.
     * @param {JobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
    **/
    create<T extends JobsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobsCreateArgs<ExtArgs>>
    ): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Jobs.
     *     @param {JobsCreateManyArgs} args - Arguments to create many Jobs.
     *     @example
     *     // Create many Jobs
     *     const jobs = await prisma.jobs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobs.
     * @param {JobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
    **/
    delete<T extends JobsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobsDeleteArgs<ExtArgs>>
    ): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Jobs.
     * @param {JobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobsUpdateArgs<ExtArgs>>
    ): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {JobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {JobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
    **/
    upsert<T extends JobsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobsUpsertArgs<ExtArgs>>
    ): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobsCountArgs>(
      args?: Subset<T, JobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsGroupByArgs['orderBy'] }
        : { orderBy?: JobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobs model
   */
  readonly fields: JobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Jobs model
   */ 
  interface JobsFieldRefs {
    readonly jobId: FieldRef<"Jobs", 'Int'>
    readonly started: FieldRef<"Jobs", 'String'>
    readonly updated: FieldRef<"Jobs", 'String'>
    readonly finished: FieldRef<"Jobs", 'String'>
    readonly title: FieldRef<"Jobs", 'String'>
    readonly description: FieldRef<"Jobs", 'String'>
    readonly status: FieldRef<"Jobs", 'String'>
    readonly logs: FieldRef<"Jobs", 'Json'>
    readonly outputMsg: FieldRef<"Jobs", 'String'>
    readonly viewedBy: FieldRef<"Jobs", 'String[]'>
    readonly oId: FieldRef<"Jobs", 'Int'>
    readonly product: FieldRef<"Jobs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Jobs findUnique
   */
  export type JobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }


  /**
   * Jobs findUniqueOrThrow
   */
  export type JobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }


  /**
   * Jobs findFirst
   */
  export type JobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }


  /**
   * Jobs findFirstOrThrow
   */
  export type JobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }


  /**
   * Jobs findMany
   */
  export type JobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }


  /**
   * Jobs create
   */
  export type JobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * The data needed to create a Jobs.
     */
    data: XOR<JobsCreateInput, JobsUncheckedCreateInput>
  }


  /**
   * Jobs createMany
   */
  export type JobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Jobs update
   */
  export type JobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * The data needed to update a Jobs.
     */
    data: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
    /**
     * Choose, which Jobs to update.
     */
    where: JobsWhereUniqueInput
  }


  /**
   * Jobs updateMany
   */
  export type JobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobsWhereInput
  }


  /**
   * Jobs upsert
   */
  export type JobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * The filter to search for the Jobs to update in case it exists.
     */
    where: JobsWhereUniqueInput
    /**
     * In case the Jobs found by the `where` argument doesn't exist, create a new Jobs with this data.
     */
    create: XOR<JobsCreateInput, JobsUncheckedCreateInput>
    /**
     * In case the Jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
  }


  /**
   * Jobs delete
   */
  export type JobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Filter which Jobs to delete.
     */
    where: JobsWhereUniqueInput
  }


  /**
   * Jobs deleteMany
   */
  export type JobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobsWhereInput
  }


  /**
   * Jobs without action
   */
  export type JobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
  }



  /**
   * Model Logs
   */

  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsAvgAggregateOutputType = {
    logId: number | null
    oId: number | null
  }

  export type LogsSumAggregateOutputType = {
    logId: number | null
    oId: number | null
  }

  export type LogsMinAggregateOutputType = {
    logId: number | null
    oId: number | null
    uid: string | null
  }

  export type LogsMaxAggregateOutputType = {
    logId: number | null
    oId: number | null
    uid: string | null
  }

  export type LogsCountAggregateOutputType = {
    logId: number
    oId: number
    provider: number
    students: number
    staff: number
    uid: number
    _all: number
  }


  export type LogsAvgAggregateInputType = {
    logId?: true
    oId?: true
  }

  export type LogsSumAggregateInputType = {
    logId?: true
    oId?: true
  }

  export type LogsMinAggregateInputType = {
    logId?: true
    oId?: true
    uid?: true
  }

  export type LogsMaxAggregateInputType = {
    logId?: true
    oId?: true
    uid?: true
  }

  export type LogsCountAggregateInputType = {
    logId?: true
    oId?: true
    provider?: true
    students?: true
    staff?: true
    uid?: true
    _all?: true
  }

  export type LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to aggregate.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type LogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithAggregationInput | LogsOrderByWithAggregationInput[]
    by: LogsScalarFieldEnum[] | LogsScalarFieldEnum
    having?: LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _avg?: LogsAvgAggregateInputType
    _sum?: LogsSumAggregateInputType
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }

  export type LogsGroupByOutputType = {
    logId: number
    oId: number
    provider: JsonValue
    students: JsonValue
    staff: JsonValue
    uid: string
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends LogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type LogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    logId?: boolean
    oId?: boolean
    provider?: boolean
    students?: boolean
    staff?: boolean
    uid?: boolean
  }, ExtArgs["result"]["logs"]>

  export type LogsSelectScalar = {
    logId?: boolean
    oId?: boolean
    provider?: boolean
    students?: boolean
    staff?: boolean
    uid?: boolean
  }


  export type $LogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      logId: number
      oId: number
      provider: Prisma.JsonValue
      students: Prisma.JsonValue
      staff: Prisma.JsonValue
      uid: string
    }, ExtArgs["result"]["logs"]>
    composites: {}
  }


  type LogsGetPayload<S extends boolean | null | undefined | LogsDefaultArgs> = $Result.GetResult<Prisma.$LogsPayload, S>

  type LogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogsCountAggregateInputType | true
    }

  export interface LogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logs'], meta: { name: 'Logs' } }
    /**
     * Find zero or one Logs that matches the filter.
     * @param {LogsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogsFindUniqueArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindFirstArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `logId`
     * const logsWithLogIdOnly = await prisma.logs.findMany({ select: { logId: true } })
     * 
    **/
    findMany<T extends LogsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Logs.
     * @param {LogsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
    **/
    create<T extends LogsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogsCreateArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Logs.
     *     @param {LogsCreateManyArgs} args - Arguments to create many Logs.
     *     @example
     *     // Create many Logs
     *     const logs = await prisma.logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logs.
     * @param {LogsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
    **/
    delete<T extends LogsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogsDeleteArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Logs.
     * @param {LogsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpdateArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs.
     * @param {LogsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
    **/
    upsert<T extends LogsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogsUpsertArgs<ExtArgs>>
    ): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogsCountArgs>(
      args?: Subset<T, LogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): Prisma.PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsGroupByArgs['orderBy'] }
        : { orderBy?: LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logs model
   */
  readonly fields: LogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Logs model
   */ 
  interface LogsFieldRefs {
    readonly logId: FieldRef<"Logs", 'Int'>
    readonly oId: FieldRef<"Logs", 'Int'>
    readonly provider: FieldRef<"Logs", 'Json'>
    readonly students: FieldRef<"Logs", 'Json'>
    readonly staff: FieldRef<"Logs", 'Json'>
    readonly uid: FieldRef<"Logs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Logs findUnique
   */
  export type LogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs findUniqueOrThrow
   */
  export type LogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs findFirst
   */
  export type LogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs findFirstOrThrow
   */
  export type LogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs findMany
   */
  export type LogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }


  /**
   * Logs create
   */
  export type LogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * The data needed to create a Logs.
     */
    data: XOR<LogsCreateInput, LogsUncheckedCreateInput>
  }


  /**
   * Logs createMany
   */
  export type LogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogsCreateManyInput | LogsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Logs update
   */
  export type LogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * The data needed to update a Logs.
     */
    data: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
    /**
     * Choose, which Logs to update.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs updateMany
   */
  export type LogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogsWhereInput
  }


  /**
   * Logs upsert
   */
  export type LogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * The filter to search for the Logs to update in case it exists.
     */
    where: LogsWhereUniqueInput
    /**
     * In case the Logs found by the `where` argument doesn't exist, create a new Logs with this data.
     */
    create: XOR<LogsCreateInput, LogsUncheckedCreateInput>
    /**
     * In case the Logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
  }


  /**
   * Logs delete
   */
  export type LogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Filter which Logs to delete.
     */
    where: LogsWhereUniqueInput
  }


  /**
   * Logs deleteMany
   */
  export type LogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogsWhereInput
  }


  /**
   * Logs without action
   */
  export type LogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
  }



  /**
   * Model PlacementListings
   */

  export type AggregatePlacementListings = {
    _count: PlacementListingsCountAggregateOutputType | null
    _avg: PlacementListingsAvgAggregateOutputType | null
    _sum: PlacementListingsSumAggregateOutputType | null
    _min: PlacementListingsMinAggregateOutputType | null
    _max: PlacementListingsMaxAggregateOutputType | null
  }

  export type PlacementListingsAvgAggregateOutputType = {
    placementListingId: number | null
  }

  export type PlacementListingsSumAggregateOutputType = {
    placementListingId: number | null
  }

  export type PlacementListingsMinAggregateOutputType = {
    placementListingId: number | null
    addressId: string | null
    contactForename: string | null
    contactSurname: string | null
    created: Date | null
    mapConsent: boolean | null
    mapConsentDate: string | null
    providerEmail: string | null
    providerId: string | null
    providerPhone: string | null
    title: string | null
    uploadedBy: string | null
  }

  export type PlacementListingsMaxAggregateOutputType = {
    placementListingId: number | null
    addressId: string | null
    contactForename: string | null
    contactSurname: string | null
    created: Date | null
    mapConsent: boolean | null
    mapConsentDate: string | null
    providerEmail: string | null
    providerId: string | null
    providerPhone: string | null
    title: string | null
    uploadedBy: string | null
  }

  export type PlacementListingsCountAggregateOutputType = {
    placementListingId: number
    addressId: number
    contactForename: number
    contactSurname: number
    created: number
    mapConsent: number
    mapConsentDate: number
    providerEmail: number
    providerId: number
    providerPhone: number
    savedBy: number
    questions: number
    title: number
    uploadedBy: number
    _all: number
  }


  export type PlacementListingsAvgAggregateInputType = {
    placementListingId?: true
  }

  export type PlacementListingsSumAggregateInputType = {
    placementListingId?: true
  }

  export type PlacementListingsMinAggregateInputType = {
    placementListingId?: true
    addressId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    mapConsent?: true
    mapConsentDate?: true
    providerEmail?: true
    providerId?: true
    providerPhone?: true
    title?: true
    uploadedBy?: true
  }

  export type PlacementListingsMaxAggregateInputType = {
    placementListingId?: true
    addressId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    mapConsent?: true
    mapConsentDate?: true
    providerEmail?: true
    providerId?: true
    providerPhone?: true
    title?: true
    uploadedBy?: true
  }

  export type PlacementListingsCountAggregateInputType = {
    placementListingId?: true
    addressId?: true
    contactForename?: true
    contactSurname?: true
    created?: true
    mapConsent?: true
    mapConsentDate?: true
    providerEmail?: true
    providerId?: true
    providerPhone?: true
    savedBy?: true
    questions?: true
    title?: true
    uploadedBy?: true
    _all?: true
  }

  export type PlacementListingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlacementListings to aggregate.
     */
    where?: PlacementListingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementListings to fetch.
     */
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlacementListingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlacementListings
    **/
    _count?: true | PlacementListingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlacementListingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlacementListingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlacementListingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlacementListingsMaxAggregateInputType
  }

  export type GetPlacementListingsAggregateType<T extends PlacementListingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlacementListings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlacementListings[P]>
      : GetScalarType<T[P], AggregatePlacementListings[P]>
  }




  export type PlacementListingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementListingsWhereInput
    orderBy?: PlacementListingsOrderByWithAggregationInput | PlacementListingsOrderByWithAggregationInput[]
    by: PlacementListingsScalarFieldEnum[] | PlacementListingsScalarFieldEnum
    having?: PlacementListingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlacementListingsCountAggregateInputType | true
    _avg?: PlacementListingsAvgAggregateInputType
    _sum?: PlacementListingsSumAggregateInputType
    _min?: PlacementListingsMinAggregateInputType
    _max?: PlacementListingsMaxAggregateInputType
  }

  export type PlacementListingsGroupByOutputType = {
    placementListingId: number
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonValue
    questions: JsonValue
    title: string
    uploadedBy: string
    _count: PlacementListingsCountAggregateOutputType | null
    _avg: PlacementListingsAvgAggregateOutputType | null
    _sum: PlacementListingsSumAggregateOutputType | null
    _min: PlacementListingsMinAggregateOutputType | null
    _max: PlacementListingsMaxAggregateOutputType | null
  }

  type GetPlacementListingsGroupByPayload<T extends PlacementListingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlacementListingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlacementListingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlacementListingsGroupByOutputType[P]>
            : GetScalarType<T[P], PlacementListingsGroupByOutputType[P]>
        }
      >
    >


  export type PlacementListingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    placementListingId?: boolean
    addressId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    created?: boolean
    mapConsent?: boolean
    mapConsentDate?: boolean
    providerEmail?: boolean
    providerId?: boolean
    providerPhone?: boolean
    savedBy?: boolean
    questions?: boolean
    title?: boolean
    uploadedBy?: boolean
  }, ExtArgs["result"]["placementListings"]>

  export type PlacementListingsSelectScalar = {
    placementListingId?: boolean
    addressId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    created?: boolean
    mapConsent?: boolean
    mapConsentDate?: boolean
    providerEmail?: boolean
    providerId?: boolean
    providerPhone?: boolean
    savedBy?: boolean
    questions?: boolean
    title?: boolean
    uploadedBy?: boolean
  }


  export type $PlacementListingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlacementListings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      placementListingId: number
      addressId: string
      contactForename: string
      contactSurname: string
      created: Date
      mapConsent: boolean
      mapConsentDate: string
      providerEmail: string
      providerId: string
      providerPhone: string
      savedBy: Prisma.JsonValue
      questions: Prisma.JsonValue
      title: string
      uploadedBy: string
    }, ExtArgs["result"]["placementListings"]>
    composites: {}
  }


  type PlacementListingsGetPayload<S extends boolean | null | undefined | PlacementListingsDefaultArgs> = $Result.GetResult<Prisma.$PlacementListingsPayload, S>

  type PlacementListingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlacementListingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlacementListingsCountAggregateInputType | true
    }

  export interface PlacementListingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlacementListings'], meta: { name: 'PlacementListings' } }
    /**
     * Find zero or one PlacementListings that matches the filter.
     * @param {PlacementListingsFindUniqueArgs} args - Arguments to find a PlacementListings
     * @example
     * // Get one PlacementListings
     * const placementListings = await prisma.placementListings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlacementListingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsFindUniqueArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PlacementListings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlacementListingsFindUniqueOrThrowArgs} args - Arguments to find a PlacementListings
     * @example
     * // Get one PlacementListings
     * const placementListings = await prisma.placementListings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlacementListingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PlacementListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsFindFirstArgs} args - Arguments to find a PlacementListings
     * @example
     * // Get one PlacementListings
     * const placementListings = await prisma.placementListings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlacementListingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsFindFirstArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PlacementListings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsFindFirstOrThrowArgs} args - Arguments to find a PlacementListings
     * @example
     * // Get one PlacementListings
     * const placementListings = await prisma.placementListings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlacementListingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PlacementListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlacementListings
     * const placementListings = await prisma.placementListings.findMany()
     * 
     * // Get first 10 PlacementListings
     * const placementListings = await prisma.placementListings.findMany({ take: 10 })
     * 
     * // Only select the `placementListingId`
     * const placementListingsWithPlacementListingIdOnly = await prisma.placementListings.findMany({ select: { placementListingId: true } })
     * 
    **/
    findMany<T extends PlacementListingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PlacementListings.
     * @param {PlacementListingsCreateArgs} args - Arguments to create a PlacementListings.
     * @example
     * // Create one PlacementListings
     * const PlacementListings = await prisma.placementListings.create({
     *   data: {
     *     // ... data to create a PlacementListings
     *   }
     * })
     * 
    **/
    create<T extends PlacementListingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsCreateArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PlacementListings.
     *     @param {PlacementListingsCreateManyArgs} args - Arguments to create many PlacementListings.
     *     @example
     *     // Create many PlacementListings
     *     const placementListings = await prisma.placementListings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlacementListingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlacementListings.
     * @param {PlacementListingsDeleteArgs} args - Arguments to delete one PlacementListings.
     * @example
     * // Delete one PlacementListings
     * const PlacementListings = await prisma.placementListings.delete({
     *   where: {
     *     // ... filter to delete one PlacementListings
     *   }
     * })
     * 
    **/
    delete<T extends PlacementListingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsDeleteArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PlacementListings.
     * @param {PlacementListingsUpdateArgs} args - Arguments to update one PlacementListings.
     * @example
     * // Update one PlacementListings
     * const placementListings = await prisma.placementListings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlacementListingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsUpdateArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PlacementListings.
     * @param {PlacementListingsDeleteManyArgs} args - Arguments to filter PlacementListings to delete.
     * @example
     * // Delete a few PlacementListings
     * const { count } = await prisma.placementListings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlacementListingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementListingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlacementListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlacementListings
     * const placementListings = await prisma.placementListings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlacementListingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlacementListings.
     * @param {PlacementListingsUpsertArgs} args - Arguments to update or create a PlacementListings.
     * @example
     * // Update or create a PlacementListings
     * const placementListings = await prisma.placementListings.upsert({
     *   create: {
     *     // ... data to create a PlacementListings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlacementListings we want to update
     *   }
     * })
    **/
    upsert<T extends PlacementListingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementListingsUpsertArgs<ExtArgs>>
    ): Prisma__PlacementListingsClient<$Result.GetResult<Prisma.$PlacementListingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PlacementListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsCountArgs} args - Arguments to filter PlacementListings to count.
     * @example
     * // Count the number of PlacementListings
     * const count = await prisma.placementListings.count({
     *   where: {
     *     // ... the filter for the PlacementListings we want to count
     *   }
     * })
    **/
    count<T extends PlacementListingsCountArgs>(
      args?: Subset<T, PlacementListingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlacementListingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlacementListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlacementListingsAggregateArgs>(args: Subset<T, PlacementListingsAggregateArgs>): Prisma.PrismaPromise<GetPlacementListingsAggregateType<T>>

    /**
     * Group by PlacementListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementListingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlacementListingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlacementListingsGroupByArgs['orderBy'] }
        : { orderBy?: PlacementListingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlacementListingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlacementListingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlacementListings model
   */
  readonly fields: PlacementListingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlacementListings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlacementListingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PlacementListings model
   */ 
  interface PlacementListingsFieldRefs {
    readonly placementListingId: FieldRef<"PlacementListings", 'Int'>
    readonly addressId: FieldRef<"PlacementListings", 'String'>
    readonly contactForename: FieldRef<"PlacementListings", 'String'>
    readonly contactSurname: FieldRef<"PlacementListings", 'String'>
    readonly created: FieldRef<"PlacementListings", 'DateTime'>
    readonly mapConsent: FieldRef<"PlacementListings", 'Boolean'>
    readonly mapConsentDate: FieldRef<"PlacementListings", 'String'>
    readonly providerEmail: FieldRef<"PlacementListings", 'String'>
    readonly providerId: FieldRef<"PlacementListings", 'String'>
    readonly providerPhone: FieldRef<"PlacementListings", 'String'>
    readonly savedBy: FieldRef<"PlacementListings", 'Json'>
    readonly questions: FieldRef<"PlacementListings", 'Json'>
    readonly title: FieldRef<"PlacementListings", 'String'>
    readonly uploadedBy: FieldRef<"PlacementListings", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PlacementListings findUnique
   */
  export type PlacementListingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where: PlacementListingsWhereUniqueInput
  }


  /**
   * PlacementListings findUniqueOrThrow
   */
  export type PlacementListingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where: PlacementListingsWhereUniqueInput
  }


  /**
   * PlacementListings findFirst
   */
  export type PlacementListingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where?: PlacementListingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementListings to fetch.
     */
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlacementListings.
     */
    cursor?: PlacementListingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlacementListings.
     */
    distinct?: PlacementListingsScalarFieldEnum | PlacementListingsScalarFieldEnum[]
  }


  /**
   * PlacementListings findFirstOrThrow
   */
  export type PlacementListingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where?: PlacementListingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementListings to fetch.
     */
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlacementListings.
     */
    cursor?: PlacementListingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlacementListings.
     */
    distinct?: PlacementListingsScalarFieldEnum | PlacementListingsScalarFieldEnum[]
  }


  /**
   * PlacementListings findMany
   */
  export type PlacementListingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Filter, which PlacementListings to fetch.
     */
    where?: PlacementListingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementListings to fetch.
     */
    orderBy?: PlacementListingsOrderByWithRelationInput | PlacementListingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlacementListings.
     */
    cursor?: PlacementListingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementListings.
     */
    skip?: number
    distinct?: PlacementListingsScalarFieldEnum | PlacementListingsScalarFieldEnum[]
  }


  /**
   * PlacementListings create
   */
  export type PlacementListingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * The data needed to create a PlacementListings.
     */
    data: XOR<PlacementListingsCreateInput, PlacementListingsUncheckedCreateInput>
  }


  /**
   * PlacementListings createMany
   */
  export type PlacementListingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlacementListings.
     */
    data: PlacementListingsCreateManyInput | PlacementListingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PlacementListings update
   */
  export type PlacementListingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * The data needed to update a PlacementListings.
     */
    data: XOR<PlacementListingsUpdateInput, PlacementListingsUncheckedUpdateInput>
    /**
     * Choose, which PlacementListings to update.
     */
    where: PlacementListingsWhereUniqueInput
  }


  /**
   * PlacementListings updateMany
   */
  export type PlacementListingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlacementListings.
     */
    data: XOR<PlacementListingsUpdateManyMutationInput, PlacementListingsUncheckedUpdateManyInput>
    /**
     * Filter which PlacementListings to update
     */
    where?: PlacementListingsWhereInput
  }


  /**
   * PlacementListings upsert
   */
  export type PlacementListingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * The filter to search for the PlacementListings to update in case it exists.
     */
    where: PlacementListingsWhereUniqueInput
    /**
     * In case the PlacementListings found by the `where` argument doesn't exist, create a new PlacementListings with this data.
     */
    create: XOR<PlacementListingsCreateInput, PlacementListingsUncheckedCreateInput>
    /**
     * In case the PlacementListings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlacementListingsUpdateInput, PlacementListingsUncheckedUpdateInput>
  }


  /**
   * PlacementListings delete
   */
  export type PlacementListingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
    /**
     * Filter which PlacementListings to delete.
     */
    where: PlacementListingsWhereUniqueInput
  }


  /**
   * PlacementListings deleteMany
   */
  export type PlacementListingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlacementListings to delete
     */
    where?: PlacementListingsWhereInput
  }


  /**
   * PlacementListings without action
   */
  export type PlacementListingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementListings
     */
    select?: PlacementListingsSelect<ExtArgs> | null
  }



  /**
   * Model Placements
   */

  export type AggregatePlacements = {
    _count: PlacementsCountAggregateOutputType | null
    _avg: PlacementsAvgAggregateOutputType | null
    _sum: PlacementsSumAggregateOutputType | null
    _min: PlacementsMinAggregateOutputType | null
    _max: PlacementsMaxAggregateOutputType | null
  }

  export type PlacementsAvgAggregateOutputType = {
    placementId: number | null
    cohortId: number | null
    oId: number | null
    nextStatus: number | null
    status: number | null
    userGroup: number | null
  }

  export type PlacementsSumAggregateOutputType = {
    placementId: number | null
    cohortId: number | null
    oId: number | null
    nextStatus: number | null
    status: number | null
    userGroup: number | null
  }

  export type PlacementsMinAggregateOutputType = {
    placementId: number | null
    address_line1: string | null
    address_line2: string | null
    cohortId: number | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    created: string | null
    draft: boolean | null
    endDate: string | null
    geoHash: string | null
    inProgress: boolean | null
    locality: string | null
    name: string | null
    oId: number | null
    parentEmailed: Date | null
    parentExpiry: string | null
    parentKey: string | null
    postal_code: string | null
    product: string | null
    providerEmail: string | null
    providerEmailed: Date | null
    providerExpiry: string | null
    providerKey: string | null
    providerName: string | null
    providerPhone: string | null
    nextStatus: number | null
    status: number | null
    startDate: string | null
    title: string | null
    uid: string | null
    uploadedBy: string | null
    userGroup: number | null
  }

  export type PlacementsMaxAggregateOutputType = {
    placementId: number | null
    address_line1: string | null
    address_line2: string | null
    cohortId: number | null
    contactForename: string | null
    contactSurname: string | null
    country: string | null
    created: string | null
    draft: boolean | null
    endDate: string | null
    geoHash: string | null
    inProgress: boolean | null
    locality: string | null
    name: string | null
    oId: number | null
    parentEmailed: Date | null
    parentExpiry: string | null
    parentKey: string | null
    postal_code: string | null
    product: string | null
    providerEmail: string | null
    providerEmailed: Date | null
    providerExpiry: string | null
    providerKey: string | null
    providerName: string | null
    providerPhone: string | null
    nextStatus: number | null
    status: number | null
    startDate: string | null
    title: string | null
    uid: string | null
    uploadedBy: string | null
    userGroup: number | null
  }

  export type PlacementsCountAggregateOutputType = {
    placementId: number
    activeDates: number
    address_line1: number
    address_line2: number
    cohortId: number
    contactForename: number
    contactSurname: number
    country: number
    created: number
    draft: number
    endDate: number
    flags: number
    geoHash: number
    inProgress: number
    leadTimes: number
    locality: number
    name: number
    oId: number
    parentEmailed: number
    parentExpiry: number
    parentKey: number
    postal_code: number
    product: number
    providerEmail: number
    providerEmailed: number
    providerExpiry: number
    providerKey: number
    providerName: number
    providerPhone: number
    nextStatus: number
    status: number
    startDate: number
    title: number
    uid: number
    forms: number
    questions: number
    uploadedBy: number
    userGroup: number
    _all: number
  }


  export type PlacementsAvgAggregateInputType = {
    placementId?: true
    cohortId?: true
    oId?: true
    nextStatus?: true
    status?: true
    userGroup?: true
  }

  export type PlacementsSumAggregateInputType = {
    placementId?: true
    cohortId?: true
    oId?: true
    nextStatus?: true
    status?: true
    userGroup?: true
  }

  export type PlacementsMinAggregateInputType = {
    placementId?: true
    address_line1?: true
    address_line2?: true
    cohortId?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    created?: true
    draft?: true
    endDate?: true
    geoHash?: true
    inProgress?: true
    locality?: true
    name?: true
    oId?: true
    parentEmailed?: true
    parentExpiry?: true
    parentKey?: true
    postal_code?: true
    product?: true
    providerEmail?: true
    providerEmailed?: true
    providerExpiry?: true
    providerKey?: true
    providerName?: true
    providerPhone?: true
    nextStatus?: true
    status?: true
    startDate?: true
    title?: true
    uid?: true
    uploadedBy?: true
    userGroup?: true
  }

  export type PlacementsMaxAggregateInputType = {
    placementId?: true
    address_line1?: true
    address_line2?: true
    cohortId?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    created?: true
    draft?: true
    endDate?: true
    geoHash?: true
    inProgress?: true
    locality?: true
    name?: true
    oId?: true
    parentEmailed?: true
    parentExpiry?: true
    parentKey?: true
    postal_code?: true
    product?: true
    providerEmail?: true
    providerEmailed?: true
    providerExpiry?: true
    providerKey?: true
    providerName?: true
    providerPhone?: true
    nextStatus?: true
    status?: true
    startDate?: true
    title?: true
    uid?: true
    uploadedBy?: true
    userGroup?: true
  }

  export type PlacementsCountAggregateInputType = {
    placementId?: true
    activeDates?: true
    address_line1?: true
    address_line2?: true
    cohortId?: true
    contactForename?: true
    contactSurname?: true
    country?: true
    created?: true
    draft?: true
    endDate?: true
    flags?: true
    geoHash?: true
    inProgress?: true
    leadTimes?: true
    locality?: true
    name?: true
    oId?: true
    parentEmailed?: true
    parentExpiry?: true
    parentKey?: true
    postal_code?: true
    product?: true
    providerEmail?: true
    providerEmailed?: true
    providerExpiry?: true
    providerKey?: true
    providerName?: true
    providerPhone?: true
    nextStatus?: true
    status?: true
    startDate?: true
    title?: true
    uid?: true
    forms?: true
    questions?: true
    uploadedBy?: true
    userGroup?: true
    _all?: true
  }

  export type PlacementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Placements to aggregate.
     */
    where?: PlacementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlacementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Placements
    **/
    _count?: true | PlacementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlacementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlacementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlacementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlacementsMaxAggregateInputType
  }

  export type GetPlacementsAggregateType<T extends PlacementsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlacements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlacements[P]>
      : GetScalarType<T[P], AggregatePlacements[P]>
  }




  export type PlacementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementsWhereInput
    orderBy?: PlacementsOrderByWithAggregationInput | PlacementsOrderByWithAggregationInput[]
    by: PlacementsScalarFieldEnum[] | PlacementsScalarFieldEnum
    having?: PlacementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlacementsCountAggregateInputType | true
    _avg?: PlacementsAvgAggregateInputType
    _sum?: PlacementsSumAggregateInputType
    _min?: PlacementsMinAggregateInputType
    _max?: PlacementsMaxAggregateInputType
  }

  export type PlacementsGroupByOutputType = {
    placementId: number
    activeDates: string[]
    address_line1: string
    address_line2: string
    cohortId: number
    contactForename: string
    contactSurname: string
    country: string
    created: string
    draft: boolean
    endDate: string
    flags: string[]
    geoHash: string
    inProgress: boolean
    leadTimes: string[]
    locality: string
    name: string
    oId: number | null
    parentEmailed: Date | null
    parentExpiry: string | null
    parentKey: string | null
    postal_code: string
    product: string | null
    providerEmail: string | null
    providerEmailed: Date | null
    providerExpiry: string | null
    providerKey: string | null
    providerName: string | null
    providerPhone: string
    nextStatus: number | null
    status: number
    startDate: string
    title: string
    uid: string
    forms: JsonValue
    questions: JsonValue
    uploadedBy: string
    userGroup: number | null
    _count: PlacementsCountAggregateOutputType | null
    _avg: PlacementsAvgAggregateOutputType | null
    _sum: PlacementsSumAggregateOutputType | null
    _min: PlacementsMinAggregateOutputType | null
    _max: PlacementsMaxAggregateOutputType | null
  }

  type GetPlacementsGroupByPayload<T extends PlacementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlacementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlacementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlacementsGroupByOutputType[P]>
            : GetScalarType<T[P], PlacementsGroupByOutputType[P]>
        }
      >
    >


  export type PlacementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    placementId?: boolean
    activeDates?: boolean
    address_line1?: boolean
    address_line2?: boolean
    cohortId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    country?: boolean
    created?: boolean
    draft?: boolean
    endDate?: boolean
    flags?: boolean
    geoHash?: boolean
    inProgress?: boolean
    leadTimes?: boolean
    locality?: boolean
    name?: boolean
    oId?: boolean
    parentEmailed?: boolean
    parentExpiry?: boolean
    parentKey?: boolean
    postal_code?: boolean
    product?: boolean
    providerEmail?: boolean
    providerEmailed?: boolean
    providerExpiry?: boolean
    providerKey?: boolean
    providerName?: boolean
    providerPhone?: boolean
    nextStatus?: boolean
    status?: boolean
    startDate?: boolean
    title?: boolean
    uid?: boolean
    forms?: boolean
    questions?: boolean
    uploadedBy?: boolean
    userGroup?: boolean
  }, ExtArgs["result"]["placements"]>

  export type PlacementsSelectScalar = {
    placementId?: boolean
    activeDates?: boolean
    address_line1?: boolean
    address_line2?: boolean
    cohortId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    country?: boolean
    created?: boolean
    draft?: boolean
    endDate?: boolean
    flags?: boolean
    geoHash?: boolean
    inProgress?: boolean
    leadTimes?: boolean
    locality?: boolean
    name?: boolean
    oId?: boolean
    parentEmailed?: boolean
    parentExpiry?: boolean
    parentKey?: boolean
    postal_code?: boolean
    product?: boolean
    providerEmail?: boolean
    providerEmailed?: boolean
    providerExpiry?: boolean
    providerKey?: boolean
    providerName?: boolean
    providerPhone?: boolean
    nextStatus?: boolean
    status?: boolean
    startDate?: boolean
    title?: boolean
    uid?: boolean
    forms?: boolean
    questions?: boolean
    uploadedBy?: boolean
    userGroup?: boolean
  }


  export type $PlacementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Placements"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      placementId: number
      activeDates: string[]
      address_line1: string
      address_line2: string
      cohortId: number
      contactForename: string
      contactSurname: string
      country: string
      created: string
      draft: boolean
      endDate: string
      flags: string[]
      geoHash: string
      inProgress: boolean
      leadTimes: string[]
      locality: string
      name: string
      oId: number | null
      parentEmailed: Date | null
      parentExpiry: string | null
      parentKey: string | null
      postal_code: string
      product: string | null
      providerEmail: string | null
      providerEmailed: Date | null
      providerExpiry: string | null
      providerKey: string | null
      providerName: string | null
      providerPhone: string
      nextStatus: number | null
      status: number
      startDate: string
      title: string
      uid: string
      forms: Prisma.JsonValue
      questions: Prisma.JsonValue
      uploadedBy: string
      userGroup: number | null
    }, ExtArgs["result"]["placements"]>
    composites: {}
  }


  type PlacementsGetPayload<S extends boolean | null | undefined | PlacementsDefaultArgs> = $Result.GetResult<Prisma.$PlacementsPayload, S>

  type PlacementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlacementsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlacementsCountAggregateInputType | true
    }

  export interface PlacementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Placements'], meta: { name: 'Placements' } }
    /**
     * Find zero or one Placements that matches the filter.
     * @param {PlacementsFindUniqueArgs} args - Arguments to find a Placements
     * @example
     * // Get one Placements
     * const placements = await prisma.placements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlacementsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsFindUniqueArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Placements that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlacementsFindUniqueOrThrowArgs} args - Arguments to find a Placements
     * @example
     * // Get one Placements
     * const placements = await prisma.placements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlacementsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Placements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsFindFirstArgs} args - Arguments to find a Placements
     * @example
     * // Get one Placements
     * const placements = await prisma.placements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlacementsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsFindFirstArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Placements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsFindFirstOrThrowArgs} args - Arguments to find a Placements
     * @example
     * // Get one Placements
     * const placements = await prisma.placements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlacementsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Placements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Placements
     * const placements = await prisma.placements.findMany()
     * 
     * // Get first 10 Placements
     * const placements = await prisma.placements.findMany({ take: 10 })
     * 
     * // Only select the `placementId`
     * const placementsWithPlacementIdOnly = await prisma.placements.findMany({ select: { placementId: true } })
     * 
    **/
    findMany<T extends PlacementsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Placements.
     * @param {PlacementsCreateArgs} args - Arguments to create a Placements.
     * @example
     * // Create one Placements
     * const Placements = await prisma.placements.create({
     *   data: {
     *     // ... data to create a Placements
     *   }
     * })
     * 
    **/
    create<T extends PlacementsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsCreateArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Placements.
     *     @param {PlacementsCreateManyArgs} args - Arguments to create many Placements.
     *     @example
     *     // Create many Placements
     *     const placements = await prisma.placements.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlacementsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Placements.
     * @param {PlacementsDeleteArgs} args - Arguments to delete one Placements.
     * @example
     * // Delete one Placements
     * const Placements = await prisma.placements.delete({
     *   where: {
     *     // ... filter to delete one Placements
     *   }
     * })
     * 
    **/
    delete<T extends PlacementsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsDeleteArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Placements.
     * @param {PlacementsUpdateArgs} args - Arguments to update one Placements.
     * @example
     * // Update one Placements
     * const placements = await prisma.placements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlacementsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsUpdateArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Placements.
     * @param {PlacementsDeleteManyArgs} args - Arguments to filter Placements to delete.
     * @example
     * // Delete a few Placements
     * const { count } = await prisma.placements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlacementsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlacementsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Placements
     * const placements = await prisma.placements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlacementsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Placements.
     * @param {PlacementsUpsertArgs} args - Arguments to update or create a Placements.
     * @example
     * // Update or create a Placements
     * const placements = await prisma.placements.upsert({
     *   create: {
     *     // ... data to create a Placements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Placements we want to update
     *   }
     * })
    **/
    upsert<T extends PlacementsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlacementsUpsertArgs<ExtArgs>>
    ): Prisma__PlacementsClient<$Result.GetResult<Prisma.$PlacementsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsCountArgs} args - Arguments to filter Placements to count.
     * @example
     * // Count the number of Placements
     * const count = await prisma.placements.count({
     *   where: {
     *     // ... the filter for the Placements we want to count
     *   }
     * })
    **/
    count<T extends PlacementsCountArgs>(
      args?: Subset<T, PlacementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlacementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlacementsAggregateArgs>(args: Subset<T, PlacementsAggregateArgs>): Prisma.PrismaPromise<GetPlacementsAggregateType<T>>

    /**
     * Group by Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlacementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlacementsGroupByArgs['orderBy'] }
        : { orderBy?: PlacementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlacementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlacementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Placements model
   */
  readonly fields: PlacementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Placements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlacementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Placements model
   */ 
  interface PlacementsFieldRefs {
    readonly placementId: FieldRef<"Placements", 'Int'>
    readonly activeDates: FieldRef<"Placements", 'String[]'>
    readonly address_line1: FieldRef<"Placements", 'String'>
    readonly address_line2: FieldRef<"Placements", 'String'>
    readonly cohortId: FieldRef<"Placements", 'Int'>
    readonly contactForename: FieldRef<"Placements", 'String'>
    readonly contactSurname: FieldRef<"Placements", 'String'>
    readonly country: FieldRef<"Placements", 'String'>
    readonly created: FieldRef<"Placements", 'String'>
    readonly draft: FieldRef<"Placements", 'Boolean'>
    readonly endDate: FieldRef<"Placements", 'String'>
    readonly flags: FieldRef<"Placements", 'String[]'>
    readonly geoHash: FieldRef<"Placements", 'String'>
    readonly inProgress: FieldRef<"Placements", 'Boolean'>
    readonly leadTimes: FieldRef<"Placements", 'String[]'>
    readonly locality: FieldRef<"Placements", 'String'>
    readonly name: FieldRef<"Placements", 'String'>
    readonly oId: FieldRef<"Placements", 'Int'>
    readonly parentEmailed: FieldRef<"Placements", 'DateTime'>
    readonly parentExpiry: FieldRef<"Placements", 'String'>
    readonly parentKey: FieldRef<"Placements", 'String'>
    readonly postal_code: FieldRef<"Placements", 'String'>
    readonly product: FieldRef<"Placements", 'String'>
    readonly providerEmail: FieldRef<"Placements", 'String'>
    readonly providerEmailed: FieldRef<"Placements", 'DateTime'>
    readonly providerExpiry: FieldRef<"Placements", 'String'>
    readonly providerKey: FieldRef<"Placements", 'String'>
    readonly providerName: FieldRef<"Placements", 'String'>
    readonly providerPhone: FieldRef<"Placements", 'String'>
    readonly nextStatus: FieldRef<"Placements", 'Int'>
    readonly status: FieldRef<"Placements", 'Int'>
    readonly startDate: FieldRef<"Placements", 'String'>
    readonly title: FieldRef<"Placements", 'String'>
    readonly uid: FieldRef<"Placements", 'String'>
    readonly forms: FieldRef<"Placements", 'Json'>
    readonly questions: FieldRef<"Placements", 'Json'>
    readonly uploadedBy: FieldRef<"Placements", 'String'>
    readonly userGroup: FieldRef<"Placements", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Placements findUnique
   */
  export type PlacementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where: PlacementsWhereUniqueInput
  }


  /**
   * Placements findUniqueOrThrow
   */
  export type PlacementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where: PlacementsWhereUniqueInput
  }


  /**
   * Placements findFirst
   */
  export type PlacementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Placements findFirstOrThrow
   */
  export type PlacementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Placements findMany
   */
  export type PlacementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementsOrderByWithRelationInput | PlacementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Placements.
     */
    cursor?: PlacementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    distinct?: PlacementsScalarFieldEnum | PlacementsScalarFieldEnum[]
  }


  /**
   * Placements create
   */
  export type PlacementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * The data needed to create a Placements.
     */
    data: XOR<PlacementsCreateInput, PlacementsUncheckedCreateInput>
  }


  /**
   * Placements createMany
   */
  export type PlacementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Placements.
     */
    data: PlacementsCreateManyInput | PlacementsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Placements update
   */
  export type PlacementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * The data needed to update a Placements.
     */
    data: XOR<PlacementsUpdateInput, PlacementsUncheckedUpdateInput>
    /**
     * Choose, which Placements to update.
     */
    where: PlacementsWhereUniqueInput
  }


  /**
   * Placements updateMany
   */
  export type PlacementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Placements.
     */
    data: XOR<PlacementsUpdateManyMutationInput, PlacementsUncheckedUpdateManyInput>
    /**
     * Filter which Placements to update
     */
    where?: PlacementsWhereInput
  }


  /**
   * Placements upsert
   */
  export type PlacementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * The filter to search for the Placements to update in case it exists.
     */
    where: PlacementsWhereUniqueInput
    /**
     * In case the Placements found by the `where` argument doesn't exist, create a new Placements with this data.
     */
    create: XOR<PlacementsCreateInput, PlacementsUncheckedCreateInput>
    /**
     * In case the Placements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlacementsUpdateInput, PlacementsUncheckedUpdateInput>
  }


  /**
   * Placements delete
   */
  export type PlacementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
    /**
     * Filter which Placements to delete.
     */
    where: PlacementsWhereUniqueInput
  }


  /**
   * Placements deleteMany
   */
  export type PlacementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Placements to delete
     */
    where?: PlacementsWhereInput
  }


  /**
   * Placements without action
   */
  export type PlacementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placements
     */
    select?: PlacementsSelect<ExtArgs> | null
  }



  /**
   * Model Providers
   */

  export type AggregateProviders = {
    _count: ProvidersCountAggregateOutputType | null
    _avg: ProvidersAvgAggregateOutputType | null
    _sum: ProvidersSumAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  export type ProvidersAvgAggregateOutputType = {
    providerId: number | null
    defAddress: number | null
  }

  export type ProvidersSumAggregateOutputType = {
    providerId: number | null
    defAddress: number | null
  }

  export type ProvidersMinAggregateOutputType = {
    providerId: number | null
    contactForename: string | null
    contactSurname: string | null
    defAddress: number | null
    email: string | null
    mapConsent: boolean | null
    insurance: boolean | null
    mapConsentDate: string | null
    name: string | null
    phone: string | null
    rememberConsent: boolean | null
    rememberConsentDate: string | null
    sector: string | null
    subsector: string | null
    uploadedBy: string | null
    website: string | null
  }

  export type ProvidersMaxAggregateOutputType = {
    providerId: number | null
    contactForename: string | null
    contactSurname: string | null
    defAddress: number | null
    email: string | null
    mapConsent: boolean | null
    insurance: boolean | null
    mapConsentDate: string | null
    name: string | null
    phone: string | null
    rememberConsent: boolean | null
    rememberConsentDate: string | null
    sector: string | null
    subsector: string | null
    uploadedBy: string | null
    website: string | null
  }

  export type ProvidersCountAggregateOutputType = {
    providerId: number
    contactForename: number
    contactSurname: number
    defAddress: number
    email: number
    mapConsent: number
    insurance: number
    mapConsentDate: number
    name: number
    phone: number
    rememberConsent: number
    rememberConsentDate: number
    savedBy: number
    sector: number
    subsector: number
    uploadedBy: number
    website: number
    _all: number
  }


  export type ProvidersAvgAggregateInputType = {
    providerId?: true
    defAddress?: true
  }

  export type ProvidersSumAggregateInputType = {
    providerId?: true
    defAddress?: true
  }

  export type ProvidersMinAggregateInputType = {
    providerId?: true
    contactForename?: true
    contactSurname?: true
    defAddress?: true
    email?: true
    mapConsent?: true
    insurance?: true
    mapConsentDate?: true
    name?: true
    phone?: true
    rememberConsent?: true
    rememberConsentDate?: true
    sector?: true
    subsector?: true
    uploadedBy?: true
    website?: true
  }

  export type ProvidersMaxAggregateInputType = {
    providerId?: true
    contactForename?: true
    contactSurname?: true
    defAddress?: true
    email?: true
    mapConsent?: true
    insurance?: true
    mapConsentDate?: true
    name?: true
    phone?: true
    rememberConsent?: true
    rememberConsentDate?: true
    sector?: true
    subsector?: true
    uploadedBy?: true
    website?: true
  }

  export type ProvidersCountAggregateInputType = {
    providerId?: true
    contactForename?: true
    contactSurname?: true
    defAddress?: true
    email?: true
    mapConsent?: true
    insurance?: true
    mapConsentDate?: true
    name?: true
    phone?: true
    rememberConsent?: true
    rememberConsentDate?: true
    savedBy?: true
    sector?: true
    subsector?: true
    uploadedBy?: true
    website?: true
    _all?: true
  }

  export type ProvidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to aggregate.
     */
    where?: ProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProvidersOrderByWithRelationInput | ProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProvidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvidersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvidersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvidersMaxAggregateInputType
  }

  export type GetProvidersAggregateType<T extends ProvidersAggregateArgs> = {
        [P in keyof T & keyof AggregateProviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviders[P]>
      : GetScalarType<T[P], AggregateProviders[P]>
  }




  export type ProvidersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvidersWhereInput
    orderBy?: ProvidersOrderByWithAggregationInput | ProvidersOrderByWithAggregationInput[]
    by: ProvidersScalarFieldEnum[] | ProvidersScalarFieldEnum
    having?: ProvidersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvidersCountAggregateInputType | true
    _avg?: ProvidersAvgAggregateInputType
    _sum?: ProvidersSumAggregateInputType
    _min?: ProvidersMinAggregateInputType
    _max?: ProvidersMaxAggregateInputType
  }

  export type ProvidersGroupByOutputType = {
    providerId: number
    contactForename: string
    contactSurname: string
    defAddress: number
    email: string
    mapConsent: boolean
    insurance: boolean
    mapConsentDate: string
    name: string
    phone: string
    rememberConsent: boolean
    rememberConsentDate: string
    savedBy: JsonValue
    sector: string
    subsector: string
    uploadedBy: string
    website: string
    _count: ProvidersCountAggregateOutputType | null
    _avg: ProvidersAvgAggregateOutputType | null
    _sum: ProvidersSumAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  type GetProvidersGroupByPayload<T extends ProvidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
            : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
        }
      >
    >


  export type ProvidersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    providerId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    defAddress?: boolean
    email?: boolean
    mapConsent?: boolean
    insurance?: boolean
    mapConsentDate?: boolean
    name?: boolean
    phone?: boolean
    rememberConsent?: boolean
    rememberConsentDate?: boolean
    savedBy?: boolean
    sector?: boolean
    subsector?: boolean
    uploadedBy?: boolean
    website?: boolean
  }, ExtArgs["result"]["providers"]>

  export type ProvidersSelectScalar = {
    providerId?: boolean
    contactForename?: boolean
    contactSurname?: boolean
    defAddress?: boolean
    email?: boolean
    mapConsent?: boolean
    insurance?: boolean
    mapConsentDate?: boolean
    name?: boolean
    phone?: boolean
    rememberConsent?: boolean
    rememberConsentDate?: boolean
    savedBy?: boolean
    sector?: boolean
    subsector?: boolean
    uploadedBy?: boolean
    website?: boolean
  }


  export type $ProvidersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Providers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      providerId: number
      contactForename: string
      contactSurname: string
      defAddress: number
      email: string
      mapConsent: boolean
      insurance: boolean
      mapConsentDate: string
      name: string
      phone: string
      rememberConsent: boolean
      rememberConsentDate: string
      savedBy: Prisma.JsonValue
      sector: string
      subsector: string
      uploadedBy: string
      website: string
    }, ExtArgs["result"]["providers"]>
    composites: {}
  }


  type ProvidersGetPayload<S extends boolean | null | undefined | ProvidersDefaultArgs> = $Result.GetResult<Prisma.$ProvidersPayload, S>

  type ProvidersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProvidersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProvidersCountAggregateInputType | true
    }

  export interface ProvidersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Providers'], meta: { name: 'Providers' } }
    /**
     * Find zero or one Providers that matches the filter.
     * @param {ProvidersFindUniqueArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProvidersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersFindUniqueArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Providers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProvidersFindUniqueOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProvidersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersFindFirstArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProvidersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersFindFirstArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Providers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersFindFirstOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProvidersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.providers.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.providers.findMany({ take: 10 })
     * 
     * // Only select the `providerId`
     * const providersWithProviderIdOnly = await prisma.providers.findMany({ select: { providerId: true } })
     * 
    **/
    findMany<T extends ProvidersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Providers.
     * @param {ProvidersCreateArgs} args - Arguments to create a Providers.
     * @example
     * // Create one Providers
     * const Providers = await prisma.providers.create({
     *   data: {
     *     // ... data to create a Providers
     *   }
     * })
     * 
    **/
    create<T extends ProvidersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersCreateArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Providers.
     *     @param {ProvidersCreateManyArgs} args - Arguments to create many Providers.
     *     @example
     *     // Create many Providers
     *     const providers = await prisma.providers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProvidersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Providers.
     * @param {ProvidersDeleteArgs} args - Arguments to delete one Providers.
     * @example
     * // Delete one Providers
     * const Providers = await prisma.providers.delete({
     *   where: {
     *     // ... filter to delete one Providers
     *   }
     * })
     * 
    **/
    delete<T extends ProvidersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersDeleteArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Providers.
     * @param {ProvidersUpdateArgs} args - Arguments to update one Providers.
     * @example
     * // Update one Providers
     * const providers = await prisma.providers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProvidersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersUpdateArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Providers.
     * @param {ProvidersDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.providers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProvidersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProvidersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const providers = await prisma.providers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProvidersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Providers.
     * @param {ProvidersUpsertArgs} args - Arguments to update or create a Providers.
     * @example
     * // Update or create a Providers
     * const providers = await prisma.providers.upsert({
     *   create: {
     *     // ... data to create a Providers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Providers we want to update
     *   }
     * })
    **/
    upsert<T extends ProvidersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProvidersUpsertArgs<ExtArgs>>
    ): Prisma__ProvidersClient<$Result.GetResult<Prisma.$ProvidersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.providers.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProvidersCountArgs>(
      args?: Subset<T, ProvidersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvidersAggregateArgs>(args: Subset<T, ProvidersAggregateArgs>): Prisma.PrismaPromise<GetProvidersAggregateType<T>>

    /**
     * Group by Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvidersGroupByArgs['orderBy'] }
        : { orderBy?: ProvidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Providers model
   */
  readonly fields: ProvidersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Providers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvidersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Providers model
   */ 
  interface ProvidersFieldRefs {
    readonly providerId: FieldRef<"Providers", 'Int'>
    readonly contactForename: FieldRef<"Providers", 'String'>
    readonly contactSurname: FieldRef<"Providers", 'String'>
    readonly defAddress: FieldRef<"Providers", 'Int'>
    readonly email: FieldRef<"Providers", 'String'>
    readonly mapConsent: FieldRef<"Providers", 'Boolean'>
    readonly insurance: FieldRef<"Providers", 'Boolean'>
    readonly mapConsentDate: FieldRef<"Providers", 'String'>
    readonly name: FieldRef<"Providers", 'String'>
    readonly phone: FieldRef<"Providers", 'String'>
    readonly rememberConsent: FieldRef<"Providers", 'Boolean'>
    readonly rememberConsentDate: FieldRef<"Providers", 'String'>
    readonly savedBy: FieldRef<"Providers", 'Json'>
    readonly sector: FieldRef<"Providers", 'String'>
    readonly subsector: FieldRef<"Providers", 'String'>
    readonly uploadedBy: FieldRef<"Providers", 'String'>
    readonly website: FieldRef<"Providers", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Providers findUnique
   */
  export type ProvidersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where: ProvidersWhereUniqueInput
  }


  /**
   * Providers findUniqueOrThrow
   */
  export type ProvidersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where: ProvidersWhereUniqueInput
  }


  /**
   * Providers findFirst
   */
  export type ProvidersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProvidersOrderByWithRelationInput | ProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }


  /**
   * Providers findFirstOrThrow
   */
  export type ProvidersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProvidersOrderByWithRelationInput | ProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }


  /**
   * Providers findMany
   */
  export type ProvidersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProvidersOrderByWithRelationInput | ProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }


  /**
   * Providers create
   */
  export type ProvidersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * The data needed to create a Providers.
     */
    data: XOR<ProvidersCreateInput, ProvidersUncheckedCreateInput>
  }


  /**
   * Providers createMany
   */
  export type ProvidersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProvidersCreateManyInput | ProvidersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Providers update
   */
  export type ProvidersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * The data needed to update a Providers.
     */
    data: XOR<ProvidersUpdateInput, ProvidersUncheckedUpdateInput>
    /**
     * Choose, which Providers to update.
     */
    where: ProvidersWhereUniqueInput
  }


  /**
   * Providers updateMany
   */
  export type ProvidersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProvidersUpdateManyMutationInput, ProvidersUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProvidersWhereInput
  }


  /**
   * Providers upsert
   */
  export type ProvidersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * The filter to search for the Providers to update in case it exists.
     */
    where: ProvidersWhereUniqueInput
    /**
     * In case the Providers found by the `where` argument doesn't exist, create a new Providers with this data.
     */
    create: XOR<ProvidersCreateInput, ProvidersUncheckedCreateInput>
    /**
     * In case the Providers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvidersUpdateInput, ProvidersUncheckedUpdateInput>
  }


  /**
   * Providers delete
   */
  export type ProvidersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
    /**
     * Filter which Providers to delete.
     */
    where: ProvidersWhereUniqueInput
  }


  /**
   * Providers deleteMany
   */
  export type ProvidersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProvidersWhereInput
  }


  /**
   * Providers without action
   */
  export type ProvidersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Providers
     */
    select?: ProvidersSelect<ExtArgs> | null
  }



  /**
   * Model Referrals
   */

  export type AggregateReferrals = {
    _count: ReferralsCountAggregateOutputType | null
    _avg: ReferralsAvgAggregateOutputType | null
    _sum: ReferralsSumAggregateOutputType | null
    _min: ReferralsMinAggregateOutputType | null
    _max: ReferralsMaxAggregateOutputType | null
  }

  export type ReferralsAvgAggregateOutputType = {
    referralId: number | null
    signUps: number | null
    volume: number | null
  }

  export type ReferralsSumAggregateOutputType = {
    referralId: number | null
    signUps: number | null
    volume: number | null
  }

  export type ReferralsMinAggregateOutputType = {
    referralId: number | null
    expiry: Date | null
    name: string | null
    product: string | null
    signUps: number | null
    volume: number | null
  }

  export type ReferralsMaxAggregateOutputType = {
    referralId: number | null
    expiry: Date | null
    name: string | null
    product: string | null
    signUps: number | null
    volume: number | null
  }

  export type ReferralsCountAggregateOutputType = {
    referralId: number
    expiry: number
    name: number
    product: number
    signUps: number
    volume: number
    _all: number
  }


  export type ReferralsAvgAggregateInputType = {
    referralId?: true
    signUps?: true
    volume?: true
  }

  export type ReferralsSumAggregateInputType = {
    referralId?: true
    signUps?: true
    volume?: true
  }

  export type ReferralsMinAggregateInputType = {
    referralId?: true
    expiry?: true
    name?: true
    product?: true
    signUps?: true
    volume?: true
  }

  export type ReferralsMaxAggregateInputType = {
    referralId?: true
    expiry?: true
    name?: true
    product?: true
    signUps?: true
    volume?: true
  }

  export type ReferralsCountAggregateInputType = {
    referralId?: true
    expiry?: true
    name?: true
    product?: true
    signUps?: true
    volume?: true
    _all?: true
  }

  export type ReferralsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to aggregate.
     */
    where?: ReferralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralsMaxAggregateInputType
  }

  export type GetReferralsAggregateType<T extends ReferralsAggregateArgs> = {
        [P in keyof T & keyof AggregateReferrals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferrals[P]>
      : GetScalarType<T[P], AggregateReferrals[P]>
  }




  export type ReferralsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralsWhereInput
    orderBy?: ReferralsOrderByWithAggregationInput | ReferralsOrderByWithAggregationInput[]
    by: ReferralsScalarFieldEnum[] | ReferralsScalarFieldEnum
    having?: ReferralsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralsCountAggregateInputType | true
    _avg?: ReferralsAvgAggregateInputType
    _sum?: ReferralsSumAggregateInputType
    _min?: ReferralsMinAggregateInputType
    _max?: ReferralsMaxAggregateInputType
  }

  export type ReferralsGroupByOutputType = {
    referralId: number
    expiry: Date
    name: string
    product: string
    signUps: number
    volume: number
    _count: ReferralsCountAggregateOutputType | null
    _avg: ReferralsAvgAggregateOutputType | null
    _sum: ReferralsSumAggregateOutputType | null
    _min: ReferralsMinAggregateOutputType | null
    _max: ReferralsMaxAggregateOutputType | null
  }

  type GetReferralsGroupByPayload<T extends ReferralsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralsGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralsGroupByOutputType[P]>
        }
      >
    >


  export type ReferralsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    referralId?: boolean
    expiry?: boolean
    name?: boolean
    product?: boolean
    signUps?: boolean
    volume?: boolean
  }, ExtArgs["result"]["referrals"]>

  export type ReferralsSelectScalar = {
    referralId?: boolean
    expiry?: boolean
    name?: boolean
    product?: boolean
    signUps?: boolean
    volume?: boolean
  }


  export type $ReferralsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referrals"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      referralId: number
      expiry: Date
      name: string
      product: string
      signUps: number
      volume: number
    }, ExtArgs["result"]["referrals"]>
    composites: {}
  }


  type ReferralsGetPayload<S extends boolean | null | undefined | ReferralsDefaultArgs> = $Result.GetResult<Prisma.$ReferralsPayload, S>

  type ReferralsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralsCountAggregateInputType | true
    }

  export interface ReferralsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referrals'], meta: { name: 'Referrals' } }
    /**
     * Find zero or one Referrals that matches the filter.
     * @param {ReferralsFindUniqueArgs} args - Arguments to find a Referrals
     * @example
     * // Get one Referrals
     * const referrals = await prisma.referrals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReferralsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReferralsFindUniqueArgs<ExtArgs>>
    ): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Referrals that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReferralsFindUniqueOrThrowArgs} args - Arguments to find a Referrals
     * @example
     * // Get one Referrals
     * const referrals = await prisma.referrals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReferralsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReferralsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsFindFirstArgs} args - Arguments to find a Referrals
     * @example
     * // Get one Referrals
     * const referrals = await prisma.referrals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReferralsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReferralsFindFirstArgs<ExtArgs>>
    ): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Referrals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsFindFirstOrThrowArgs} args - Arguments to find a Referrals
     * @example
     * // Get one Referrals
     * const referrals = await prisma.referrals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReferralsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReferralsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referrals.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referrals.findMany({ take: 10 })
     * 
     * // Only select the `referralId`
     * const referralsWithReferralIdOnly = await prisma.referrals.findMany({ select: { referralId: true } })
     * 
    **/
    findMany<T extends ReferralsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReferralsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Referrals.
     * @param {ReferralsCreateArgs} args - Arguments to create a Referrals.
     * @example
     * // Create one Referrals
     * const Referrals = await prisma.referrals.create({
     *   data: {
     *     // ... data to create a Referrals
     *   }
     * })
     * 
    **/
    create<T extends ReferralsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReferralsCreateArgs<ExtArgs>>
    ): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Referrals.
     *     @param {ReferralsCreateManyArgs} args - Arguments to create many Referrals.
     *     @example
     *     // Create many Referrals
     *     const referrals = await prisma.referrals.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReferralsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReferralsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referrals.
     * @param {ReferralsDeleteArgs} args - Arguments to delete one Referrals.
     * @example
     * // Delete one Referrals
     * const Referrals = await prisma.referrals.delete({
     *   where: {
     *     // ... filter to delete one Referrals
     *   }
     * })
     * 
    **/
    delete<T extends ReferralsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReferralsDeleteArgs<ExtArgs>>
    ): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Referrals.
     * @param {ReferralsUpdateArgs} args - Arguments to update one Referrals.
     * @example
     * // Update one Referrals
     * const referrals = await prisma.referrals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReferralsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReferralsUpdateArgs<ExtArgs>>
    ): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralsDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referrals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReferralsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReferralsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referrals = await prisma.referrals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReferralsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReferralsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referrals.
     * @param {ReferralsUpsertArgs} args - Arguments to update or create a Referrals.
     * @example
     * // Update or create a Referrals
     * const referrals = await prisma.referrals.upsert({
     *   create: {
     *     // ... data to create a Referrals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referrals we want to update
     *   }
     * })
    **/
    upsert<T extends ReferralsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReferralsUpsertArgs<ExtArgs>>
    ): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referrals.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralsCountArgs>(
      args?: Subset<T, ReferralsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralsAggregateArgs>(args: Subset<T, ReferralsAggregateArgs>): Prisma.PrismaPromise<GetReferralsAggregateType<T>>

    /**
     * Group by Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralsGroupByArgs['orderBy'] }
        : { orderBy?: ReferralsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referrals model
   */
  readonly fields: ReferralsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referrals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Referrals model
   */ 
  interface ReferralsFieldRefs {
    readonly referralId: FieldRef<"Referrals", 'Int'>
    readonly expiry: FieldRef<"Referrals", 'DateTime'>
    readonly name: FieldRef<"Referrals", 'String'>
    readonly product: FieldRef<"Referrals", 'String'>
    readonly signUps: FieldRef<"Referrals", 'Int'>
    readonly volume: FieldRef<"Referrals", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Referrals findUnique
   */
  export type ReferralsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where: ReferralsWhereUniqueInput
  }


  /**
   * Referrals findUniqueOrThrow
   */
  export type ReferralsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where: ReferralsWhereUniqueInput
  }


  /**
   * Referrals findFirst
   */
  export type ReferralsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralsScalarFieldEnum | ReferralsScalarFieldEnum[]
  }


  /**
   * Referrals findFirstOrThrow
   */
  export type ReferralsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralsScalarFieldEnum | ReferralsScalarFieldEnum[]
  }


  /**
   * Referrals findMany
   */
  export type ReferralsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralsScalarFieldEnum | ReferralsScalarFieldEnum[]
  }


  /**
   * Referrals create
   */
  export type ReferralsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * The data needed to create a Referrals.
     */
    data: XOR<ReferralsCreateInput, ReferralsUncheckedCreateInput>
  }


  /**
   * Referrals createMany
   */
  export type ReferralsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralsCreateManyInput | ReferralsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Referrals update
   */
  export type ReferralsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * The data needed to update a Referrals.
     */
    data: XOR<ReferralsUpdateInput, ReferralsUncheckedUpdateInput>
    /**
     * Choose, which Referrals to update.
     */
    where: ReferralsWhereUniqueInput
  }


  /**
   * Referrals updateMany
   */
  export type ReferralsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralsUpdateManyMutationInput, ReferralsUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralsWhereInput
  }


  /**
   * Referrals upsert
   */
  export type ReferralsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * The filter to search for the Referrals to update in case it exists.
     */
    where: ReferralsWhereUniqueInput
    /**
     * In case the Referrals found by the `where` argument doesn't exist, create a new Referrals with this data.
     */
    create: XOR<ReferralsCreateInput, ReferralsUncheckedCreateInput>
    /**
     * In case the Referrals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralsUpdateInput, ReferralsUncheckedUpdateInput>
  }


  /**
   * Referrals delete
   */
  export type ReferralsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Filter which Referrals to delete.
     */
    where: ReferralsWhereUniqueInput
  }


  /**
   * Referrals deleteMany
   */
  export type ReferralsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralsWhereInput
  }


  /**
   * Referrals without action
   */
  export type ReferralsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
  }



  /**
   * Model UserGroups
   */

  export type AggregateUserGroups = {
    _count: UserGroupsCountAggregateOutputType | null
    _avg: UserGroupsAvgAggregateOutputType | null
    _sum: UserGroupsSumAggregateOutputType | null
    _min: UserGroupsMinAggregateOutputType | null
    _max: UserGroupsMaxAggregateOutputType | null
  }

  export type UserGroupsAvgAggregateOutputType = {
    userGroupId: number | null
    oId: number | null
  }

  export type UserGroupsSumAggregateOutputType = {
    userGroupId: number | null
    oId: number | null
  }

  export type UserGroupsMinAggregateOutputType = {
    userGroupId: number | null
    default: boolean | null
    name: string | null
    oId: number | null
    product: string | null
    template: string | null
    updated: string | null
  }

  export type UserGroupsMaxAggregateOutputType = {
    userGroupId: number | null
    default: boolean | null
    name: string | null
    oId: number | null
    product: string | null
    template: string | null
    updated: string | null
  }

  export type UserGroupsCountAggregateOutputType = {
    userGroupId: number
    default: number
    name: number
    oId: number
    product: number
    template: number
    updated: number
    _all: number
  }


  export type UserGroupsAvgAggregateInputType = {
    userGroupId?: true
    oId?: true
  }

  export type UserGroupsSumAggregateInputType = {
    userGroupId?: true
    oId?: true
  }

  export type UserGroupsMinAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    oId?: true
    product?: true
    template?: true
    updated?: true
  }

  export type UserGroupsMaxAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    oId?: true
    product?: true
    template?: true
    updated?: true
  }

  export type UserGroupsCountAggregateInputType = {
    userGroupId?: true
    default?: true
    name?: true
    oId?: true
    product?: true
    template?: true
    updated?: true
    _all?: true
  }

  export type UserGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroups to aggregate.
     */
    where?: UserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupsOrderByWithRelationInput | UserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroups
    **/
    _count?: true | UserGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupsMaxAggregateInputType
  }

  export type GetUserGroupsAggregateType<T extends UserGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroups[P]>
      : GetScalarType<T[P], AggregateUserGroups[P]>
  }




  export type UserGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupsWhereInput
    orderBy?: UserGroupsOrderByWithAggregationInput | UserGroupsOrderByWithAggregationInput[]
    by: UserGroupsScalarFieldEnum[] | UserGroupsScalarFieldEnum
    having?: UserGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupsCountAggregateInputType | true
    _avg?: UserGroupsAvgAggregateInputType
    _sum?: UserGroupsSumAggregateInputType
    _min?: UserGroupsMinAggregateInputType
    _max?: UserGroupsMaxAggregateInputType
  }

  export type UserGroupsGroupByOutputType = {
    userGroupId: number
    default: boolean
    name: string
    oId: number
    product: string
    template: string
    updated: string
    _count: UserGroupsCountAggregateOutputType | null
    _avg: UserGroupsAvgAggregateOutputType | null
    _sum: UserGroupsSumAggregateOutputType | null
    _min: UserGroupsMinAggregateOutputType | null
    _max: UserGroupsMaxAggregateOutputType | null
  }

  type GetUserGroupsGroupByPayload<T extends UserGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupsGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userGroupId?: boolean
    default?: boolean
    name?: boolean
    oId?: boolean
    product?: boolean
    template?: boolean
    updated?: boolean
  }, ExtArgs["result"]["userGroups"]>

  export type UserGroupsSelectScalar = {
    userGroupId?: boolean
    default?: boolean
    name?: boolean
    oId?: boolean
    product?: boolean
    template?: boolean
    updated?: boolean
  }


  export type $UserGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGroups"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userGroupId: number
      default: boolean
      name: string
      oId: number
      product: string
      template: string
      updated: string
    }, ExtArgs["result"]["userGroups"]>
    composites: {}
  }


  type UserGroupsGetPayload<S extends boolean | null | undefined | UserGroupsDefaultArgs> = $Result.GetResult<Prisma.$UserGroupsPayload, S>

  type UserGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserGroupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserGroupsCountAggregateInputType | true
    }

  export interface UserGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGroups'], meta: { name: 'UserGroups' } }
    /**
     * Find zero or one UserGroups that matches the filter.
     * @param {UserGroupsFindUniqueArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserGroupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserGroupsFindUniqueArgs<ExtArgs>>
    ): Prisma__UserGroupsClient<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserGroups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserGroupsFindUniqueOrThrowArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserGroupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserGroupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserGroupsClient<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsFindFirstArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserGroupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserGroupsFindFirstArgs<ExtArgs>>
    ): Prisma__UserGroupsClient<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsFindFirstOrThrowArgs} args - Arguments to find a UserGroups
     * @example
     * // Get one UserGroups
     * const userGroups = await prisma.userGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserGroupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserGroupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserGroupsClient<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroups
     * const userGroups = await prisma.userGroups.findMany()
     * 
     * // Get first 10 UserGroups
     * const userGroups = await prisma.userGroups.findMany({ take: 10 })
     * 
     * // Only select the `userGroupId`
     * const userGroupsWithUserGroupIdOnly = await prisma.userGroups.findMany({ select: { userGroupId: true } })
     * 
    **/
    findMany<T extends UserGroupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserGroupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserGroups.
     * @param {UserGroupsCreateArgs} args - Arguments to create a UserGroups.
     * @example
     * // Create one UserGroups
     * const UserGroups = await prisma.userGroups.create({
     *   data: {
     *     // ... data to create a UserGroups
     *   }
     * })
     * 
    **/
    create<T extends UserGroupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserGroupsCreateArgs<ExtArgs>>
    ): Prisma__UserGroupsClient<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserGroups.
     *     @param {UserGroupsCreateManyArgs} args - Arguments to create many UserGroups.
     *     @example
     *     // Create many UserGroups
     *     const userGroups = await prisma.userGroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserGroupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserGroupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserGroups.
     * @param {UserGroupsDeleteArgs} args - Arguments to delete one UserGroups.
     * @example
     * // Delete one UserGroups
     * const UserGroups = await prisma.userGroups.delete({
     *   where: {
     *     // ... filter to delete one UserGroups
     *   }
     * })
     * 
    **/
    delete<T extends UserGroupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserGroupsDeleteArgs<ExtArgs>>
    ): Prisma__UserGroupsClient<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserGroups.
     * @param {UserGroupsUpdateArgs} args - Arguments to update one UserGroups.
     * @example
     * // Update one UserGroups
     * const userGroups = await prisma.userGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserGroupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserGroupsUpdateArgs<ExtArgs>>
    ): Prisma__UserGroupsClient<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserGroups.
     * @param {UserGroupsDeleteManyArgs} args - Arguments to filter UserGroups to delete.
     * @example
     * // Delete a few UserGroups
     * const { count } = await prisma.userGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserGroupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserGroupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroups
     * const userGroups = await prisma.userGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserGroupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserGroupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGroups.
     * @param {UserGroupsUpsertArgs} args - Arguments to update or create a UserGroups.
     * @example
     * // Update or create a UserGroups
     * const userGroups = await prisma.userGroups.upsert({
     *   create: {
     *     // ... data to create a UserGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroups we want to update
     *   }
     * })
    **/
    upsert<T extends UserGroupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserGroupsUpsertArgs<ExtArgs>>
    ): Prisma__UserGroupsClient<$Result.GetResult<Prisma.$UserGroupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsCountArgs} args - Arguments to filter UserGroups to count.
     * @example
     * // Count the number of UserGroups
     * const count = await prisma.userGroups.count({
     *   where: {
     *     // ... the filter for the UserGroups we want to count
     *   }
     * })
    **/
    count<T extends UserGroupsCountArgs>(
      args?: Subset<T, UserGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupsAggregateArgs>(args: Subset<T, UserGroupsAggregateArgs>): Prisma.PrismaPromise<GetUserGroupsAggregateType<T>>

    /**
     * Group by UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupsGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGroups model
   */
  readonly fields: UserGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserGroups model
   */ 
  interface UserGroupsFieldRefs {
    readonly userGroupId: FieldRef<"UserGroups", 'Int'>
    readonly default: FieldRef<"UserGroups", 'Boolean'>
    readonly name: FieldRef<"UserGroups", 'String'>
    readonly oId: FieldRef<"UserGroups", 'Int'>
    readonly product: FieldRef<"UserGroups", 'String'>
    readonly template: FieldRef<"UserGroups", 'String'>
    readonly updated: FieldRef<"UserGroups", 'String'>
  }
    

  // Custom InputTypes

  /**
   * UserGroups findUnique
   */
  export type UserGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where: UserGroupsWhereUniqueInput
  }


  /**
   * UserGroups findUniqueOrThrow
   */
  export type UserGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where: UserGroupsWhereUniqueInput
  }


  /**
   * UserGroups findFirst
   */
  export type UserGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where?: UserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupsOrderByWithRelationInput | UserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupsScalarFieldEnum | UserGroupsScalarFieldEnum[]
  }


  /**
   * UserGroups findFirstOrThrow
   */
  export type UserGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where?: UserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupsOrderByWithRelationInput | UserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupsScalarFieldEnum | UserGroupsScalarFieldEnum[]
  }


  /**
   * UserGroups findMany
   */
  export type UserGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where?: UserGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupsOrderByWithRelationInput | UserGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroups.
     */
    cursor?: UserGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    distinct?: UserGroupsScalarFieldEnum | UserGroupsScalarFieldEnum[]
  }


  /**
   * UserGroups create
   */
  export type UserGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * The data needed to create a UserGroups.
     */
    data: XOR<UserGroupsCreateInput, UserGroupsUncheckedCreateInput>
  }


  /**
   * UserGroups createMany
   */
  export type UserGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupsCreateManyInput | UserGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserGroups update
   */
  export type UserGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * The data needed to update a UserGroups.
     */
    data: XOR<UserGroupsUpdateInput, UserGroupsUncheckedUpdateInput>
    /**
     * Choose, which UserGroups to update.
     */
    where: UserGroupsWhereUniqueInput
  }


  /**
   * UserGroups updateMany
   */
  export type UserGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGroups.
     */
    data: XOR<UserGroupsUpdateManyMutationInput, UserGroupsUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     */
    where?: UserGroupsWhereInput
  }


  /**
   * UserGroups upsert
   */
  export type UserGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * The filter to search for the UserGroups to update in case it exists.
     */
    where: UserGroupsWhereUniqueInput
    /**
     * In case the UserGroups found by the `where` argument doesn't exist, create a new UserGroups with this data.
     */
    create: XOR<UserGroupsCreateInput, UserGroupsUncheckedCreateInput>
    /**
     * In case the UserGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGroupsUpdateInput, UserGroupsUncheckedUpdateInput>
  }


  /**
   * UserGroups delete
   */
  export type UserGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
    /**
     * Filter which UserGroups to delete.
     */
    where: UserGroupsWhereUniqueInput
  }


  /**
   * UserGroups deleteMany
   */
  export type UserGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroups to delete
     */
    where?: UserGroupsWhereInput
  }


  /**
   * UserGroups without action
   */
  export type UserGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroups
     */
    select?: UserGroupsSelect<ExtArgs> | null
  }



  /**
   * Model StudentUsers
   */

  export type AggregateStudentUsers = {
    _count: StudentUsersCountAggregateOutputType | null
    _min: StudentUsersMinAggregateOutputType | null
    _max: StudentUsersMaxAggregateOutputType | null
  }

  export type StudentUsersMinAggregateOutputType = {
    studentUserId: string | null
    status: string | null
    created: string | null
    email: string | null
    referral: string | null
    units: string | null
    userType: string | null
  }

  export type StudentUsersMaxAggregateOutputType = {
    studentUserId: string | null
    status: string | null
    created: string | null
    email: string | null
    referral: string | null
    units: string | null
    userType: string | null
  }

  export type StudentUsersCountAggregateOutputType = {
    studentUserId: number
    status: number
    analytics: number
    created: number
    details: number
    email: number
    referral: number
    units: number
    userType: number
    _all: number
  }


  export type StudentUsersMinAggregateInputType = {
    studentUserId?: true
    status?: true
    created?: true
    email?: true
    referral?: true
    units?: true
    userType?: true
  }

  export type StudentUsersMaxAggregateInputType = {
    studentUserId?: true
    status?: true
    created?: true
    email?: true
    referral?: true
    units?: true
    userType?: true
  }

  export type StudentUsersCountAggregateInputType = {
    studentUserId?: true
    status?: true
    analytics?: true
    created?: true
    details?: true
    email?: true
    referral?: true
    units?: true
    userType?: true
    _all?: true
  }

  export type StudentUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentUsers to aggregate.
     */
    where?: StudentUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentUsers to fetch.
     */
    orderBy?: StudentUsersOrderByWithRelationInput | StudentUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentUsers
    **/
    _count?: true | StudentUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentUsersMaxAggregateInputType
  }

  export type GetStudentUsersAggregateType<T extends StudentUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentUsers[P]>
      : GetScalarType<T[P], AggregateStudentUsers[P]>
  }




  export type StudentUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentUsersWhereInput
    orderBy?: StudentUsersOrderByWithAggregationInput | StudentUsersOrderByWithAggregationInput[]
    by: StudentUsersScalarFieldEnum[] | StudentUsersScalarFieldEnum
    having?: StudentUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentUsersCountAggregateInputType | true
    _min?: StudentUsersMinAggregateInputType
    _max?: StudentUsersMaxAggregateInputType
  }

  export type StudentUsersGroupByOutputType = {
    studentUserId: string
    status: string
    analytics: JsonValue
    created: string
    details: JsonValue
    email: string
    referral: string
    units: string
    userType: string
    _count: StudentUsersCountAggregateOutputType | null
    _min: StudentUsersMinAggregateOutputType | null
    _max: StudentUsersMaxAggregateOutputType | null
  }

  type GetStudentUsersGroupByPayload<T extends StudentUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentUsersGroupByOutputType[P]>
            : GetScalarType<T[P], StudentUsersGroupByOutputType[P]>
        }
      >
    >


  export type StudentUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studentUserId?: boolean
    status?: boolean
    analytics?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    referral?: boolean
    units?: boolean
    userType?: boolean
  }, ExtArgs["result"]["studentUsers"]>

  export type StudentUsersSelectScalar = {
    studentUserId?: boolean
    status?: boolean
    analytics?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    referral?: boolean
    units?: boolean
    userType?: boolean
  }


  export type $StudentUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentUsers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      studentUserId: string
      status: string
      analytics: Prisma.JsonValue
      created: string
      details: Prisma.JsonValue
      email: string
      referral: string
      units: string
      userType: string
    }, ExtArgs["result"]["studentUsers"]>
    composites: {}
  }


  type StudentUsersGetPayload<S extends boolean | null | undefined | StudentUsersDefaultArgs> = $Result.GetResult<Prisma.$StudentUsersPayload, S>

  type StudentUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentUsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentUsersCountAggregateInputType | true
    }

  export interface StudentUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentUsers'], meta: { name: 'StudentUsers' } }
    /**
     * Find zero or one StudentUsers that matches the filter.
     * @param {StudentUsersFindUniqueArgs} args - Arguments to find a StudentUsers
     * @example
     * // Get one StudentUsers
     * const studentUsers = await prisma.studentUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentUsersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentUsers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentUsersFindUniqueOrThrowArgs} args - Arguments to find a StudentUsers
     * @example
     * // Get one StudentUsers
     * const studentUsers = await prisma.studentUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentUsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersFindFirstArgs} args - Arguments to find a StudentUsers
     * @example
     * // Get one StudentUsers
     * const studentUsers = await prisma.studentUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentUsersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersFindFirstArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersFindFirstOrThrowArgs} args - Arguments to find a StudentUsers
     * @example
     * // Get one StudentUsers
     * const studentUsers = await prisma.studentUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentUsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentUsers
     * const studentUsers = await prisma.studentUsers.findMany()
     * 
     * // Get first 10 StudentUsers
     * const studentUsers = await prisma.studentUsers.findMany({ take: 10 })
     * 
     * // Only select the `studentUserId`
     * const studentUsersWithStudentUserIdOnly = await prisma.studentUsers.findMany({ select: { studentUserId: true } })
     * 
    **/
    findMany<T extends StudentUsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentUsers.
     * @param {StudentUsersCreateArgs} args - Arguments to create a StudentUsers.
     * @example
     * // Create one StudentUsers
     * const StudentUsers = await prisma.studentUsers.create({
     *   data: {
     *     // ... data to create a StudentUsers
     *   }
     * })
     * 
    **/
    create<T extends StudentUsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersCreateArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentUsers.
     *     @param {StudentUsersCreateManyArgs} args - Arguments to create many StudentUsers.
     *     @example
     *     // Create many StudentUsers
     *     const studentUsers = await prisma.studentUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentUsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentUsers.
     * @param {StudentUsersDeleteArgs} args - Arguments to delete one StudentUsers.
     * @example
     * // Delete one StudentUsers
     * const StudentUsers = await prisma.studentUsers.delete({
     *   where: {
     *     // ... filter to delete one StudentUsers
     *   }
     * })
     * 
    **/
    delete<T extends StudentUsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersDeleteArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentUsers.
     * @param {StudentUsersUpdateArgs} args - Arguments to update one StudentUsers.
     * @example
     * // Update one StudentUsers
     * const studentUsers = await prisma.studentUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersUpdateArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentUsers.
     * @param {StudentUsersDeleteManyArgs} args - Arguments to filter StudentUsers to delete.
     * @example
     * // Delete a few StudentUsers
     * const { count } = await prisma.studentUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentUsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentUsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentUsers
     * const studentUsers = await prisma.studentUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentUsers.
     * @param {StudentUsersUpsertArgs} args - Arguments to update or create a StudentUsers.
     * @example
     * // Update or create a StudentUsers
     * const studentUsers = await prisma.studentUsers.upsert({
     *   create: {
     *     // ... data to create a StudentUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentUsers we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUsersUpsertArgs<ExtArgs>>
    ): Prisma__StudentUsersClient<$Result.GetResult<Prisma.$StudentUsersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersCountArgs} args - Arguments to filter StudentUsers to count.
     * @example
     * // Count the number of StudentUsers
     * const count = await prisma.studentUsers.count({
     *   where: {
     *     // ... the filter for the StudentUsers we want to count
     *   }
     * })
    **/
    count<T extends StudentUsersCountArgs>(
      args?: Subset<T, StudentUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentUsersAggregateArgs>(args: Subset<T, StudentUsersAggregateArgs>): Prisma.PrismaPromise<GetStudentUsersAggregateType<T>>

    /**
     * Group by StudentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentUsersGroupByArgs['orderBy'] }
        : { orderBy?: StudentUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentUsers model
   */
  readonly fields: StudentUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentUsers model
   */ 
  interface StudentUsersFieldRefs {
    readonly studentUserId: FieldRef<"StudentUsers", 'String'>
    readonly status: FieldRef<"StudentUsers", 'String'>
    readonly analytics: FieldRef<"StudentUsers", 'Json'>
    readonly created: FieldRef<"StudentUsers", 'String'>
    readonly details: FieldRef<"StudentUsers", 'Json'>
    readonly email: FieldRef<"StudentUsers", 'String'>
    readonly referral: FieldRef<"StudentUsers", 'String'>
    readonly units: FieldRef<"StudentUsers", 'String'>
    readonly userType: FieldRef<"StudentUsers", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StudentUsers findUnique
   */
  export type StudentUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where: StudentUsersWhereUniqueInput
  }


  /**
   * StudentUsers findUniqueOrThrow
   */
  export type StudentUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where: StudentUsersWhereUniqueInput
  }


  /**
   * StudentUsers findFirst
   */
  export type StudentUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where?: StudentUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentUsers to fetch.
     */
    orderBy?: StudentUsersOrderByWithRelationInput | StudentUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentUsers.
     */
    cursor?: StudentUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentUsers.
     */
    distinct?: StudentUsersScalarFieldEnum | StudentUsersScalarFieldEnum[]
  }


  /**
   * StudentUsers findFirstOrThrow
   */
  export type StudentUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where?: StudentUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentUsers to fetch.
     */
    orderBy?: StudentUsersOrderByWithRelationInput | StudentUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentUsers.
     */
    cursor?: StudentUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentUsers.
     */
    distinct?: StudentUsersScalarFieldEnum | StudentUsersScalarFieldEnum[]
  }


  /**
   * StudentUsers findMany
   */
  export type StudentUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Filter, which StudentUsers to fetch.
     */
    where?: StudentUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentUsers to fetch.
     */
    orderBy?: StudentUsersOrderByWithRelationInput | StudentUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentUsers.
     */
    cursor?: StudentUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentUsers.
     */
    skip?: number
    distinct?: StudentUsersScalarFieldEnum | StudentUsersScalarFieldEnum[]
  }


  /**
   * StudentUsers create
   */
  export type StudentUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * The data needed to create a StudentUsers.
     */
    data: XOR<StudentUsersCreateInput, StudentUsersUncheckedCreateInput>
  }


  /**
   * StudentUsers createMany
   */
  export type StudentUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentUsers.
     */
    data: StudentUsersCreateManyInput | StudentUsersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentUsers update
   */
  export type StudentUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * The data needed to update a StudentUsers.
     */
    data: XOR<StudentUsersUpdateInput, StudentUsersUncheckedUpdateInput>
    /**
     * Choose, which StudentUsers to update.
     */
    where: StudentUsersWhereUniqueInput
  }


  /**
   * StudentUsers updateMany
   */
  export type StudentUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentUsers.
     */
    data: XOR<StudentUsersUpdateManyMutationInput, StudentUsersUncheckedUpdateManyInput>
    /**
     * Filter which StudentUsers to update
     */
    where?: StudentUsersWhereInput
  }


  /**
   * StudentUsers upsert
   */
  export type StudentUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * The filter to search for the StudentUsers to update in case it exists.
     */
    where: StudentUsersWhereUniqueInput
    /**
     * In case the StudentUsers found by the `where` argument doesn't exist, create a new StudentUsers with this data.
     */
    create: XOR<StudentUsersCreateInput, StudentUsersUncheckedCreateInput>
    /**
     * In case the StudentUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUsersUpdateInput, StudentUsersUncheckedUpdateInput>
  }


  /**
   * StudentUsers delete
   */
  export type StudentUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
    /**
     * Filter which StudentUsers to delete.
     */
    where: StudentUsersWhereUniqueInput
  }


  /**
   * StudentUsers deleteMany
   */
  export type StudentUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentUsers to delete
     */
    where?: StudentUsersWhereInput
  }


  /**
   * StudentUsers without action
   */
  export type StudentUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentUsers
     */
    select?: StudentUsersSelect<ExtArgs> | null
  }



  /**
   * Model InstituteStaff
   */

  export type AggregateInstituteStaff = {
    _count: InstituteStaffCountAggregateOutputType | null
    _min: InstituteStaffMinAggregateOutputType | null
    _max: InstituteStaffMaxAggregateOutputType | null
  }

  export type InstituteStaffMinAggregateOutputType = {
    instituteStaffId: string | null
    created: string | null
    email: string | null
    oId: string | null
    status: string | null
    userGroup: string | null
    userType: string | null
  }

  export type InstituteStaffMaxAggregateOutputType = {
    instituteStaffId: string | null
    created: string | null
    email: string | null
    oId: string | null
    status: string | null
    userGroup: string | null
    userType: string | null
  }

  export type InstituteStaffCountAggregateOutputType = {
    instituteStaffId: number
    created: number
    details: number
    email: number
    oId: number
    status: number
    userGroup: number
    userType: number
    _all: number
  }


  export type InstituteStaffMinAggregateInputType = {
    instituteStaffId?: true
    created?: true
    email?: true
    oId?: true
    status?: true
    userGroup?: true
    userType?: true
  }

  export type InstituteStaffMaxAggregateInputType = {
    instituteStaffId?: true
    created?: true
    email?: true
    oId?: true
    status?: true
    userGroup?: true
    userType?: true
  }

  export type InstituteStaffCountAggregateInputType = {
    instituteStaffId?: true
    created?: true
    details?: true
    email?: true
    oId?: true
    status?: true
    userGroup?: true
    userType?: true
    _all?: true
  }

  export type InstituteStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStaff to aggregate.
     */
    where?: InstituteStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffs to fetch.
     */
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstituteStaffs
    **/
    _count?: true | InstituteStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteStaffMaxAggregateInputType
  }

  export type GetInstituteStaffAggregateType<T extends InstituteStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateInstituteStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstituteStaff[P]>
      : GetScalarType<T[P], AggregateInstituteStaff[P]>
  }




  export type InstituteStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStaffWhereInput
    orderBy?: InstituteStaffOrderByWithAggregationInput | InstituteStaffOrderByWithAggregationInput[]
    by: InstituteStaffScalarFieldEnum[] | InstituteStaffScalarFieldEnum
    having?: InstituteStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteStaffCountAggregateInputType | true
    _min?: InstituteStaffMinAggregateInputType
    _max?: InstituteStaffMaxAggregateInputType
  }

  export type InstituteStaffGroupByOutputType = {
    instituteStaffId: string
    created: string
    details: JsonValue
    email: string
    oId: string
    status: string
    userGroup: string
    userType: string
    _count: InstituteStaffCountAggregateOutputType | null
    _min: InstituteStaffMinAggregateOutputType | null
    _max: InstituteStaffMaxAggregateOutputType | null
  }

  type GetInstituteStaffGroupByPayload<T extends InstituteStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteStaffGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteStaffGroupByOutputType[P]>
        }
      >
    >


  export type InstituteStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instituteStaffId?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    oId?: boolean
    status?: boolean
    userGroup?: boolean
    userType?: boolean
  }, ExtArgs["result"]["instituteStaff"]>

  export type InstituteStaffSelectScalar = {
    instituteStaffId?: boolean
    created?: boolean
    details?: boolean
    email?: boolean
    oId?: boolean
    status?: boolean
    userGroup?: boolean
    userType?: boolean
  }


  export type $InstituteStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstituteStaff"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      instituteStaffId: string
      created: string
      details: Prisma.JsonValue
      email: string
      oId: string
      status: string
      userGroup: string
      userType: string
    }, ExtArgs["result"]["instituteStaff"]>
    composites: {}
  }


  type InstituteStaffGetPayload<S extends boolean | null | undefined | InstituteStaffDefaultArgs> = $Result.GetResult<Prisma.$InstituteStaffPayload, S>

  type InstituteStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstituteStaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstituteStaffCountAggregateInputType | true
    }

  export interface InstituteStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstituteStaff'], meta: { name: 'InstituteStaff' } }
    /**
     * Find zero or one InstituteStaff that matches the filter.
     * @param {InstituteStaffFindUniqueArgs} args - Arguments to find a InstituteStaff
     * @example
     * // Get one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstituteStaffFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffFindUniqueArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InstituteStaff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstituteStaffFindUniqueOrThrowArgs} args - Arguments to find a InstituteStaff
     * @example
     * // Get one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstituteStaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InstituteStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffFindFirstArgs} args - Arguments to find a InstituteStaff
     * @example
     * // Get one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstituteStaffFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffFindFirstArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InstituteStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffFindFirstOrThrowArgs} args - Arguments to find a InstituteStaff
     * @example
     * // Get one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstituteStaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InstituteStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstituteStaffs
     * const instituteStaffs = await prisma.instituteStaff.findMany()
     * 
     * // Get first 10 InstituteStaffs
     * const instituteStaffs = await prisma.instituteStaff.findMany({ take: 10 })
     * 
     * // Only select the `instituteStaffId`
     * const instituteStaffWithInstituteStaffIdOnly = await prisma.instituteStaff.findMany({ select: { instituteStaffId: true } })
     * 
    **/
    findMany<T extends InstituteStaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InstituteStaff.
     * @param {InstituteStaffCreateArgs} args - Arguments to create a InstituteStaff.
     * @example
     * // Create one InstituteStaff
     * const InstituteStaff = await prisma.instituteStaff.create({
     *   data: {
     *     // ... data to create a InstituteStaff
     *   }
     * })
     * 
    **/
    create<T extends InstituteStaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffCreateArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InstituteStaffs.
     *     @param {InstituteStaffCreateManyArgs} args - Arguments to create many InstituteStaffs.
     *     @example
     *     // Create many InstituteStaffs
     *     const instituteStaff = await prisma.instituteStaff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstituteStaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InstituteStaff.
     * @param {InstituteStaffDeleteArgs} args - Arguments to delete one InstituteStaff.
     * @example
     * // Delete one InstituteStaff
     * const InstituteStaff = await prisma.instituteStaff.delete({
     *   where: {
     *     // ... filter to delete one InstituteStaff
     *   }
     * })
     * 
    **/
    delete<T extends InstituteStaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffDeleteArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InstituteStaff.
     * @param {InstituteStaffUpdateArgs} args - Arguments to update one InstituteStaff.
     * @example
     * // Update one InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstituteStaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUpdateArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InstituteStaffs.
     * @param {InstituteStaffDeleteManyArgs} args - Arguments to filter InstituteStaffs to delete.
     * @example
     * // Delete a few InstituteStaffs
     * const { count } = await prisma.instituteStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstituteStaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstituteStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstituteStaffs
     * const instituteStaff = await prisma.instituteStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstituteStaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstituteStaff.
     * @param {InstituteStaffUpsertArgs} args - Arguments to update or create a InstituteStaff.
     * @example
     * // Update or create a InstituteStaff
     * const instituteStaff = await prisma.instituteStaff.upsert({
     *   create: {
     *     // ... data to create a InstituteStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstituteStaff we want to update
     *   }
     * })
    **/
    upsert<T extends InstituteStaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStaffUpsertArgs<ExtArgs>>
    ): Prisma__InstituteStaffClient<$Result.GetResult<Prisma.$InstituteStaffPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InstituteStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffCountArgs} args - Arguments to filter InstituteStaffs to count.
     * @example
     * // Count the number of InstituteStaffs
     * const count = await prisma.instituteStaff.count({
     *   where: {
     *     // ... the filter for the InstituteStaffs we want to count
     *   }
     * })
    **/
    count<T extends InstituteStaffCountArgs>(
      args?: Subset<T, InstituteStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstituteStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteStaffAggregateArgs>(args: Subset<T, InstituteStaffAggregateArgs>): Prisma.PrismaPromise<GetInstituteStaffAggregateType<T>>

    /**
     * Group by InstituteStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteStaffGroupByArgs['orderBy'] }
        : { orderBy?: InstituteStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstituteStaff model
   */
  readonly fields: InstituteStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstituteStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InstituteStaff model
   */ 
  interface InstituteStaffFieldRefs {
    readonly instituteStaffId: FieldRef<"InstituteStaff", 'String'>
    readonly created: FieldRef<"InstituteStaff", 'String'>
    readonly details: FieldRef<"InstituteStaff", 'Json'>
    readonly email: FieldRef<"InstituteStaff", 'String'>
    readonly oId: FieldRef<"InstituteStaff", 'String'>
    readonly status: FieldRef<"InstituteStaff", 'String'>
    readonly userGroup: FieldRef<"InstituteStaff", 'String'>
    readonly userType: FieldRef<"InstituteStaff", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InstituteStaff findUnique
   */
  export type InstituteStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStaff to fetch.
     */
    where: InstituteStaffWhereUniqueInput
  }


  /**
   * InstituteStaff findUniqueOrThrow
   */
  export type InstituteStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStaff to fetch.
     */
    where: InstituteStaffWhereUniqueInput
  }


  /**
   * InstituteStaff findFirst
   */
  export type InstituteStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStaff to fetch.
     */
    where?: InstituteStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffs to fetch.
     */
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStaffs.
     */
    cursor?: InstituteStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStaffs.
     */
    distinct?: InstituteStaffScalarFieldEnum | InstituteStaffScalarFieldEnum[]
  }


  /**
   * InstituteStaff findFirstOrThrow
   */
  export type InstituteStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStaff to fetch.
     */
    where?: InstituteStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffs to fetch.
     */
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStaffs.
     */
    cursor?: InstituteStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStaffs.
     */
    distinct?: InstituteStaffScalarFieldEnum | InstituteStaffScalarFieldEnum[]
  }


  /**
   * InstituteStaff findMany
   */
  export type InstituteStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStaffs to fetch.
     */
    where?: InstituteStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStaffs to fetch.
     */
    orderBy?: InstituteStaffOrderByWithRelationInput | InstituteStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstituteStaffs.
     */
    cursor?: InstituteStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStaffs.
     */
    skip?: number
    distinct?: InstituteStaffScalarFieldEnum | InstituteStaffScalarFieldEnum[]
  }


  /**
   * InstituteStaff create
   */
  export type InstituteStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * The data needed to create a InstituteStaff.
     */
    data: XOR<InstituteStaffCreateInput, InstituteStaffUncheckedCreateInput>
  }


  /**
   * InstituteStaff createMany
   */
  export type InstituteStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstituteStaffs.
     */
    data: InstituteStaffCreateManyInput | InstituteStaffCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InstituteStaff update
   */
  export type InstituteStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * The data needed to update a InstituteStaff.
     */
    data: XOR<InstituteStaffUpdateInput, InstituteStaffUncheckedUpdateInput>
    /**
     * Choose, which InstituteStaff to update.
     */
    where: InstituteStaffWhereUniqueInput
  }


  /**
   * InstituteStaff updateMany
   */
  export type InstituteStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstituteStaffs.
     */
    data: XOR<InstituteStaffUpdateManyMutationInput, InstituteStaffUncheckedUpdateManyInput>
    /**
     * Filter which InstituteStaffs to update
     */
    where?: InstituteStaffWhereInput
  }


  /**
   * InstituteStaff upsert
   */
  export type InstituteStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * The filter to search for the InstituteStaff to update in case it exists.
     */
    where: InstituteStaffWhereUniqueInput
    /**
     * In case the InstituteStaff found by the `where` argument doesn't exist, create a new InstituteStaff with this data.
     */
    create: XOR<InstituteStaffCreateInput, InstituteStaffUncheckedCreateInput>
    /**
     * In case the InstituteStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteStaffUpdateInput, InstituteStaffUncheckedUpdateInput>
  }


  /**
   * InstituteStaff delete
   */
  export type InstituteStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
    /**
     * Filter which InstituteStaff to delete.
     */
    where: InstituteStaffWhereUniqueInput
  }


  /**
   * InstituteStaff deleteMany
   */
  export type InstituteStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStaffs to delete
     */
    where?: InstituteStaffWhereInput
  }


  /**
   * InstituteStaff without action
   */
  export type InstituteStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStaff
     */
    select?: InstituteStaffSelect<ExtArgs> | null
  }



  /**
   * Model InstituteStudents
   */

  export type AggregateInstituteStudents = {
    _count: InstituteStudentsCountAggregateOutputType | null
    _avg: InstituteStudentsAvgAggregateOutputType | null
    _sum: InstituteStudentsSumAggregateOutputType | null
    _min: InstituteStudentsMinAggregateOutputType | null
    _max: InstituteStudentsMaxAggregateOutputType | null
  }

  export type InstituteStudentsAvgAggregateOutputType = {
    cohortId: number | null
    oId: number | null
    userGroup: number | null
  }

  export type InstituteStudentsSumAggregateOutputType = {
    cohortId: number | null
    oId: number | null
    userGroup: number | null
  }

  export type InstituteStudentsMinAggregateOutputType = {
    instituteStudentId: string | null
    activated: string | null
    created: string | null
    cohortId: number | null
    email: string | null
    oId: number | null
    resetExpiry: Date | null
    status: string | null
    userGroup: number | null
    userType: string | null
  }

  export type InstituteStudentsMaxAggregateOutputType = {
    instituteStudentId: string | null
    activated: string | null
    created: string | null
    cohortId: number | null
    email: string | null
    oId: number | null
    resetExpiry: Date | null
    status: string | null
    userGroup: number | null
    userType: string | null
  }

  export type InstituteStudentsCountAggregateOutputType = {
    instituteStudentId: number
    activated: number
    created: number
    cohortId: number
    details: number
    email: number
    flags: number
    oId: number
    resetExpiry: number
    status: number
    userGroup: number
    userType: number
    _all: number
  }


  export type InstituteStudentsAvgAggregateInputType = {
    cohortId?: true
    oId?: true
    userGroup?: true
  }

  export type InstituteStudentsSumAggregateInputType = {
    cohortId?: true
    oId?: true
    userGroup?: true
  }

  export type InstituteStudentsMinAggregateInputType = {
    instituteStudentId?: true
    activated?: true
    created?: true
    cohortId?: true
    email?: true
    oId?: true
    resetExpiry?: true
    status?: true
    userGroup?: true
    userType?: true
  }

  export type InstituteStudentsMaxAggregateInputType = {
    instituteStudentId?: true
    activated?: true
    created?: true
    cohortId?: true
    email?: true
    oId?: true
    resetExpiry?: true
    status?: true
    userGroup?: true
    userType?: true
  }

  export type InstituteStudentsCountAggregateInputType = {
    instituteStudentId?: true
    activated?: true
    created?: true
    cohortId?: true
    details?: true
    email?: true
    flags?: true
    oId?: true
    resetExpiry?: true
    status?: true
    userGroup?: true
    userType?: true
    _all?: true
  }

  export type InstituteStudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStudents to aggregate.
     */
    where?: InstituteStudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudents to fetch.
     */
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteStudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstituteStudents
    **/
    _count?: true | InstituteStudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstituteStudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstituteStudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteStudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteStudentsMaxAggregateInputType
  }

  export type GetInstituteStudentsAggregateType<T extends InstituteStudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstituteStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstituteStudents[P]>
      : GetScalarType<T[P], AggregateInstituteStudents[P]>
  }




  export type InstituteStudentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteStudentsWhereInput
    orderBy?: InstituteStudentsOrderByWithAggregationInput | InstituteStudentsOrderByWithAggregationInput[]
    by: InstituteStudentsScalarFieldEnum[] | InstituteStudentsScalarFieldEnum
    having?: InstituteStudentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteStudentsCountAggregateInputType | true
    _avg?: InstituteStudentsAvgAggregateInputType
    _sum?: InstituteStudentsSumAggregateInputType
    _min?: InstituteStudentsMinAggregateInputType
    _max?: InstituteStudentsMaxAggregateInputType
  }

  export type InstituteStudentsGroupByOutputType = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: number
    details: JsonValue
    email: string
    flags: string[]
    oId: number
    resetExpiry: Date
    status: string
    userGroup: number
    userType: string
    _count: InstituteStudentsCountAggregateOutputType | null
    _avg: InstituteStudentsAvgAggregateOutputType | null
    _sum: InstituteStudentsSumAggregateOutputType | null
    _min: InstituteStudentsMinAggregateOutputType | null
    _max: InstituteStudentsMaxAggregateOutputType | null
  }

  type GetInstituteStudentsGroupByPayload<T extends InstituteStudentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteStudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteStudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteStudentsGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteStudentsGroupByOutputType[P]>
        }
      >
    >


  export type InstituteStudentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instituteStudentId?: boolean
    activated?: boolean
    created?: boolean
    cohortId?: boolean
    details?: boolean
    email?: boolean
    flags?: boolean
    oId?: boolean
    resetExpiry?: boolean
    status?: boolean
    userGroup?: boolean
    userType?: boolean
  }, ExtArgs["result"]["instituteStudents"]>

  export type InstituteStudentsSelectScalar = {
    instituteStudentId?: boolean
    activated?: boolean
    created?: boolean
    cohortId?: boolean
    details?: boolean
    email?: boolean
    flags?: boolean
    oId?: boolean
    resetExpiry?: boolean
    status?: boolean
    userGroup?: boolean
    userType?: boolean
  }


  export type $InstituteStudentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstituteStudents"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      instituteStudentId: string
      activated: string
      created: string
      cohortId: number
      details: Prisma.JsonValue
      email: string
      flags: string[]
      oId: number
      resetExpiry: Date
      status: string
      userGroup: number
      userType: string
    }, ExtArgs["result"]["instituteStudents"]>
    composites: {}
  }


  type InstituteStudentsGetPayload<S extends boolean | null | undefined | InstituteStudentsDefaultArgs> = $Result.GetResult<Prisma.$InstituteStudentsPayload, S>

  type InstituteStudentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstituteStudentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstituteStudentsCountAggregateInputType | true
    }

  export interface InstituteStudentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstituteStudents'], meta: { name: 'InstituteStudents' } }
    /**
     * Find zero or one InstituteStudents that matches the filter.
     * @param {InstituteStudentsFindUniqueArgs} args - Arguments to find a InstituteStudents
     * @example
     * // Get one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstituteStudentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsFindUniqueArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InstituteStudents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstituteStudentsFindUniqueOrThrowArgs} args - Arguments to find a InstituteStudents
     * @example
     * // Get one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstituteStudentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InstituteStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsFindFirstArgs} args - Arguments to find a InstituteStudents
     * @example
     * // Get one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstituteStudentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsFindFirstArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InstituteStudents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsFindFirstOrThrowArgs} args - Arguments to find a InstituteStudents
     * @example
     * // Get one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstituteStudentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InstituteStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findMany()
     * 
     * // Get first 10 InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.findMany({ take: 10 })
     * 
     * // Only select the `instituteStudentId`
     * const instituteStudentsWithInstituteStudentIdOnly = await prisma.instituteStudents.findMany({ select: { instituteStudentId: true } })
     * 
    **/
    findMany<T extends InstituteStudentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InstituteStudents.
     * @param {InstituteStudentsCreateArgs} args - Arguments to create a InstituteStudents.
     * @example
     * // Create one InstituteStudents
     * const InstituteStudents = await prisma.instituteStudents.create({
     *   data: {
     *     // ... data to create a InstituteStudents
     *   }
     * })
     * 
    **/
    create<T extends InstituteStudentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsCreateArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InstituteStudents.
     *     @param {InstituteStudentsCreateManyArgs} args - Arguments to create many InstituteStudents.
     *     @example
     *     // Create many InstituteStudents
     *     const instituteStudents = await prisma.instituteStudents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstituteStudentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InstituteStudents.
     * @param {InstituteStudentsDeleteArgs} args - Arguments to delete one InstituteStudents.
     * @example
     * // Delete one InstituteStudents
     * const InstituteStudents = await prisma.instituteStudents.delete({
     *   where: {
     *     // ... filter to delete one InstituteStudents
     *   }
     * })
     * 
    **/
    delete<T extends InstituteStudentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsDeleteArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InstituteStudents.
     * @param {InstituteStudentsUpdateArgs} args - Arguments to update one InstituteStudents.
     * @example
     * // Update one InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstituteStudentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsUpdateArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InstituteStudents.
     * @param {InstituteStudentsDeleteManyArgs} args - Arguments to filter InstituteStudents to delete.
     * @example
     * // Delete a few InstituteStudents
     * const { count } = await prisma.instituteStudents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstituteStudentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstituteStudentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstituteStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstituteStudentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstituteStudents.
     * @param {InstituteStudentsUpsertArgs} args - Arguments to update or create a InstituteStudents.
     * @example
     * // Update or create a InstituteStudents
     * const instituteStudents = await prisma.instituteStudents.upsert({
     *   create: {
     *     // ... data to create a InstituteStudents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstituteStudents we want to update
     *   }
     * })
    **/
    upsert<T extends InstituteStudentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstituteStudentsUpsertArgs<ExtArgs>>
    ): Prisma__InstituteStudentsClient<$Result.GetResult<Prisma.$InstituteStudentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InstituteStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsCountArgs} args - Arguments to filter InstituteStudents to count.
     * @example
     * // Count the number of InstituteStudents
     * const count = await prisma.instituteStudents.count({
     *   where: {
     *     // ... the filter for the InstituteStudents we want to count
     *   }
     * })
    **/
    count<T extends InstituteStudentsCountArgs>(
      args?: Subset<T, InstituteStudentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteStudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstituteStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteStudentsAggregateArgs>(args: Subset<T, InstituteStudentsAggregateArgs>): Prisma.PrismaPromise<GetInstituteStudentsAggregateType<T>>

    /**
     * Group by InstituteStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteStudentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteStudentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteStudentsGroupByArgs['orderBy'] }
        : { orderBy?: InstituteStudentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteStudentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstituteStudents model
   */
  readonly fields: InstituteStudentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstituteStudents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteStudentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InstituteStudents model
   */ 
  interface InstituteStudentsFieldRefs {
    readonly instituteStudentId: FieldRef<"InstituteStudents", 'String'>
    readonly activated: FieldRef<"InstituteStudents", 'String'>
    readonly created: FieldRef<"InstituteStudents", 'String'>
    readonly cohortId: FieldRef<"InstituteStudents", 'Int'>
    readonly details: FieldRef<"InstituteStudents", 'Json'>
    readonly email: FieldRef<"InstituteStudents", 'String'>
    readonly flags: FieldRef<"InstituteStudents", 'String[]'>
    readonly oId: FieldRef<"InstituteStudents", 'Int'>
    readonly resetExpiry: FieldRef<"InstituteStudents", 'DateTime'>
    readonly status: FieldRef<"InstituteStudents", 'String'>
    readonly userGroup: FieldRef<"InstituteStudents", 'Int'>
    readonly userType: FieldRef<"InstituteStudents", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InstituteStudents findUnique
   */
  export type InstituteStudentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where: InstituteStudentsWhereUniqueInput
  }


  /**
   * InstituteStudents findUniqueOrThrow
   */
  export type InstituteStudentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where: InstituteStudentsWhereUniqueInput
  }


  /**
   * InstituteStudents findFirst
   */
  export type InstituteStudentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where?: InstituteStudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudents to fetch.
     */
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStudents.
     */
    cursor?: InstituteStudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStudents.
     */
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * InstituteStudents findFirstOrThrow
   */
  export type InstituteStudentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where?: InstituteStudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudents to fetch.
     */
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstituteStudents.
     */
    cursor?: InstituteStudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstituteStudents.
     */
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * InstituteStudents findMany
   */
  export type InstituteStudentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Filter, which InstituteStudents to fetch.
     */
    where?: InstituteStudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstituteStudents to fetch.
     */
    orderBy?: InstituteStudentsOrderByWithRelationInput | InstituteStudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstituteStudents.
     */
    cursor?: InstituteStudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstituteStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstituteStudents.
     */
    skip?: number
    distinct?: InstituteStudentsScalarFieldEnum | InstituteStudentsScalarFieldEnum[]
  }


  /**
   * InstituteStudents create
   */
  export type InstituteStudentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * The data needed to create a InstituteStudents.
     */
    data: XOR<InstituteStudentsCreateInput, InstituteStudentsUncheckedCreateInput>
  }


  /**
   * InstituteStudents createMany
   */
  export type InstituteStudentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstituteStudents.
     */
    data: InstituteStudentsCreateManyInput | InstituteStudentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InstituteStudents update
   */
  export type InstituteStudentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * The data needed to update a InstituteStudents.
     */
    data: XOR<InstituteStudentsUpdateInput, InstituteStudentsUncheckedUpdateInput>
    /**
     * Choose, which InstituteStudents to update.
     */
    where: InstituteStudentsWhereUniqueInput
  }


  /**
   * InstituteStudents updateMany
   */
  export type InstituteStudentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstituteStudents.
     */
    data: XOR<InstituteStudentsUpdateManyMutationInput, InstituteStudentsUncheckedUpdateManyInput>
    /**
     * Filter which InstituteStudents to update
     */
    where?: InstituteStudentsWhereInput
  }


  /**
   * InstituteStudents upsert
   */
  export type InstituteStudentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * The filter to search for the InstituteStudents to update in case it exists.
     */
    where: InstituteStudentsWhereUniqueInput
    /**
     * In case the InstituteStudents found by the `where` argument doesn't exist, create a new InstituteStudents with this data.
     */
    create: XOR<InstituteStudentsCreateInput, InstituteStudentsUncheckedCreateInput>
    /**
     * In case the InstituteStudents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteStudentsUpdateInput, InstituteStudentsUncheckedUpdateInput>
  }


  /**
   * InstituteStudents delete
   */
  export type InstituteStudentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
    /**
     * Filter which InstituteStudents to delete.
     */
    where: InstituteStudentsWhereUniqueInput
  }


  /**
   * InstituteStudents deleteMany
   */
  export type InstituteStudentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstituteStudents to delete
     */
    where?: InstituteStudentsWhereInput
  }


  /**
   * InstituteStudents without action
   */
  export type InstituteStudentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstituteStudents
     */
    select?: InstituteStudentsSelect<ExtArgs> | null
  }



  /**
   * Model ProviderStaff
   */

  export type AggregateProviderStaff = {
    _count: ProviderStaffCountAggregateOutputType | null
    _avg: ProviderStaffAvgAggregateOutputType | null
    _sum: ProviderStaffSumAggregateOutputType | null
    _min: ProviderStaffMinAggregateOutputType | null
    _max: ProviderStaffMaxAggregateOutputType | null
  }

  export type ProviderStaffAvgAggregateOutputType = {
    cohortId: number | null
  }

  export type ProviderStaffSumAggregateOutputType = {
    cohortId: number | null
  }

  export type ProviderStaffMinAggregateOutputType = {
    providerStaffId: string | null
    created: string | null
    cohortId: number | null
    email: string | null
    oId: string | null
    status: string | null
    userGroup: string | null
    userType: string | null
  }

  export type ProviderStaffMaxAggregateOutputType = {
    providerStaffId: string | null
    created: string | null
    cohortId: number | null
    email: string | null
    oId: string | null
    status: string | null
    userGroup: string | null
    userType: string | null
  }

  export type ProviderStaffCountAggregateOutputType = {
    providerStaffId: number
    created: number
    details: number
    cohortId: number
    email: number
    notes: number
    oId: number
    status: number
    userGroup: number
    userType: number
    _all: number
  }


  export type ProviderStaffAvgAggregateInputType = {
    cohortId?: true
  }

  export type ProviderStaffSumAggregateInputType = {
    cohortId?: true
  }

  export type ProviderStaffMinAggregateInputType = {
    providerStaffId?: true
    created?: true
    cohortId?: true
    email?: true
    oId?: true
    status?: true
    userGroup?: true
    userType?: true
  }

  export type ProviderStaffMaxAggregateInputType = {
    providerStaffId?: true
    created?: true
    cohortId?: true
    email?: true
    oId?: true
    status?: true
    userGroup?: true
    userType?: true
  }

  export type ProviderStaffCountAggregateInputType = {
    providerStaffId?: true
    created?: true
    details?: true
    cohortId?: true
    email?: true
    notes?: true
    oId?: true
    status?: true
    userGroup?: true
    userType?: true
    _all?: true
  }

  export type ProviderStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderStaff to aggregate.
     */
    where?: ProviderStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStaffs to fetch.
     */
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderStaffs
    **/
    _count?: true | ProviderStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderStaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderStaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderStaffMaxAggregateInputType
  }

  export type GetProviderStaffAggregateType<T extends ProviderStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderStaff[P]>
      : GetScalarType<T[P], AggregateProviderStaff[P]>
  }




  export type ProviderStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderStaffWhereInput
    orderBy?: ProviderStaffOrderByWithAggregationInput | ProviderStaffOrderByWithAggregationInput[]
    by: ProviderStaffScalarFieldEnum[] | ProviderStaffScalarFieldEnum
    having?: ProviderStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderStaffCountAggregateInputType | true
    _avg?: ProviderStaffAvgAggregateInputType
    _sum?: ProviderStaffSumAggregateInputType
    _min?: ProviderStaffMinAggregateInputType
    _max?: ProviderStaffMaxAggregateInputType
  }

  export type ProviderStaffGroupByOutputType = {
    providerStaffId: string
    created: string
    details: JsonValue
    cohortId: number
    email: string
    notes: JsonValue
    oId: string
    status: string
    userGroup: string
    userType: string
    _count: ProviderStaffCountAggregateOutputType | null
    _avg: ProviderStaffAvgAggregateOutputType | null
    _sum: ProviderStaffSumAggregateOutputType | null
    _min: ProviderStaffMinAggregateOutputType | null
    _max: ProviderStaffMaxAggregateOutputType | null
  }

  type GetProviderStaffGroupByPayload<T extends ProviderStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderStaffGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderStaffGroupByOutputType[P]>
        }
      >
    >


  export type ProviderStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    providerStaffId?: boolean
    created?: boolean
    details?: boolean
    cohortId?: boolean
    email?: boolean
    notes?: boolean
    oId?: boolean
    status?: boolean
    userGroup?: boolean
    userType?: boolean
  }, ExtArgs["result"]["providerStaff"]>

  export type ProviderStaffSelectScalar = {
    providerStaffId?: boolean
    created?: boolean
    details?: boolean
    cohortId?: boolean
    email?: boolean
    notes?: boolean
    oId?: boolean
    status?: boolean
    userGroup?: boolean
    userType?: boolean
  }


  export type $ProviderStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderStaff"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      providerStaffId: string
      created: string
      details: Prisma.JsonValue
      cohortId: number
      email: string
      notes: Prisma.JsonValue
      oId: string
      status: string
      userGroup: string
      userType: string
    }, ExtArgs["result"]["providerStaff"]>
    composites: {}
  }


  type ProviderStaffGetPayload<S extends boolean | null | undefined | ProviderStaffDefaultArgs> = $Result.GetResult<Prisma.$ProviderStaffPayload, S>

  type ProviderStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProviderStaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProviderStaffCountAggregateInputType | true
    }

  export interface ProviderStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderStaff'], meta: { name: 'ProviderStaff' } }
    /**
     * Find zero or one ProviderStaff that matches the filter.
     * @param {ProviderStaffFindUniqueArgs} args - Arguments to find a ProviderStaff
     * @example
     * // Get one ProviderStaff
     * const providerStaff = await prisma.providerStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderStaffFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffFindUniqueArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProviderStaff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProviderStaffFindUniqueOrThrowArgs} args - Arguments to find a ProviderStaff
     * @example
     * // Get one ProviderStaff
     * const providerStaff = await prisma.providerStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProviderStaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProviderStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffFindFirstArgs} args - Arguments to find a ProviderStaff
     * @example
     * // Get one ProviderStaff
     * const providerStaff = await prisma.providerStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderStaffFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffFindFirstArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProviderStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffFindFirstOrThrowArgs} args - Arguments to find a ProviderStaff
     * @example
     * // Get one ProviderStaff
     * const providerStaff = await prisma.providerStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProviderStaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProviderStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderStaffs
     * const providerStaffs = await prisma.providerStaff.findMany()
     * 
     * // Get first 10 ProviderStaffs
     * const providerStaffs = await prisma.providerStaff.findMany({ take: 10 })
     * 
     * // Only select the `providerStaffId`
     * const providerStaffWithProviderStaffIdOnly = await prisma.providerStaff.findMany({ select: { providerStaffId: true } })
     * 
    **/
    findMany<T extends ProviderStaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProviderStaff.
     * @param {ProviderStaffCreateArgs} args - Arguments to create a ProviderStaff.
     * @example
     * // Create one ProviderStaff
     * const ProviderStaff = await prisma.providerStaff.create({
     *   data: {
     *     // ... data to create a ProviderStaff
     *   }
     * })
     * 
    **/
    create<T extends ProviderStaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffCreateArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProviderStaffs.
     *     @param {ProviderStaffCreateManyArgs} args - Arguments to create many ProviderStaffs.
     *     @example
     *     // Create many ProviderStaffs
     *     const providerStaff = await prisma.providerStaff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProviderStaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProviderStaff.
     * @param {ProviderStaffDeleteArgs} args - Arguments to delete one ProviderStaff.
     * @example
     * // Delete one ProviderStaff
     * const ProviderStaff = await prisma.providerStaff.delete({
     *   where: {
     *     // ... filter to delete one ProviderStaff
     *   }
     * })
     * 
    **/
    delete<T extends ProviderStaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffDeleteArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProviderStaff.
     * @param {ProviderStaffUpdateArgs} args - Arguments to update one ProviderStaff.
     * @example
     * // Update one ProviderStaff
     * const providerStaff = await prisma.providerStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderStaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffUpdateArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProviderStaffs.
     * @param {ProviderStaffDeleteManyArgs} args - Arguments to filter ProviderStaffs to delete.
     * @example
     * // Delete a few ProviderStaffs
     * const { count } = await prisma.providerStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderStaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderStaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderStaffs
     * const providerStaff = await prisma.providerStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderStaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProviderStaff.
     * @param {ProviderStaffUpsertArgs} args - Arguments to update or create a ProviderStaff.
     * @example
     * // Update or create a ProviderStaff
     * const providerStaff = await prisma.providerStaff.upsert({
     *   create: {
     *     // ... data to create a ProviderStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderStaff we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderStaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderStaffUpsertArgs<ExtArgs>>
    ): Prisma__ProviderStaffClient<$Result.GetResult<Prisma.$ProviderStaffPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProviderStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffCountArgs} args - Arguments to filter ProviderStaffs to count.
     * @example
     * // Count the number of ProviderStaffs
     * const count = await prisma.providerStaff.count({
     *   where: {
     *     // ... the filter for the ProviderStaffs we want to count
     *   }
     * })
    **/
    count<T extends ProviderStaffCountArgs>(
      args?: Subset<T, ProviderStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderStaffAggregateArgs>(args: Subset<T, ProviderStaffAggregateArgs>): Prisma.PrismaPromise<GetProviderStaffAggregateType<T>>

    /**
     * Group by ProviderStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderStaffGroupByArgs['orderBy'] }
        : { orderBy?: ProviderStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderStaff model
   */
  readonly fields: ProviderStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProviderStaff model
   */ 
  interface ProviderStaffFieldRefs {
    readonly providerStaffId: FieldRef<"ProviderStaff", 'String'>
    readonly created: FieldRef<"ProviderStaff", 'String'>
    readonly details: FieldRef<"ProviderStaff", 'Json'>
    readonly cohortId: FieldRef<"ProviderStaff", 'Int'>
    readonly email: FieldRef<"ProviderStaff", 'String'>
    readonly notes: FieldRef<"ProviderStaff", 'Json'>
    readonly oId: FieldRef<"ProviderStaff", 'String'>
    readonly status: FieldRef<"ProviderStaff", 'String'>
    readonly userGroup: FieldRef<"ProviderStaff", 'String'>
    readonly userType: FieldRef<"ProviderStaff", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ProviderStaff findUnique
   */
  export type ProviderStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Filter, which ProviderStaff to fetch.
     */
    where: ProviderStaffWhereUniqueInput
  }


  /**
   * ProviderStaff findUniqueOrThrow
   */
  export type ProviderStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Filter, which ProviderStaff to fetch.
     */
    where: ProviderStaffWhereUniqueInput
  }


  /**
   * ProviderStaff findFirst
   */
  export type ProviderStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Filter, which ProviderStaff to fetch.
     */
    where?: ProviderStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStaffs to fetch.
     */
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderStaffs.
     */
    cursor?: ProviderStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderStaffs.
     */
    distinct?: ProviderStaffScalarFieldEnum | ProviderStaffScalarFieldEnum[]
  }


  /**
   * ProviderStaff findFirstOrThrow
   */
  export type ProviderStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Filter, which ProviderStaff to fetch.
     */
    where?: ProviderStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStaffs to fetch.
     */
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderStaffs.
     */
    cursor?: ProviderStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderStaffs.
     */
    distinct?: ProviderStaffScalarFieldEnum | ProviderStaffScalarFieldEnum[]
  }


  /**
   * ProviderStaff findMany
   */
  export type ProviderStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Filter, which ProviderStaffs to fetch.
     */
    where?: ProviderStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStaffs to fetch.
     */
    orderBy?: ProviderStaffOrderByWithRelationInput | ProviderStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderStaffs.
     */
    cursor?: ProviderStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStaffs.
     */
    skip?: number
    distinct?: ProviderStaffScalarFieldEnum | ProviderStaffScalarFieldEnum[]
  }


  /**
   * ProviderStaff create
   */
  export type ProviderStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * The data needed to create a ProviderStaff.
     */
    data: XOR<ProviderStaffCreateInput, ProviderStaffUncheckedCreateInput>
  }


  /**
   * ProviderStaff createMany
   */
  export type ProviderStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderStaffs.
     */
    data: ProviderStaffCreateManyInput | ProviderStaffCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProviderStaff update
   */
  export type ProviderStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * The data needed to update a ProviderStaff.
     */
    data: XOR<ProviderStaffUpdateInput, ProviderStaffUncheckedUpdateInput>
    /**
     * Choose, which ProviderStaff to update.
     */
    where: ProviderStaffWhereUniqueInput
  }


  /**
   * ProviderStaff updateMany
   */
  export type ProviderStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderStaffs.
     */
    data: XOR<ProviderStaffUpdateManyMutationInput, ProviderStaffUncheckedUpdateManyInput>
    /**
     * Filter which ProviderStaffs to update
     */
    where?: ProviderStaffWhereInput
  }


  /**
   * ProviderStaff upsert
   */
  export type ProviderStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * The filter to search for the ProviderStaff to update in case it exists.
     */
    where: ProviderStaffWhereUniqueInput
    /**
     * In case the ProviderStaff found by the `where` argument doesn't exist, create a new ProviderStaff with this data.
     */
    create: XOR<ProviderStaffCreateInput, ProviderStaffUncheckedCreateInput>
    /**
     * In case the ProviderStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderStaffUpdateInput, ProviderStaffUncheckedUpdateInput>
  }


  /**
   * ProviderStaff delete
   */
  export type ProviderStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
    /**
     * Filter which ProviderStaff to delete.
     */
    where: ProviderStaffWhereUniqueInput
  }


  /**
   * ProviderStaff deleteMany
   */
  export type ProviderStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderStaffs to delete
     */
    where?: ProviderStaffWhereInput
  }


  /**
   * ProviderStaff without action
   */
  export type ProviderStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStaff
     */
    select?: ProviderStaffSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AddressesScalarFieldEnum: {
    addressId: 'addressId',
    address_line1: 'address_line1',
    address_line2: 'address_line2',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    country: 'country',
    email: 'email',
    geoHash: 'geoHash',
    locality: 'locality',
    oId: 'oId',
    product: 'product',
    phone: 'phone',
    postal_code: 'postal_code'
  };

  export type AddressesScalarFieldEnum = (typeof AddressesScalarFieldEnum)[keyof typeof AddressesScalarFieldEnum]


  export const BlogsScalarFieldEnum: {
    blogId: 'blogId',
    author: 'author',
    category: 'category',
    summary: 'summary',
    tags: 'tags',
    title: 'title',
    uploaded: 'uploaded',
    body: 'body'
  };

  export type BlogsScalarFieldEnum = (typeof BlogsScalarFieldEnum)[keyof typeof BlogsScalarFieldEnum]


  export const BugReportsScalarFieldEnum: {
    bugReportId: 'bugReportId',
    bug: 'bug',
    date: 'date',
    description: 'description',
    severity: 'severity',
    status: 'status',
    uid: 'uid'
  };

  export type BugReportsScalarFieldEnum = (typeof BugReportsScalarFieldEnum)[keyof typeof BugReportsScalarFieldEnum]


  export const BusinessInterestScalarFieldEnum: {
    businessInterestId: 'businessInterestId',
    email: 'email',
    forename: 'forename',
    surname: 'surname',
    sector: 'sector',
    subsector: 'subsector'
  };

  export type BusinessInterestScalarFieldEnum = (typeof BusinessInterestScalarFieldEnum)[keyof typeof BusinessInterestScalarFieldEnum]


  export const CohortsScalarFieldEnum: {
    cohortId: 'cohortId',
    designatedStaff: 'designatedStaff',
    oId: 'oId',
    product: 'product',
    stage: 'stage',
    placementType: 'placementType',
    name: 'name',
    startPlacements: 'startPlacements',
    endPlacements: 'endPlacements',
    startSubmission: 'startSubmission',
    endSubmission: 'endSubmission',
    includedFiles: 'includedFiles',
    includedForms: 'includedForms',
    workflow: 'workflow'
  };

  export type CohortsScalarFieldEnum = (typeof CohortsScalarFieldEnum)[keyof typeof CohortsScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    contactId: 'contactId',
    address_line1: 'address_line1',
    address_line2: 'address_line2',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    country: 'country',
    created: 'created',
    locality: 'locality',
    name: 'name',
    providerEmail: 'providerEmail',
    providerPhone: 'providerPhone',
    postal_code: 'postal_code',
    uid: 'uid'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const DowntimeScalarFieldEnum: {
    downtimeId: 'downtimeId',
    active: 'active',
    body: 'body',
    products: 'products',
    title: 'title'
  };

  export type DowntimeScalarFieldEnum = (typeof DowntimeScalarFieldEnum)[keyof typeof DowntimeScalarFieldEnum]


  export const FeatureRequestsScalarFieldEnum: {
    featureRequestId: 'featureRequestId',
    date: 'date',
    description: 'description',
    feature: 'feature',
    impact: 'impact',
    uid: 'uid'
  };

  export type FeatureRequestsScalarFieldEnum = (typeof FeatureRequestsScalarFieldEnum)[keyof typeof FeatureRequestsScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    feedbackId: 'feedbackId',
    created: 'created',
    msg: 'msg',
    title: 'title',
    uid: 'uid'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const FormsScalarFieldEnum: {
    formId: 'formId',
    form: 'form',
    oId: 'oId',
    product: 'product',
    updated: 'updated'
  };

  export type FormsScalarFieldEnum = (typeof FormsScalarFieldEnum)[keyof typeof FormsScalarFieldEnum]


  export const InstitutesScalarFieldEnum: {
    instituteId: 'instituteId',
    address_line1: 'address_line1',
    address_line2: 'address_line2',
    admin: 'admin',
    country: 'country',
    externalProviderUploads: 'externalProviderUploads',
    geoHash: 'geoHash',
    locality: 'locality',
    name: 'name',
    postal_code: 'postal_code',
    referral: 'referral',
    status: 'status',
    studentsFields: 'studentsFields',
    staff: 'staff',
    staffActive: 'staffActive',
    students: 'students',
    studentsActive: 'studentsActive',
    staffFields: 'staffFields',
    staffGuidance: 'staffGuidance',
    studentsGuidance: 'studentsGuidance',
    verifiedProviders: 'verifiedProviders'
  };

  export type InstitutesScalarFieldEnum = (typeof InstitutesScalarFieldEnum)[keyof typeof InstitutesScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    jobId: 'jobId',
    started: 'started',
    updated: 'updated',
    finished: 'finished',
    title: 'title',
    description: 'description',
    status: 'status',
    logs: 'logs',
    outputMsg: 'outputMsg',
    viewedBy: 'viewedBy',
    oId: 'oId',
    product: 'product'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const LogsScalarFieldEnum: {
    logId: 'logId',
    oId: 'oId',
    provider: 'provider',
    students: 'students',
    staff: 'staff',
    uid: 'uid'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const PlacementListingsScalarFieldEnum: {
    placementListingId: 'placementListingId',
    addressId: 'addressId',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    created: 'created',
    mapConsent: 'mapConsent',
    mapConsentDate: 'mapConsentDate',
    providerEmail: 'providerEmail',
    providerId: 'providerId',
    providerPhone: 'providerPhone',
    savedBy: 'savedBy',
    questions: 'questions',
    title: 'title',
    uploadedBy: 'uploadedBy'
  };

  export type PlacementListingsScalarFieldEnum = (typeof PlacementListingsScalarFieldEnum)[keyof typeof PlacementListingsScalarFieldEnum]


  export const PlacementsScalarFieldEnum: {
    placementId: 'placementId',
    activeDates: 'activeDates',
    address_line1: 'address_line1',
    address_line2: 'address_line2',
    cohortId: 'cohortId',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    country: 'country',
    created: 'created',
    draft: 'draft',
    endDate: 'endDate',
    flags: 'flags',
    geoHash: 'geoHash',
    inProgress: 'inProgress',
    leadTimes: 'leadTimes',
    locality: 'locality',
    name: 'name',
    oId: 'oId',
    parentEmailed: 'parentEmailed',
    parentExpiry: 'parentExpiry',
    parentKey: 'parentKey',
    postal_code: 'postal_code',
    product: 'product',
    providerEmail: 'providerEmail',
    providerEmailed: 'providerEmailed',
    providerExpiry: 'providerExpiry',
    providerKey: 'providerKey',
    providerName: 'providerName',
    providerPhone: 'providerPhone',
    nextStatus: 'nextStatus',
    status: 'status',
    startDate: 'startDate',
    title: 'title',
    uid: 'uid',
    forms: 'forms',
    questions: 'questions',
    uploadedBy: 'uploadedBy',
    userGroup: 'userGroup'
  };

  export type PlacementsScalarFieldEnum = (typeof PlacementsScalarFieldEnum)[keyof typeof PlacementsScalarFieldEnum]


  export const ProvidersScalarFieldEnum: {
    providerId: 'providerId',
    contactForename: 'contactForename',
    contactSurname: 'contactSurname',
    defAddress: 'defAddress',
    email: 'email',
    mapConsent: 'mapConsent',
    insurance: 'insurance',
    mapConsentDate: 'mapConsentDate',
    name: 'name',
    phone: 'phone',
    rememberConsent: 'rememberConsent',
    rememberConsentDate: 'rememberConsentDate',
    savedBy: 'savedBy',
    sector: 'sector',
    subsector: 'subsector',
    uploadedBy: 'uploadedBy',
    website: 'website'
  };

  export type ProvidersScalarFieldEnum = (typeof ProvidersScalarFieldEnum)[keyof typeof ProvidersScalarFieldEnum]


  export const ReferralsScalarFieldEnum: {
    referralId: 'referralId',
    expiry: 'expiry',
    name: 'name',
    product: 'product',
    signUps: 'signUps',
    volume: 'volume'
  };

  export type ReferralsScalarFieldEnum = (typeof ReferralsScalarFieldEnum)[keyof typeof ReferralsScalarFieldEnum]


  export const UserGroupsScalarFieldEnum: {
    userGroupId: 'userGroupId',
    default: 'default',
    name: 'name',
    oId: 'oId',
    product: 'product',
    template: 'template',
    updated: 'updated'
  };

  export type UserGroupsScalarFieldEnum = (typeof UserGroupsScalarFieldEnum)[keyof typeof UserGroupsScalarFieldEnum]


  export const StudentUsersScalarFieldEnum: {
    studentUserId: 'studentUserId',
    status: 'status',
    analytics: 'analytics',
    created: 'created',
    details: 'details',
    email: 'email',
    referral: 'referral',
    units: 'units',
    userType: 'userType'
  };

  export type StudentUsersScalarFieldEnum = (typeof StudentUsersScalarFieldEnum)[keyof typeof StudentUsersScalarFieldEnum]


  export const InstituteStaffScalarFieldEnum: {
    instituteStaffId: 'instituteStaffId',
    created: 'created',
    details: 'details',
    email: 'email',
    oId: 'oId',
    status: 'status',
    userGroup: 'userGroup',
    userType: 'userType'
  };

  export type InstituteStaffScalarFieldEnum = (typeof InstituteStaffScalarFieldEnum)[keyof typeof InstituteStaffScalarFieldEnum]


  export const InstituteStudentsScalarFieldEnum: {
    instituteStudentId: 'instituteStudentId',
    activated: 'activated',
    created: 'created',
    cohortId: 'cohortId',
    details: 'details',
    email: 'email',
    flags: 'flags',
    oId: 'oId',
    resetExpiry: 'resetExpiry',
    status: 'status',
    userGroup: 'userGroup',
    userType: 'userType'
  };

  export type InstituteStudentsScalarFieldEnum = (typeof InstituteStudentsScalarFieldEnum)[keyof typeof InstituteStudentsScalarFieldEnum]


  export const ProviderStaffScalarFieldEnum: {
    providerStaffId: 'providerStaffId',
    created: 'created',
    details: 'details',
    cohortId: 'cohortId',
    email: 'email',
    notes: 'notes',
    oId: 'oId',
    status: 'status',
    userGroup: 'userGroup',
    userType: 'userType'
  };

  export type ProviderStaffScalarFieldEnum = (typeof ProviderStaffScalarFieldEnum)[keyof typeof ProviderStaffScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AddressesWhereInput = {
    AND?: AddressesWhereInput | AddressesWhereInput[]
    OR?: AddressesWhereInput[]
    NOT?: AddressesWhereInput | AddressesWhereInput[]
    addressId?: IntFilter<"Addresses"> | number
    address_line1?: StringFilter<"Addresses"> | string
    address_line2?: StringFilter<"Addresses"> | string
    contactForename?: StringFilter<"Addresses"> | string
    contactSurname?: StringFilter<"Addresses"> | string
    country?: StringFilter<"Addresses"> | string
    email?: StringFilter<"Addresses"> | string
    geoHash?: StringFilter<"Addresses"> | string
    locality?: StringFilter<"Addresses"> | string
    oId?: IntFilter<"Addresses"> | number
    product?: StringFilter<"Addresses"> | string
    phone?: StringFilter<"Addresses"> | string
    postal_code?: StringFilter<"Addresses"> | string
  }

  export type AddressesOrderByWithRelationInput = {
    addressId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    email?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    phone?: SortOrder
    postal_code?: SortOrder
  }

  export type AddressesWhereUniqueInput = Prisma.AtLeast<{
    addressId?: number
    AND?: AddressesWhereInput | AddressesWhereInput[]
    OR?: AddressesWhereInput[]
    NOT?: AddressesWhereInput | AddressesWhereInput[]
    address_line1?: StringFilter<"Addresses"> | string
    address_line2?: StringFilter<"Addresses"> | string
    contactForename?: StringFilter<"Addresses"> | string
    contactSurname?: StringFilter<"Addresses"> | string
    country?: StringFilter<"Addresses"> | string
    email?: StringFilter<"Addresses"> | string
    geoHash?: StringFilter<"Addresses"> | string
    locality?: StringFilter<"Addresses"> | string
    oId?: IntFilter<"Addresses"> | number
    product?: StringFilter<"Addresses"> | string
    phone?: StringFilter<"Addresses"> | string
    postal_code?: StringFilter<"Addresses"> | string
  }, "addressId">

  export type AddressesOrderByWithAggregationInput = {
    addressId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    email?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    phone?: SortOrder
    postal_code?: SortOrder
    _count?: AddressesCountOrderByAggregateInput
    _avg?: AddressesAvgOrderByAggregateInput
    _max?: AddressesMaxOrderByAggregateInput
    _min?: AddressesMinOrderByAggregateInput
    _sum?: AddressesSumOrderByAggregateInput
  }

  export type AddressesScalarWhereWithAggregatesInput = {
    AND?: AddressesScalarWhereWithAggregatesInput | AddressesScalarWhereWithAggregatesInput[]
    OR?: AddressesScalarWhereWithAggregatesInput[]
    NOT?: AddressesScalarWhereWithAggregatesInput | AddressesScalarWhereWithAggregatesInput[]
    addressId?: IntWithAggregatesFilter<"Addresses"> | number
    address_line1?: StringWithAggregatesFilter<"Addresses"> | string
    address_line2?: StringWithAggregatesFilter<"Addresses"> | string
    contactForename?: StringWithAggregatesFilter<"Addresses"> | string
    contactSurname?: StringWithAggregatesFilter<"Addresses"> | string
    country?: StringWithAggregatesFilter<"Addresses"> | string
    email?: StringWithAggregatesFilter<"Addresses"> | string
    geoHash?: StringWithAggregatesFilter<"Addresses"> | string
    locality?: StringWithAggregatesFilter<"Addresses"> | string
    oId?: IntWithAggregatesFilter<"Addresses"> | number
    product?: StringWithAggregatesFilter<"Addresses"> | string
    phone?: StringWithAggregatesFilter<"Addresses"> | string
    postal_code?: StringWithAggregatesFilter<"Addresses"> | string
  }

  export type BlogsWhereInput = {
    AND?: BlogsWhereInput | BlogsWhereInput[]
    OR?: BlogsWhereInput[]
    NOT?: BlogsWhereInput | BlogsWhereInput[]
    blogId?: IntFilter<"Blogs"> | number
    author?: StringFilter<"Blogs"> | string
    category?: StringFilter<"Blogs"> | string
    summary?: StringFilter<"Blogs"> | string
    tags?: StringFilter<"Blogs"> | string
    title?: StringFilter<"Blogs"> | string
    uploaded?: StringFilter<"Blogs"> | string
    body?: JsonFilter<"Blogs">
  }

  export type BlogsOrderByWithRelationInput = {
    blogId?: SortOrder
    author?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    tags?: SortOrder
    title?: SortOrder
    uploaded?: SortOrder
    body?: SortOrder
  }

  export type BlogsWhereUniqueInput = Prisma.AtLeast<{
    blogId?: number
    AND?: BlogsWhereInput | BlogsWhereInput[]
    OR?: BlogsWhereInput[]
    NOT?: BlogsWhereInput | BlogsWhereInput[]
    author?: StringFilter<"Blogs"> | string
    category?: StringFilter<"Blogs"> | string
    summary?: StringFilter<"Blogs"> | string
    tags?: StringFilter<"Blogs"> | string
    title?: StringFilter<"Blogs"> | string
    uploaded?: StringFilter<"Blogs"> | string
    body?: JsonFilter<"Blogs">
  }, "blogId">

  export type BlogsOrderByWithAggregationInput = {
    blogId?: SortOrder
    author?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    tags?: SortOrder
    title?: SortOrder
    uploaded?: SortOrder
    body?: SortOrder
    _count?: BlogsCountOrderByAggregateInput
    _avg?: BlogsAvgOrderByAggregateInput
    _max?: BlogsMaxOrderByAggregateInput
    _min?: BlogsMinOrderByAggregateInput
    _sum?: BlogsSumOrderByAggregateInput
  }

  export type BlogsScalarWhereWithAggregatesInput = {
    AND?: BlogsScalarWhereWithAggregatesInput | BlogsScalarWhereWithAggregatesInput[]
    OR?: BlogsScalarWhereWithAggregatesInput[]
    NOT?: BlogsScalarWhereWithAggregatesInput | BlogsScalarWhereWithAggregatesInput[]
    blogId?: IntWithAggregatesFilter<"Blogs"> | number
    author?: StringWithAggregatesFilter<"Blogs"> | string
    category?: StringWithAggregatesFilter<"Blogs"> | string
    summary?: StringWithAggregatesFilter<"Blogs"> | string
    tags?: StringWithAggregatesFilter<"Blogs"> | string
    title?: StringWithAggregatesFilter<"Blogs"> | string
    uploaded?: StringWithAggregatesFilter<"Blogs"> | string
    body?: JsonWithAggregatesFilter<"Blogs">
  }

  export type BugReportsWhereInput = {
    AND?: BugReportsWhereInput | BugReportsWhereInput[]
    OR?: BugReportsWhereInput[]
    NOT?: BugReportsWhereInput | BugReportsWhereInput[]
    bugReportId?: IntFilter<"BugReports"> | number
    bug?: StringFilter<"BugReports"> | string
    date?: DateTimeFilter<"BugReports"> | Date | string
    description?: StringFilter<"BugReports"> | string
    severity?: StringFilter<"BugReports"> | string
    status?: StringFilter<"BugReports"> | string
    uid?: StringFilter<"BugReports"> | string
  }

  export type BugReportsOrderByWithRelationInput = {
    bugReportId?: SortOrder
    bug?: SortOrder
    date?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    uid?: SortOrder
  }

  export type BugReportsWhereUniqueInput = Prisma.AtLeast<{
    bugReportId?: number
    AND?: BugReportsWhereInput | BugReportsWhereInput[]
    OR?: BugReportsWhereInput[]
    NOT?: BugReportsWhereInput | BugReportsWhereInput[]
    bug?: StringFilter<"BugReports"> | string
    date?: DateTimeFilter<"BugReports"> | Date | string
    description?: StringFilter<"BugReports"> | string
    severity?: StringFilter<"BugReports"> | string
    status?: StringFilter<"BugReports"> | string
    uid?: StringFilter<"BugReports"> | string
  }, "bugReportId">

  export type BugReportsOrderByWithAggregationInput = {
    bugReportId?: SortOrder
    bug?: SortOrder
    date?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    uid?: SortOrder
    _count?: BugReportsCountOrderByAggregateInput
    _avg?: BugReportsAvgOrderByAggregateInput
    _max?: BugReportsMaxOrderByAggregateInput
    _min?: BugReportsMinOrderByAggregateInput
    _sum?: BugReportsSumOrderByAggregateInput
  }

  export type BugReportsScalarWhereWithAggregatesInput = {
    AND?: BugReportsScalarWhereWithAggregatesInput | BugReportsScalarWhereWithAggregatesInput[]
    OR?: BugReportsScalarWhereWithAggregatesInput[]
    NOT?: BugReportsScalarWhereWithAggregatesInput | BugReportsScalarWhereWithAggregatesInput[]
    bugReportId?: IntWithAggregatesFilter<"BugReports"> | number
    bug?: StringWithAggregatesFilter<"BugReports"> | string
    date?: DateTimeWithAggregatesFilter<"BugReports"> | Date | string
    description?: StringWithAggregatesFilter<"BugReports"> | string
    severity?: StringWithAggregatesFilter<"BugReports"> | string
    status?: StringWithAggregatesFilter<"BugReports"> | string
    uid?: StringWithAggregatesFilter<"BugReports"> | string
  }

  export type BusinessInterestWhereInput = {
    AND?: BusinessInterestWhereInput | BusinessInterestWhereInput[]
    OR?: BusinessInterestWhereInput[]
    NOT?: BusinessInterestWhereInput | BusinessInterestWhereInput[]
    businessInterestId?: IntFilter<"BusinessInterest"> | number
    email?: StringFilter<"BusinessInterest"> | string
    forename?: StringFilter<"BusinessInterest"> | string
    surname?: StringFilter<"BusinessInterest"> | string
    sector?: StringNullableFilter<"BusinessInterest"> | string | null
    subsector?: StringNullableFilter<"BusinessInterest"> | string | null
  }

  export type BusinessInterestOrderByWithRelationInput = {
    businessInterestId?: SortOrder
    email?: SortOrder
    forename?: SortOrder
    surname?: SortOrder
    sector?: SortOrderInput | SortOrder
    subsector?: SortOrderInput | SortOrder
  }

  export type BusinessInterestWhereUniqueInput = Prisma.AtLeast<{
    businessInterestId?: number
    AND?: BusinessInterestWhereInput | BusinessInterestWhereInput[]
    OR?: BusinessInterestWhereInput[]
    NOT?: BusinessInterestWhereInput | BusinessInterestWhereInput[]
    email?: StringFilter<"BusinessInterest"> | string
    forename?: StringFilter<"BusinessInterest"> | string
    surname?: StringFilter<"BusinessInterest"> | string
    sector?: StringNullableFilter<"BusinessInterest"> | string | null
    subsector?: StringNullableFilter<"BusinessInterest"> | string | null
  }, "businessInterestId">

  export type BusinessInterestOrderByWithAggregationInput = {
    businessInterestId?: SortOrder
    email?: SortOrder
    forename?: SortOrder
    surname?: SortOrder
    sector?: SortOrderInput | SortOrder
    subsector?: SortOrderInput | SortOrder
    _count?: BusinessInterestCountOrderByAggregateInput
    _avg?: BusinessInterestAvgOrderByAggregateInput
    _max?: BusinessInterestMaxOrderByAggregateInput
    _min?: BusinessInterestMinOrderByAggregateInput
    _sum?: BusinessInterestSumOrderByAggregateInput
  }

  export type BusinessInterestScalarWhereWithAggregatesInput = {
    AND?: BusinessInterestScalarWhereWithAggregatesInput | BusinessInterestScalarWhereWithAggregatesInput[]
    OR?: BusinessInterestScalarWhereWithAggregatesInput[]
    NOT?: BusinessInterestScalarWhereWithAggregatesInput | BusinessInterestScalarWhereWithAggregatesInput[]
    businessInterestId?: IntWithAggregatesFilter<"BusinessInterest"> | number
    email?: StringWithAggregatesFilter<"BusinessInterest"> | string
    forename?: StringWithAggregatesFilter<"BusinessInterest"> | string
    surname?: StringWithAggregatesFilter<"BusinessInterest"> | string
    sector?: StringNullableWithAggregatesFilter<"BusinessInterest"> | string | null
    subsector?: StringNullableWithAggregatesFilter<"BusinessInterest"> | string | null
  }

  export type CohortsWhereInput = {
    AND?: CohortsWhereInput | CohortsWhereInput[]
    OR?: CohortsWhereInput[]
    NOT?: CohortsWhereInput | CohortsWhereInput[]
    cohortId?: IntFilter<"Cohorts"> | number
    designatedStaff?: StringFilter<"Cohorts"> | string
    oId?: IntFilter<"Cohorts"> | number
    product?: StringFilter<"Cohorts"> | string
    stage?: StringFilter<"Cohorts"> | string
    placementType?: StringFilter<"Cohorts"> | string
    name?: StringFilter<"Cohorts"> | string
    startPlacements?: StringFilter<"Cohorts"> | string
    endPlacements?: StringFilter<"Cohorts"> | string
    startSubmission?: StringFilter<"Cohorts"> | string
    endSubmission?: StringFilter<"Cohorts"> | string
    includedFiles?: StringNullableListFilter<"Cohorts">
    includedForms?: StringNullableListFilter<"Cohorts">
    workflow?: StringFilter<"Cohorts"> | string
  }

  export type CohortsOrderByWithRelationInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    includedFiles?: SortOrder
    includedForms?: SortOrder
    workflow?: SortOrder
  }

  export type CohortsWhereUniqueInput = Prisma.AtLeast<{
    cohortId?: number
    designatedStaff?: string
    oId?: number
    AND?: CohortsWhereInput | CohortsWhereInput[]
    OR?: CohortsWhereInput[]
    NOT?: CohortsWhereInput | CohortsWhereInput[]
    product?: StringFilter<"Cohorts"> | string
    stage?: StringFilter<"Cohorts"> | string
    placementType?: StringFilter<"Cohorts"> | string
    name?: StringFilter<"Cohorts"> | string
    startPlacements?: StringFilter<"Cohorts"> | string
    endPlacements?: StringFilter<"Cohorts"> | string
    startSubmission?: StringFilter<"Cohorts"> | string
    endSubmission?: StringFilter<"Cohorts"> | string
    includedFiles?: StringNullableListFilter<"Cohorts">
    includedForms?: StringNullableListFilter<"Cohorts">
    workflow?: StringFilter<"Cohorts"> | string
  }, "cohortId" | "designatedStaff" | "oId">

  export type CohortsOrderByWithAggregationInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    includedFiles?: SortOrder
    includedForms?: SortOrder
    workflow?: SortOrder
    _count?: CohortsCountOrderByAggregateInput
    _avg?: CohortsAvgOrderByAggregateInput
    _max?: CohortsMaxOrderByAggregateInput
    _min?: CohortsMinOrderByAggregateInput
    _sum?: CohortsSumOrderByAggregateInput
  }

  export type CohortsScalarWhereWithAggregatesInput = {
    AND?: CohortsScalarWhereWithAggregatesInput | CohortsScalarWhereWithAggregatesInput[]
    OR?: CohortsScalarWhereWithAggregatesInput[]
    NOT?: CohortsScalarWhereWithAggregatesInput | CohortsScalarWhereWithAggregatesInput[]
    cohortId?: IntWithAggregatesFilter<"Cohorts"> | number
    designatedStaff?: StringWithAggregatesFilter<"Cohorts"> | string
    oId?: IntWithAggregatesFilter<"Cohorts"> | number
    product?: StringWithAggregatesFilter<"Cohorts"> | string
    stage?: StringWithAggregatesFilter<"Cohorts"> | string
    placementType?: StringWithAggregatesFilter<"Cohorts"> | string
    name?: StringWithAggregatesFilter<"Cohorts"> | string
    startPlacements?: StringWithAggregatesFilter<"Cohorts"> | string
    endPlacements?: StringWithAggregatesFilter<"Cohorts"> | string
    startSubmission?: StringWithAggregatesFilter<"Cohorts"> | string
    endSubmission?: StringWithAggregatesFilter<"Cohorts"> | string
    includedFiles?: StringNullableListFilter<"Cohorts">
    includedForms?: StringNullableListFilter<"Cohorts">
    workflow?: StringWithAggregatesFilter<"Cohorts"> | string
  }

  export type ContactsWhereInput = {
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    contactId?: IntFilter<"Contacts"> | number
    address_line1?: StringFilter<"Contacts"> | string
    address_line2?: StringFilter<"Contacts"> | string
    contactForename?: StringFilter<"Contacts"> | string
    contactSurname?: StringFilter<"Contacts"> | string
    country?: StringFilter<"Contacts"> | string
    created?: StringFilter<"Contacts"> | string
    locality?: StringFilter<"Contacts"> | string
    name?: StringFilter<"Contacts"> | string
    providerEmail?: StringFilter<"Contacts"> | string
    providerPhone?: StringFilter<"Contacts"> | string
    postal_code?: StringFilter<"Contacts"> | string
    uid?: StringFilter<"Contacts"> | string
  }

  export type ContactsOrderByWithRelationInput = {
    contactId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    providerEmail?: SortOrder
    providerPhone?: SortOrder
    postal_code?: SortOrder
    uid?: SortOrder
  }

  export type ContactsWhereUniqueInput = Prisma.AtLeast<{
    contactId?: number
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    address_line1?: StringFilter<"Contacts"> | string
    address_line2?: StringFilter<"Contacts"> | string
    contactForename?: StringFilter<"Contacts"> | string
    contactSurname?: StringFilter<"Contacts"> | string
    country?: StringFilter<"Contacts"> | string
    created?: StringFilter<"Contacts"> | string
    locality?: StringFilter<"Contacts"> | string
    name?: StringFilter<"Contacts"> | string
    providerEmail?: StringFilter<"Contacts"> | string
    providerPhone?: StringFilter<"Contacts"> | string
    postal_code?: StringFilter<"Contacts"> | string
    uid?: StringFilter<"Contacts"> | string
  }, "contactId">

  export type ContactsOrderByWithAggregationInput = {
    contactId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    providerEmail?: SortOrder
    providerPhone?: SortOrder
    postal_code?: SortOrder
    uid?: SortOrder
    _count?: ContactsCountOrderByAggregateInput
    _avg?: ContactsAvgOrderByAggregateInput
    _max?: ContactsMaxOrderByAggregateInput
    _min?: ContactsMinOrderByAggregateInput
    _sum?: ContactsSumOrderByAggregateInput
  }

  export type ContactsScalarWhereWithAggregatesInput = {
    AND?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    OR?: ContactsScalarWhereWithAggregatesInput[]
    NOT?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    contactId?: IntWithAggregatesFilter<"Contacts"> | number
    address_line1?: StringWithAggregatesFilter<"Contacts"> | string
    address_line2?: StringWithAggregatesFilter<"Contacts"> | string
    contactForename?: StringWithAggregatesFilter<"Contacts"> | string
    contactSurname?: StringWithAggregatesFilter<"Contacts"> | string
    country?: StringWithAggregatesFilter<"Contacts"> | string
    created?: StringWithAggregatesFilter<"Contacts"> | string
    locality?: StringWithAggregatesFilter<"Contacts"> | string
    name?: StringWithAggregatesFilter<"Contacts"> | string
    providerEmail?: StringWithAggregatesFilter<"Contacts"> | string
    providerPhone?: StringWithAggregatesFilter<"Contacts"> | string
    postal_code?: StringWithAggregatesFilter<"Contacts"> | string
    uid?: StringWithAggregatesFilter<"Contacts"> | string
  }

  export type DowntimeWhereInput = {
    AND?: DowntimeWhereInput | DowntimeWhereInput[]
    OR?: DowntimeWhereInput[]
    NOT?: DowntimeWhereInput | DowntimeWhereInput[]
    downtimeId?: IntFilter<"Downtime"> | number
    active?: BoolFilter<"Downtime"> | boolean
    body?: StringFilter<"Downtime"> | string
    products?: StringNullableListFilter<"Downtime">
    title?: StringFilter<"Downtime"> | string
  }

  export type DowntimeOrderByWithRelationInput = {
    downtimeId?: SortOrder
    active?: SortOrder
    body?: SortOrder
    products?: SortOrder
    title?: SortOrder
  }

  export type DowntimeWhereUniqueInput = Prisma.AtLeast<{
    downtimeId?: number
    AND?: DowntimeWhereInput | DowntimeWhereInput[]
    OR?: DowntimeWhereInput[]
    NOT?: DowntimeWhereInput | DowntimeWhereInput[]
    active?: BoolFilter<"Downtime"> | boolean
    body?: StringFilter<"Downtime"> | string
    products?: StringNullableListFilter<"Downtime">
    title?: StringFilter<"Downtime"> | string
  }, "downtimeId">

  export type DowntimeOrderByWithAggregationInput = {
    downtimeId?: SortOrder
    active?: SortOrder
    body?: SortOrder
    products?: SortOrder
    title?: SortOrder
    _count?: DowntimeCountOrderByAggregateInput
    _avg?: DowntimeAvgOrderByAggregateInput
    _max?: DowntimeMaxOrderByAggregateInput
    _min?: DowntimeMinOrderByAggregateInput
    _sum?: DowntimeSumOrderByAggregateInput
  }

  export type DowntimeScalarWhereWithAggregatesInput = {
    AND?: DowntimeScalarWhereWithAggregatesInput | DowntimeScalarWhereWithAggregatesInput[]
    OR?: DowntimeScalarWhereWithAggregatesInput[]
    NOT?: DowntimeScalarWhereWithAggregatesInput | DowntimeScalarWhereWithAggregatesInput[]
    downtimeId?: IntWithAggregatesFilter<"Downtime"> | number
    active?: BoolWithAggregatesFilter<"Downtime"> | boolean
    body?: StringWithAggregatesFilter<"Downtime"> | string
    products?: StringNullableListFilter<"Downtime">
    title?: StringWithAggregatesFilter<"Downtime"> | string
  }

  export type FeatureRequestsWhereInput = {
    AND?: FeatureRequestsWhereInput | FeatureRequestsWhereInput[]
    OR?: FeatureRequestsWhereInput[]
    NOT?: FeatureRequestsWhereInput | FeatureRequestsWhereInput[]
    featureRequestId?: IntFilter<"FeatureRequests"> | number
    date?: DateTimeFilter<"FeatureRequests"> | Date | string
    description?: StringFilter<"FeatureRequests"> | string
    feature?: StringFilter<"FeatureRequests"> | string
    impact?: StringFilter<"FeatureRequests"> | string
    uid?: StringFilter<"FeatureRequests"> | string
  }

  export type FeatureRequestsOrderByWithRelationInput = {
    featureRequestId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    feature?: SortOrder
    impact?: SortOrder
    uid?: SortOrder
  }

  export type FeatureRequestsWhereUniqueInput = Prisma.AtLeast<{
    featureRequestId?: number
    AND?: FeatureRequestsWhereInput | FeatureRequestsWhereInput[]
    OR?: FeatureRequestsWhereInput[]
    NOT?: FeatureRequestsWhereInput | FeatureRequestsWhereInput[]
    date?: DateTimeFilter<"FeatureRequests"> | Date | string
    description?: StringFilter<"FeatureRequests"> | string
    feature?: StringFilter<"FeatureRequests"> | string
    impact?: StringFilter<"FeatureRequests"> | string
    uid?: StringFilter<"FeatureRequests"> | string
  }, "featureRequestId">

  export type FeatureRequestsOrderByWithAggregationInput = {
    featureRequestId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    feature?: SortOrder
    impact?: SortOrder
    uid?: SortOrder
    _count?: FeatureRequestsCountOrderByAggregateInput
    _avg?: FeatureRequestsAvgOrderByAggregateInput
    _max?: FeatureRequestsMaxOrderByAggregateInput
    _min?: FeatureRequestsMinOrderByAggregateInput
    _sum?: FeatureRequestsSumOrderByAggregateInput
  }

  export type FeatureRequestsScalarWhereWithAggregatesInput = {
    AND?: FeatureRequestsScalarWhereWithAggregatesInput | FeatureRequestsScalarWhereWithAggregatesInput[]
    OR?: FeatureRequestsScalarWhereWithAggregatesInput[]
    NOT?: FeatureRequestsScalarWhereWithAggregatesInput | FeatureRequestsScalarWhereWithAggregatesInput[]
    featureRequestId?: IntWithAggregatesFilter<"FeatureRequests"> | number
    date?: DateTimeWithAggregatesFilter<"FeatureRequests"> | Date | string
    description?: StringWithAggregatesFilter<"FeatureRequests"> | string
    feature?: StringWithAggregatesFilter<"FeatureRequests"> | string
    impact?: StringWithAggregatesFilter<"FeatureRequests"> | string
    uid?: StringWithAggregatesFilter<"FeatureRequests"> | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    feedbackId?: IntFilter<"Feedback"> | number
    created?: DateTimeFilter<"Feedback"> | Date | string
    msg?: StringFilter<"Feedback"> | string
    title?: StringFilter<"Feedback"> | string
    uid?: StringFilter<"Feedback"> | string
  }

  export type FeedbackOrderByWithRelationInput = {
    feedbackId?: SortOrder
    created?: SortOrder
    msg?: SortOrder
    title?: SortOrder
    uid?: SortOrder
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    feedbackId?: number
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    created?: DateTimeFilter<"Feedback"> | Date | string
    msg?: StringFilter<"Feedback"> | string
    title?: StringFilter<"Feedback"> | string
    uid?: StringFilter<"Feedback"> | string
  }, "feedbackId">

  export type FeedbackOrderByWithAggregationInput = {
    feedbackId?: SortOrder
    created?: SortOrder
    msg?: SortOrder
    title?: SortOrder
    uid?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    feedbackId?: IntWithAggregatesFilter<"Feedback"> | number
    created?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    msg?: StringWithAggregatesFilter<"Feedback"> | string
    title?: StringWithAggregatesFilter<"Feedback"> | string
    uid?: StringWithAggregatesFilter<"Feedback"> | string
  }

  export type FormsWhereInput = {
    AND?: FormsWhereInput | FormsWhereInput[]
    OR?: FormsWhereInput[]
    NOT?: FormsWhereInput | FormsWhereInput[]
    formId?: IntFilter<"Forms"> | number
    form?: JsonFilter<"Forms">
    oId?: IntFilter<"Forms"> | number
    product?: StringFilter<"Forms"> | string
    updated?: StringFilter<"Forms"> | string
  }

  export type FormsOrderByWithRelationInput = {
    formId?: SortOrder
    form?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    updated?: SortOrder
  }

  export type FormsWhereUniqueInput = Prisma.AtLeast<{
    formId?: number
    AND?: FormsWhereInput | FormsWhereInput[]
    OR?: FormsWhereInput[]
    NOT?: FormsWhereInput | FormsWhereInput[]
    form?: JsonFilter<"Forms">
    oId?: IntFilter<"Forms"> | number
    product?: StringFilter<"Forms"> | string
    updated?: StringFilter<"Forms"> | string
  }, "formId">

  export type FormsOrderByWithAggregationInput = {
    formId?: SortOrder
    form?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    updated?: SortOrder
    _count?: FormsCountOrderByAggregateInput
    _avg?: FormsAvgOrderByAggregateInput
    _max?: FormsMaxOrderByAggregateInput
    _min?: FormsMinOrderByAggregateInput
    _sum?: FormsSumOrderByAggregateInput
  }

  export type FormsScalarWhereWithAggregatesInput = {
    AND?: FormsScalarWhereWithAggregatesInput | FormsScalarWhereWithAggregatesInput[]
    OR?: FormsScalarWhereWithAggregatesInput[]
    NOT?: FormsScalarWhereWithAggregatesInput | FormsScalarWhereWithAggregatesInput[]
    formId?: IntWithAggregatesFilter<"Forms"> | number
    form?: JsonWithAggregatesFilter<"Forms">
    oId?: IntWithAggregatesFilter<"Forms"> | number
    product?: StringWithAggregatesFilter<"Forms"> | string
    updated?: StringWithAggregatesFilter<"Forms"> | string
  }

  export type InstitutesWhereInput = {
    AND?: InstitutesWhereInput | InstitutesWhereInput[]
    OR?: InstitutesWhereInput[]
    NOT?: InstitutesWhereInput | InstitutesWhereInput[]
    instituteId?: IntFilter<"Institutes"> | number
    address_line1?: StringFilter<"Institutes"> | string
    address_line2?: StringFilter<"Institutes"> | string
    admin?: StringFilter<"Institutes"> | string
    country?: StringFilter<"Institutes"> | string
    externalProviderUploads?: BoolFilter<"Institutes"> | boolean
    geoHash?: StringFilter<"Institutes"> | string
    locality?: StringFilter<"Institutes"> | string
    name?: StringFilter<"Institutes"> | string
    postal_code?: StringFilter<"Institutes"> | string
    referral?: StringNullableFilter<"Institutes"> | string | null
    status?: StringFilter<"Institutes"> | string
    studentsFields?: StringNullableListFilter<"Institutes">
    staff?: IntFilter<"Institutes"> | number
    staffActive?: IntFilter<"Institutes"> | number
    students?: IntFilter<"Institutes"> | number
    studentsActive?: IntFilter<"Institutes"> | number
    staffFields?: StringNullableListFilter<"Institutes">
    staffGuidance?: JsonFilter<"Institutes">
    studentsGuidance?: JsonFilter<"Institutes">
    verifiedProviders?: StringNullableListFilter<"Institutes">
  }

  export type InstitutesOrderByWithRelationInput = {
    instituteId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    admin?: SortOrder
    country?: SortOrder
    externalProviderUploads?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
    referral?: SortOrderInput | SortOrder
    status?: SortOrder
    studentsFields?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
    staffFields?: SortOrder
    staffGuidance?: SortOrder
    studentsGuidance?: SortOrder
    verifiedProviders?: SortOrder
  }

  export type InstitutesWhereUniqueInput = Prisma.AtLeast<{
    instituteId?: number
    AND?: InstitutesWhereInput | InstitutesWhereInput[]
    OR?: InstitutesWhereInput[]
    NOT?: InstitutesWhereInput | InstitutesWhereInput[]
    address_line1?: StringFilter<"Institutes"> | string
    address_line2?: StringFilter<"Institutes"> | string
    admin?: StringFilter<"Institutes"> | string
    country?: StringFilter<"Institutes"> | string
    externalProviderUploads?: BoolFilter<"Institutes"> | boolean
    geoHash?: StringFilter<"Institutes"> | string
    locality?: StringFilter<"Institutes"> | string
    name?: StringFilter<"Institutes"> | string
    postal_code?: StringFilter<"Institutes"> | string
    referral?: StringNullableFilter<"Institutes"> | string | null
    status?: StringFilter<"Institutes"> | string
    studentsFields?: StringNullableListFilter<"Institutes">
    staff?: IntFilter<"Institutes"> | number
    staffActive?: IntFilter<"Institutes"> | number
    students?: IntFilter<"Institutes"> | number
    studentsActive?: IntFilter<"Institutes"> | number
    staffFields?: StringNullableListFilter<"Institutes">
    staffGuidance?: JsonFilter<"Institutes">
    studentsGuidance?: JsonFilter<"Institutes">
    verifiedProviders?: StringNullableListFilter<"Institutes">
  }, "instituteId">

  export type InstitutesOrderByWithAggregationInput = {
    instituteId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    admin?: SortOrder
    country?: SortOrder
    externalProviderUploads?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
    referral?: SortOrderInput | SortOrder
    status?: SortOrder
    studentsFields?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
    staffFields?: SortOrder
    staffGuidance?: SortOrder
    studentsGuidance?: SortOrder
    verifiedProviders?: SortOrder
    _count?: InstitutesCountOrderByAggregateInput
    _avg?: InstitutesAvgOrderByAggregateInput
    _max?: InstitutesMaxOrderByAggregateInput
    _min?: InstitutesMinOrderByAggregateInput
    _sum?: InstitutesSumOrderByAggregateInput
  }

  export type InstitutesScalarWhereWithAggregatesInput = {
    AND?: InstitutesScalarWhereWithAggregatesInput | InstitutesScalarWhereWithAggregatesInput[]
    OR?: InstitutesScalarWhereWithAggregatesInput[]
    NOT?: InstitutesScalarWhereWithAggregatesInput | InstitutesScalarWhereWithAggregatesInput[]
    instituteId?: IntWithAggregatesFilter<"Institutes"> | number
    address_line1?: StringWithAggregatesFilter<"Institutes"> | string
    address_line2?: StringWithAggregatesFilter<"Institutes"> | string
    admin?: StringWithAggregatesFilter<"Institutes"> | string
    country?: StringWithAggregatesFilter<"Institutes"> | string
    externalProviderUploads?: BoolWithAggregatesFilter<"Institutes"> | boolean
    geoHash?: StringWithAggregatesFilter<"Institutes"> | string
    locality?: StringWithAggregatesFilter<"Institutes"> | string
    name?: StringWithAggregatesFilter<"Institutes"> | string
    postal_code?: StringWithAggregatesFilter<"Institutes"> | string
    referral?: StringNullableWithAggregatesFilter<"Institutes"> | string | null
    status?: StringWithAggregatesFilter<"Institutes"> | string
    studentsFields?: StringNullableListFilter<"Institutes">
    staff?: IntWithAggregatesFilter<"Institutes"> | number
    staffActive?: IntWithAggregatesFilter<"Institutes"> | number
    students?: IntWithAggregatesFilter<"Institutes"> | number
    studentsActive?: IntWithAggregatesFilter<"Institutes"> | number
    staffFields?: StringNullableListFilter<"Institutes">
    staffGuidance?: JsonWithAggregatesFilter<"Institutes">
    studentsGuidance?: JsonWithAggregatesFilter<"Institutes">
    verifiedProviders?: StringNullableListFilter<"Institutes">
  }

  export type JobsWhereInput = {
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    jobId?: IntFilter<"Jobs"> | number
    started?: StringFilter<"Jobs"> | string
    updated?: StringNullableFilter<"Jobs"> | string | null
    finished?: StringNullableFilter<"Jobs"> | string | null
    title?: StringFilter<"Jobs"> | string
    description?: StringFilter<"Jobs"> | string
    status?: StringFilter<"Jobs"> | string
    logs?: JsonFilter<"Jobs">
    outputMsg?: StringNullableFilter<"Jobs"> | string | null
    viewedBy?: StringNullableListFilter<"Jobs">
    oId?: IntFilter<"Jobs"> | number
    product?: StringFilter<"Jobs"> | string
  }

  export type JobsOrderByWithRelationInput = {
    jobId?: SortOrder
    started?: SortOrder
    updated?: SortOrderInput | SortOrder
    finished?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    logs?: SortOrder
    outputMsg?: SortOrderInput | SortOrder
    viewedBy?: SortOrder
    oId?: SortOrder
    product?: SortOrder
  }

  export type JobsWhereUniqueInput = Prisma.AtLeast<{
    jobId?: number
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    started?: StringFilter<"Jobs"> | string
    updated?: StringNullableFilter<"Jobs"> | string | null
    finished?: StringNullableFilter<"Jobs"> | string | null
    title?: StringFilter<"Jobs"> | string
    description?: StringFilter<"Jobs"> | string
    status?: StringFilter<"Jobs"> | string
    logs?: JsonFilter<"Jobs">
    outputMsg?: StringNullableFilter<"Jobs"> | string | null
    viewedBy?: StringNullableListFilter<"Jobs">
    oId?: IntFilter<"Jobs"> | number
    product?: StringFilter<"Jobs"> | string
  }, "jobId">

  export type JobsOrderByWithAggregationInput = {
    jobId?: SortOrder
    started?: SortOrder
    updated?: SortOrderInput | SortOrder
    finished?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    logs?: SortOrder
    outputMsg?: SortOrderInput | SortOrder
    viewedBy?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    _count?: JobsCountOrderByAggregateInput
    _avg?: JobsAvgOrderByAggregateInput
    _max?: JobsMaxOrderByAggregateInput
    _min?: JobsMinOrderByAggregateInput
    _sum?: JobsSumOrderByAggregateInput
  }

  export type JobsScalarWhereWithAggregatesInput = {
    AND?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    OR?: JobsScalarWhereWithAggregatesInput[]
    NOT?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    jobId?: IntWithAggregatesFilter<"Jobs"> | number
    started?: StringWithAggregatesFilter<"Jobs"> | string
    updated?: StringNullableWithAggregatesFilter<"Jobs"> | string | null
    finished?: StringNullableWithAggregatesFilter<"Jobs"> | string | null
    title?: StringWithAggregatesFilter<"Jobs"> | string
    description?: StringWithAggregatesFilter<"Jobs"> | string
    status?: StringWithAggregatesFilter<"Jobs"> | string
    logs?: JsonWithAggregatesFilter<"Jobs">
    outputMsg?: StringNullableWithAggregatesFilter<"Jobs"> | string | null
    viewedBy?: StringNullableListFilter<"Jobs">
    oId?: IntWithAggregatesFilter<"Jobs"> | number
    product?: StringWithAggregatesFilter<"Jobs"> | string
  }

  export type LogsWhereInput = {
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    logId?: IntFilter<"Logs"> | number
    oId?: IntFilter<"Logs"> | number
    provider?: JsonFilter<"Logs">
    students?: JsonFilter<"Logs">
    staff?: JsonFilter<"Logs">
    uid?: StringFilter<"Logs"> | string
  }

  export type LogsOrderByWithRelationInput = {
    logId?: SortOrder
    oId?: SortOrder
    provider?: SortOrder
    students?: SortOrder
    staff?: SortOrder
    uid?: SortOrder
  }

  export type LogsWhereUniqueInput = Prisma.AtLeast<{
    logId?: number
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    oId?: IntFilter<"Logs"> | number
    provider?: JsonFilter<"Logs">
    students?: JsonFilter<"Logs">
    staff?: JsonFilter<"Logs">
    uid?: StringFilter<"Logs"> | string
  }, "logId">

  export type LogsOrderByWithAggregationInput = {
    logId?: SortOrder
    oId?: SortOrder
    provider?: SortOrder
    students?: SortOrder
    staff?: SortOrder
    uid?: SortOrder
    _count?: LogsCountOrderByAggregateInput
    _avg?: LogsAvgOrderByAggregateInput
    _max?: LogsMaxOrderByAggregateInput
    _min?: LogsMinOrderByAggregateInput
    _sum?: LogsSumOrderByAggregateInput
  }

  export type LogsScalarWhereWithAggregatesInput = {
    AND?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    OR?: LogsScalarWhereWithAggregatesInput[]
    NOT?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    logId?: IntWithAggregatesFilter<"Logs"> | number
    oId?: IntWithAggregatesFilter<"Logs"> | number
    provider?: JsonWithAggregatesFilter<"Logs">
    students?: JsonWithAggregatesFilter<"Logs">
    staff?: JsonWithAggregatesFilter<"Logs">
    uid?: StringWithAggregatesFilter<"Logs"> | string
  }

  export type PlacementListingsWhereInput = {
    AND?: PlacementListingsWhereInput | PlacementListingsWhereInput[]
    OR?: PlacementListingsWhereInput[]
    NOT?: PlacementListingsWhereInput | PlacementListingsWhereInput[]
    placementListingId?: IntFilter<"PlacementListings"> | number
    addressId?: StringFilter<"PlacementListings"> | string
    contactForename?: StringFilter<"PlacementListings"> | string
    contactSurname?: StringFilter<"PlacementListings"> | string
    created?: DateTimeFilter<"PlacementListings"> | Date | string
    mapConsent?: BoolFilter<"PlacementListings"> | boolean
    mapConsentDate?: StringFilter<"PlacementListings"> | string
    providerEmail?: StringFilter<"PlacementListings"> | string
    providerId?: StringFilter<"PlacementListings"> | string
    providerPhone?: StringFilter<"PlacementListings"> | string
    savedBy?: JsonFilter<"PlacementListings">
    questions?: JsonFilter<"PlacementListings">
    title?: StringFilter<"PlacementListings"> | string
    uploadedBy?: StringFilter<"PlacementListings"> | string
  }

  export type PlacementListingsOrderByWithRelationInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    savedBy?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
  }

  export type PlacementListingsWhereUniqueInput = Prisma.AtLeast<{
    placementListingId?: number
    addressId?: string
    providerId?: string
    AND?: PlacementListingsWhereInput | PlacementListingsWhereInput[]
    OR?: PlacementListingsWhereInput[]
    NOT?: PlacementListingsWhereInput | PlacementListingsWhereInput[]
    contactForename?: StringFilter<"PlacementListings"> | string
    contactSurname?: StringFilter<"PlacementListings"> | string
    created?: DateTimeFilter<"PlacementListings"> | Date | string
    mapConsent?: BoolFilter<"PlacementListings"> | boolean
    mapConsentDate?: StringFilter<"PlacementListings"> | string
    providerEmail?: StringFilter<"PlacementListings"> | string
    providerPhone?: StringFilter<"PlacementListings"> | string
    savedBy?: JsonFilter<"PlacementListings">
    questions?: JsonFilter<"PlacementListings">
    title?: StringFilter<"PlacementListings"> | string
    uploadedBy?: StringFilter<"PlacementListings"> | string
  }, "placementListingId" | "addressId" | "providerId">

  export type PlacementListingsOrderByWithAggregationInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    savedBy?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
    _count?: PlacementListingsCountOrderByAggregateInput
    _avg?: PlacementListingsAvgOrderByAggregateInput
    _max?: PlacementListingsMaxOrderByAggregateInput
    _min?: PlacementListingsMinOrderByAggregateInput
    _sum?: PlacementListingsSumOrderByAggregateInput
  }

  export type PlacementListingsScalarWhereWithAggregatesInput = {
    AND?: PlacementListingsScalarWhereWithAggregatesInput | PlacementListingsScalarWhereWithAggregatesInput[]
    OR?: PlacementListingsScalarWhereWithAggregatesInput[]
    NOT?: PlacementListingsScalarWhereWithAggregatesInput | PlacementListingsScalarWhereWithAggregatesInput[]
    placementListingId?: IntWithAggregatesFilter<"PlacementListings"> | number
    addressId?: StringWithAggregatesFilter<"PlacementListings"> | string
    contactForename?: StringWithAggregatesFilter<"PlacementListings"> | string
    contactSurname?: StringWithAggregatesFilter<"PlacementListings"> | string
    created?: DateTimeWithAggregatesFilter<"PlacementListings"> | Date | string
    mapConsent?: BoolWithAggregatesFilter<"PlacementListings"> | boolean
    mapConsentDate?: StringWithAggregatesFilter<"PlacementListings"> | string
    providerEmail?: StringWithAggregatesFilter<"PlacementListings"> | string
    providerId?: StringWithAggregatesFilter<"PlacementListings"> | string
    providerPhone?: StringWithAggregatesFilter<"PlacementListings"> | string
    savedBy?: JsonWithAggregatesFilter<"PlacementListings">
    questions?: JsonWithAggregatesFilter<"PlacementListings">
    title?: StringWithAggregatesFilter<"PlacementListings"> | string
    uploadedBy?: StringWithAggregatesFilter<"PlacementListings"> | string
  }

  export type PlacementsWhereInput = {
    AND?: PlacementsWhereInput | PlacementsWhereInput[]
    OR?: PlacementsWhereInput[]
    NOT?: PlacementsWhereInput | PlacementsWhereInput[]
    placementId?: IntFilter<"Placements"> | number
    activeDates?: StringNullableListFilter<"Placements">
    address_line1?: StringFilter<"Placements"> | string
    address_line2?: StringFilter<"Placements"> | string
    cohortId?: IntFilter<"Placements"> | number
    contactForename?: StringFilter<"Placements"> | string
    contactSurname?: StringFilter<"Placements"> | string
    country?: StringFilter<"Placements"> | string
    created?: StringFilter<"Placements"> | string
    draft?: BoolFilter<"Placements"> | boolean
    endDate?: StringFilter<"Placements"> | string
    flags?: StringNullableListFilter<"Placements">
    geoHash?: StringFilter<"Placements"> | string
    inProgress?: BoolFilter<"Placements"> | boolean
    leadTimes?: StringNullableListFilter<"Placements">
    locality?: StringFilter<"Placements"> | string
    name?: StringFilter<"Placements"> | string
    oId?: IntNullableFilter<"Placements"> | number | null
    parentEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    parentExpiry?: StringNullableFilter<"Placements"> | string | null
    parentKey?: StringNullableFilter<"Placements"> | string | null
    postal_code?: StringFilter<"Placements"> | string
    product?: StringNullableFilter<"Placements"> | string | null
    providerEmail?: StringNullableFilter<"Placements"> | string | null
    providerEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    providerExpiry?: StringNullableFilter<"Placements"> | string | null
    providerKey?: StringNullableFilter<"Placements"> | string | null
    providerName?: StringNullableFilter<"Placements"> | string | null
    providerPhone?: StringFilter<"Placements"> | string
    nextStatus?: IntNullableFilter<"Placements"> | number | null
    status?: IntFilter<"Placements"> | number
    startDate?: StringFilter<"Placements"> | string
    title?: StringFilter<"Placements"> | string
    uid?: StringFilter<"Placements"> | string
    forms?: JsonFilter<"Placements">
    questions?: JsonFilter<"Placements">
    uploadedBy?: StringFilter<"Placements"> | string
    userGroup?: IntNullableFilter<"Placements"> | number | null
  }

  export type PlacementsOrderByWithRelationInput = {
    placementId?: SortOrder
    activeDates?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    flags?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    leadTimes?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    oId?: SortOrderInput | SortOrder
    parentEmailed?: SortOrderInput | SortOrder
    parentExpiry?: SortOrderInput | SortOrder
    parentKey?: SortOrderInput | SortOrder
    postal_code?: SortOrder
    product?: SortOrderInput | SortOrder
    providerEmail?: SortOrderInput | SortOrder
    providerEmailed?: SortOrderInput | SortOrder
    providerExpiry?: SortOrderInput | SortOrder
    providerKey?: SortOrderInput | SortOrder
    providerName?: SortOrderInput | SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    uid?: SortOrder
    forms?: SortOrder
    questions?: SortOrder
    uploadedBy?: SortOrder
    userGroup?: SortOrderInput | SortOrder
  }

  export type PlacementsWhereUniqueInput = Prisma.AtLeast<{
    placementId?: number
    AND?: PlacementsWhereInput | PlacementsWhereInput[]
    OR?: PlacementsWhereInput[]
    NOT?: PlacementsWhereInput | PlacementsWhereInput[]
    activeDates?: StringNullableListFilter<"Placements">
    address_line1?: StringFilter<"Placements"> | string
    address_line2?: StringFilter<"Placements"> | string
    cohortId?: IntFilter<"Placements"> | number
    contactForename?: StringFilter<"Placements"> | string
    contactSurname?: StringFilter<"Placements"> | string
    country?: StringFilter<"Placements"> | string
    created?: StringFilter<"Placements"> | string
    draft?: BoolFilter<"Placements"> | boolean
    endDate?: StringFilter<"Placements"> | string
    flags?: StringNullableListFilter<"Placements">
    geoHash?: StringFilter<"Placements"> | string
    inProgress?: BoolFilter<"Placements"> | boolean
    leadTimes?: StringNullableListFilter<"Placements">
    locality?: StringFilter<"Placements"> | string
    name?: StringFilter<"Placements"> | string
    oId?: IntNullableFilter<"Placements"> | number | null
    parentEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    parentExpiry?: StringNullableFilter<"Placements"> | string | null
    parentKey?: StringNullableFilter<"Placements"> | string | null
    postal_code?: StringFilter<"Placements"> | string
    product?: StringNullableFilter<"Placements"> | string | null
    providerEmail?: StringNullableFilter<"Placements"> | string | null
    providerEmailed?: DateTimeNullableFilter<"Placements"> | Date | string | null
    providerExpiry?: StringNullableFilter<"Placements"> | string | null
    providerKey?: StringNullableFilter<"Placements"> | string | null
    providerName?: StringNullableFilter<"Placements"> | string | null
    providerPhone?: StringFilter<"Placements"> | string
    nextStatus?: IntNullableFilter<"Placements"> | number | null
    status?: IntFilter<"Placements"> | number
    startDate?: StringFilter<"Placements"> | string
    title?: StringFilter<"Placements"> | string
    uid?: StringFilter<"Placements"> | string
    forms?: JsonFilter<"Placements">
    questions?: JsonFilter<"Placements">
    uploadedBy?: StringFilter<"Placements"> | string
    userGroup?: IntNullableFilter<"Placements"> | number | null
  }, "placementId">

  export type PlacementsOrderByWithAggregationInput = {
    placementId?: SortOrder
    activeDates?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    flags?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    leadTimes?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    oId?: SortOrderInput | SortOrder
    parentEmailed?: SortOrderInput | SortOrder
    parentExpiry?: SortOrderInput | SortOrder
    parentKey?: SortOrderInput | SortOrder
    postal_code?: SortOrder
    product?: SortOrderInput | SortOrder
    providerEmail?: SortOrderInput | SortOrder
    providerEmailed?: SortOrderInput | SortOrder
    providerExpiry?: SortOrderInput | SortOrder
    providerKey?: SortOrderInput | SortOrder
    providerName?: SortOrderInput | SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    uid?: SortOrder
    forms?: SortOrder
    questions?: SortOrder
    uploadedBy?: SortOrder
    userGroup?: SortOrderInput | SortOrder
    _count?: PlacementsCountOrderByAggregateInput
    _avg?: PlacementsAvgOrderByAggregateInput
    _max?: PlacementsMaxOrderByAggregateInput
    _min?: PlacementsMinOrderByAggregateInput
    _sum?: PlacementsSumOrderByAggregateInput
  }

  export type PlacementsScalarWhereWithAggregatesInput = {
    AND?: PlacementsScalarWhereWithAggregatesInput | PlacementsScalarWhereWithAggregatesInput[]
    OR?: PlacementsScalarWhereWithAggregatesInput[]
    NOT?: PlacementsScalarWhereWithAggregatesInput | PlacementsScalarWhereWithAggregatesInput[]
    placementId?: IntWithAggregatesFilter<"Placements"> | number
    activeDates?: StringNullableListFilter<"Placements">
    address_line1?: StringWithAggregatesFilter<"Placements"> | string
    address_line2?: StringWithAggregatesFilter<"Placements"> | string
    cohortId?: IntWithAggregatesFilter<"Placements"> | number
    contactForename?: StringWithAggregatesFilter<"Placements"> | string
    contactSurname?: StringWithAggregatesFilter<"Placements"> | string
    country?: StringWithAggregatesFilter<"Placements"> | string
    created?: StringWithAggregatesFilter<"Placements"> | string
    draft?: BoolWithAggregatesFilter<"Placements"> | boolean
    endDate?: StringWithAggregatesFilter<"Placements"> | string
    flags?: StringNullableListFilter<"Placements">
    geoHash?: StringWithAggregatesFilter<"Placements"> | string
    inProgress?: BoolWithAggregatesFilter<"Placements"> | boolean
    leadTimes?: StringNullableListFilter<"Placements">
    locality?: StringWithAggregatesFilter<"Placements"> | string
    name?: StringWithAggregatesFilter<"Placements"> | string
    oId?: IntNullableWithAggregatesFilter<"Placements"> | number | null
    parentEmailed?: DateTimeNullableWithAggregatesFilter<"Placements"> | Date | string | null
    parentExpiry?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    parentKey?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    postal_code?: StringWithAggregatesFilter<"Placements"> | string
    product?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerEmail?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerEmailed?: DateTimeNullableWithAggregatesFilter<"Placements"> | Date | string | null
    providerExpiry?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerKey?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerName?: StringNullableWithAggregatesFilter<"Placements"> | string | null
    providerPhone?: StringWithAggregatesFilter<"Placements"> | string
    nextStatus?: IntNullableWithAggregatesFilter<"Placements"> | number | null
    status?: IntWithAggregatesFilter<"Placements"> | number
    startDate?: StringWithAggregatesFilter<"Placements"> | string
    title?: StringWithAggregatesFilter<"Placements"> | string
    uid?: StringWithAggregatesFilter<"Placements"> | string
    forms?: JsonWithAggregatesFilter<"Placements">
    questions?: JsonWithAggregatesFilter<"Placements">
    uploadedBy?: StringWithAggregatesFilter<"Placements"> | string
    userGroup?: IntNullableWithAggregatesFilter<"Placements"> | number | null
  }

  export type ProvidersWhereInput = {
    AND?: ProvidersWhereInput | ProvidersWhereInput[]
    OR?: ProvidersWhereInput[]
    NOT?: ProvidersWhereInput | ProvidersWhereInput[]
    providerId?: IntFilter<"Providers"> | number
    contactForename?: StringFilter<"Providers"> | string
    contactSurname?: StringFilter<"Providers"> | string
    defAddress?: IntFilter<"Providers"> | number
    email?: StringFilter<"Providers"> | string
    mapConsent?: BoolFilter<"Providers"> | boolean
    insurance?: BoolFilter<"Providers"> | boolean
    mapConsentDate?: StringFilter<"Providers"> | string
    name?: StringFilter<"Providers"> | string
    phone?: StringFilter<"Providers"> | string
    rememberConsent?: BoolFilter<"Providers"> | boolean
    rememberConsentDate?: StringFilter<"Providers"> | string
    savedBy?: JsonFilter<"Providers">
    sector?: StringFilter<"Providers"> | string
    subsector?: StringFilter<"Providers"> | string
    uploadedBy?: StringFilter<"Providers"> | string
    website?: StringFilter<"Providers"> | string
  }

  export type ProvidersOrderByWithRelationInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    defAddress?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrder
    insurance?: SortOrder
    mapConsentDate?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrder
    rememberConsentDate?: SortOrder
    savedBy?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrder
  }

  export type ProvidersWhereUniqueInput = Prisma.AtLeast<{
    providerId?: number
    AND?: ProvidersWhereInput | ProvidersWhereInput[]
    OR?: ProvidersWhereInput[]
    NOT?: ProvidersWhereInput | ProvidersWhereInput[]
    contactForename?: StringFilter<"Providers"> | string
    contactSurname?: StringFilter<"Providers"> | string
    defAddress?: IntFilter<"Providers"> | number
    email?: StringFilter<"Providers"> | string
    mapConsent?: BoolFilter<"Providers"> | boolean
    insurance?: BoolFilter<"Providers"> | boolean
    mapConsentDate?: StringFilter<"Providers"> | string
    name?: StringFilter<"Providers"> | string
    phone?: StringFilter<"Providers"> | string
    rememberConsent?: BoolFilter<"Providers"> | boolean
    rememberConsentDate?: StringFilter<"Providers"> | string
    savedBy?: JsonFilter<"Providers">
    sector?: StringFilter<"Providers"> | string
    subsector?: StringFilter<"Providers"> | string
    uploadedBy?: StringFilter<"Providers"> | string
    website?: StringFilter<"Providers"> | string
  }, "providerId">

  export type ProvidersOrderByWithAggregationInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    defAddress?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrder
    insurance?: SortOrder
    mapConsentDate?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrder
    rememberConsentDate?: SortOrder
    savedBy?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrder
    _count?: ProvidersCountOrderByAggregateInput
    _avg?: ProvidersAvgOrderByAggregateInput
    _max?: ProvidersMaxOrderByAggregateInput
    _min?: ProvidersMinOrderByAggregateInput
    _sum?: ProvidersSumOrderByAggregateInput
  }

  export type ProvidersScalarWhereWithAggregatesInput = {
    AND?: ProvidersScalarWhereWithAggregatesInput | ProvidersScalarWhereWithAggregatesInput[]
    OR?: ProvidersScalarWhereWithAggregatesInput[]
    NOT?: ProvidersScalarWhereWithAggregatesInput | ProvidersScalarWhereWithAggregatesInput[]
    providerId?: IntWithAggregatesFilter<"Providers"> | number
    contactForename?: StringWithAggregatesFilter<"Providers"> | string
    contactSurname?: StringWithAggregatesFilter<"Providers"> | string
    defAddress?: IntWithAggregatesFilter<"Providers"> | number
    email?: StringWithAggregatesFilter<"Providers"> | string
    mapConsent?: BoolWithAggregatesFilter<"Providers"> | boolean
    insurance?: BoolWithAggregatesFilter<"Providers"> | boolean
    mapConsentDate?: StringWithAggregatesFilter<"Providers"> | string
    name?: StringWithAggregatesFilter<"Providers"> | string
    phone?: StringWithAggregatesFilter<"Providers"> | string
    rememberConsent?: BoolWithAggregatesFilter<"Providers"> | boolean
    rememberConsentDate?: StringWithAggregatesFilter<"Providers"> | string
    savedBy?: JsonWithAggregatesFilter<"Providers">
    sector?: StringWithAggregatesFilter<"Providers"> | string
    subsector?: StringWithAggregatesFilter<"Providers"> | string
    uploadedBy?: StringWithAggregatesFilter<"Providers"> | string
    website?: StringWithAggregatesFilter<"Providers"> | string
  }

  export type ReferralsWhereInput = {
    AND?: ReferralsWhereInput | ReferralsWhereInput[]
    OR?: ReferralsWhereInput[]
    NOT?: ReferralsWhereInput | ReferralsWhereInput[]
    referralId?: IntFilter<"Referrals"> | number
    expiry?: DateTimeFilter<"Referrals"> | Date | string
    name?: StringFilter<"Referrals"> | string
    product?: StringFilter<"Referrals"> | string
    signUps?: IntFilter<"Referrals"> | number
    volume?: IntFilter<"Referrals"> | number
  }

  export type ReferralsOrderByWithRelationInput = {
    referralId?: SortOrder
    expiry?: SortOrder
    name?: SortOrder
    product?: SortOrder
    signUps?: SortOrder
    volume?: SortOrder
  }

  export type ReferralsWhereUniqueInput = Prisma.AtLeast<{
    referralId?: number
    AND?: ReferralsWhereInput | ReferralsWhereInput[]
    OR?: ReferralsWhereInput[]
    NOT?: ReferralsWhereInput | ReferralsWhereInput[]
    expiry?: DateTimeFilter<"Referrals"> | Date | string
    name?: StringFilter<"Referrals"> | string
    product?: StringFilter<"Referrals"> | string
    signUps?: IntFilter<"Referrals"> | number
    volume?: IntFilter<"Referrals"> | number
  }, "referralId">

  export type ReferralsOrderByWithAggregationInput = {
    referralId?: SortOrder
    expiry?: SortOrder
    name?: SortOrder
    product?: SortOrder
    signUps?: SortOrder
    volume?: SortOrder
    _count?: ReferralsCountOrderByAggregateInput
    _avg?: ReferralsAvgOrderByAggregateInput
    _max?: ReferralsMaxOrderByAggregateInput
    _min?: ReferralsMinOrderByAggregateInput
    _sum?: ReferralsSumOrderByAggregateInput
  }

  export type ReferralsScalarWhereWithAggregatesInput = {
    AND?: ReferralsScalarWhereWithAggregatesInput | ReferralsScalarWhereWithAggregatesInput[]
    OR?: ReferralsScalarWhereWithAggregatesInput[]
    NOT?: ReferralsScalarWhereWithAggregatesInput | ReferralsScalarWhereWithAggregatesInput[]
    referralId?: IntWithAggregatesFilter<"Referrals"> | number
    expiry?: DateTimeWithAggregatesFilter<"Referrals"> | Date | string
    name?: StringWithAggregatesFilter<"Referrals"> | string
    product?: StringWithAggregatesFilter<"Referrals"> | string
    signUps?: IntWithAggregatesFilter<"Referrals"> | number
    volume?: IntWithAggregatesFilter<"Referrals"> | number
  }

  export type UserGroupsWhereInput = {
    AND?: UserGroupsWhereInput | UserGroupsWhereInput[]
    OR?: UserGroupsWhereInput[]
    NOT?: UserGroupsWhereInput | UserGroupsWhereInput[]
    userGroupId?: IntFilter<"UserGroups"> | number
    default?: BoolFilter<"UserGroups"> | boolean
    name?: StringFilter<"UserGroups"> | string
    oId?: IntFilter<"UserGroups"> | number
    product?: StringFilter<"UserGroups"> | string
    template?: StringFilter<"UserGroups"> | string
    updated?: StringFilter<"UserGroups"> | string
  }

  export type UserGroupsOrderByWithRelationInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    template?: SortOrder
    updated?: SortOrder
  }

  export type UserGroupsWhereUniqueInput = Prisma.AtLeast<{
    userGroupId?: number
    AND?: UserGroupsWhereInput | UserGroupsWhereInput[]
    OR?: UserGroupsWhereInput[]
    NOT?: UserGroupsWhereInput | UserGroupsWhereInput[]
    default?: BoolFilter<"UserGroups"> | boolean
    name?: StringFilter<"UserGroups"> | string
    oId?: IntFilter<"UserGroups"> | number
    product?: StringFilter<"UserGroups"> | string
    template?: StringFilter<"UserGroups"> | string
    updated?: StringFilter<"UserGroups"> | string
  }, "userGroupId">

  export type UserGroupsOrderByWithAggregationInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    template?: SortOrder
    updated?: SortOrder
    _count?: UserGroupsCountOrderByAggregateInput
    _avg?: UserGroupsAvgOrderByAggregateInput
    _max?: UserGroupsMaxOrderByAggregateInput
    _min?: UserGroupsMinOrderByAggregateInput
    _sum?: UserGroupsSumOrderByAggregateInput
  }

  export type UserGroupsScalarWhereWithAggregatesInput = {
    AND?: UserGroupsScalarWhereWithAggregatesInput | UserGroupsScalarWhereWithAggregatesInput[]
    OR?: UserGroupsScalarWhereWithAggregatesInput[]
    NOT?: UserGroupsScalarWhereWithAggregatesInput | UserGroupsScalarWhereWithAggregatesInput[]
    userGroupId?: IntWithAggregatesFilter<"UserGroups"> | number
    default?: BoolWithAggregatesFilter<"UserGroups"> | boolean
    name?: StringWithAggregatesFilter<"UserGroups"> | string
    oId?: IntWithAggregatesFilter<"UserGroups"> | number
    product?: StringWithAggregatesFilter<"UserGroups"> | string
    template?: StringWithAggregatesFilter<"UserGroups"> | string
    updated?: StringWithAggregatesFilter<"UserGroups"> | string
  }

  export type StudentUsersWhereInput = {
    AND?: StudentUsersWhereInput | StudentUsersWhereInput[]
    OR?: StudentUsersWhereInput[]
    NOT?: StudentUsersWhereInput | StudentUsersWhereInput[]
    studentUserId?: StringFilter<"StudentUsers"> | string
    status?: StringFilter<"StudentUsers"> | string
    analytics?: JsonFilter<"StudentUsers">
    created?: StringFilter<"StudentUsers"> | string
    details?: JsonFilter<"StudentUsers">
    email?: StringFilter<"StudentUsers"> | string
    referral?: StringFilter<"StudentUsers"> | string
    units?: StringFilter<"StudentUsers"> | string
    userType?: StringFilter<"StudentUsers"> | string
  }

  export type StudentUsersOrderByWithRelationInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    analytics?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
  }

  export type StudentUsersWhereUniqueInput = Prisma.AtLeast<{
    studentUserId?: string
    AND?: StudentUsersWhereInput | StudentUsersWhereInput[]
    OR?: StudentUsersWhereInput[]
    NOT?: StudentUsersWhereInput | StudentUsersWhereInput[]
    status?: StringFilter<"StudentUsers"> | string
    analytics?: JsonFilter<"StudentUsers">
    created?: StringFilter<"StudentUsers"> | string
    details?: JsonFilter<"StudentUsers">
    email?: StringFilter<"StudentUsers"> | string
    referral?: StringFilter<"StudentUsers"> | string
    units?: StringFilter<"StudentUsers"> | string
    userType?: StringFilter<"StudentUsers"> | string
  }, "studentUserId">

  export type StudentUsersOrderByWithAggregationInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    analytics?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
    _count?: StudentUsersCountOrderByAggregateInput
    _max?: StudentUsersMaxOrderByAggregateInput
    _min?: StudentUsersMinOrderByAggregateInput
  }

  export type StudentUsersScalarWhereWithAggregatesInput = {
    AND?: StudentUsersScalarWhereWithAggregatesInput | StudentUsersScalarWhereWithAggregatesInput[]
    OR?: StudentUsersScalarWhereWithAggregatesInput[]
    NOT?: StudentUsersScalarWhereWithAggregatesInput | StudentUsersScalarWhereWithAggregatesInput[]
    studentUserId?: StringWithAggregatesFilter<"StudentUsers"> | string
    status?: StringWithAggregatesFilter<"StudentUsers"> | string
    analytics?: JsonWithAggregatesFilter<"StudentUsers">
    created?: StringWithAggregatesFilter<"StudentUsers"> | string
    details?: JsonWithAggregatesFilter<"StudentUsers">
    email?: StringWithAggregatesFilter<"StudentUsers"> | string
    referral?: StringWithAggregatesFilter<"StudentUsers"> | string
    units?: StringWithAggregatesFilter<"StudentUsers"> | string
    userType?: StringWithAggregatesFilter<"StudentUsers"> | string
  }

  export type InstituteStaffWhereInput = {
    AND?: InstituteStaffWhereInput | InstituteStaffWhereInput[]
    OR?: InstituteStaffWhereInput[]
    NOT?: InstituteStaffWhereInput | InstituteStaffWhereInput[]
    instituteStaffId?: StringFilter<"InstituteStaff"> | string
    created?: StringFilter<"InstituteStaff"> | string
    details?: JsonFilter<"InstituteStaff">
    email?: StringFilter<"InstituteStaff"> | string
    oId?: StringFilter<"InstituteStaff"> | string
    status?: StringFilter<"InstituteStaff"> | string
    userGroup?: StringFilter<"InstituteStaff"> | string
    userType?: StringFilter<"InstituteStaff"> | string
  }

  export type InstituteStaffOrderByWithRelationInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStaffWhereUniqueInput = Prisma.AtLeast<{
    instituteStaffId?: string
    AND?: InstituteStaffWhereInput | InstituteStaffWhereInput[]
    OR?: InstituteStaffWhereInput[]
    NOT?: InstituteStaffWhereInput | InstituteStaffWhereInput[]
    created?: StringFilter<"InstituteStaff"> | string
    details?: JsonFilter<"InstituteStaff">
    email?: StringFilter<"InstituteStaff"> | string
    oId?: StringFilter<"InstituteStaff"> | string
    status?: StringFilter<"InstituteStaff"> | string
    userGroup?: StringFilter<"InstituteStaff"> | string
    userType?: StringFilter<"InstituteStaff"> | string
  }, "instituteStaffId">

  export type InstituteStaffOrderByWithAggregationInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
    _count?: InstituteStaffCountOrderByAggregateInput
    _max?: InstituteStaffMaxOrderByAggregateInput
    _min?: InstituteStaffMinOrderByAggregateInput
  }

  export type InstituteStaffScalarWhereWithAggregatesInput = {
    AND?: InstituteStaffScalarWhereWithAggregatesInput | InstituteStaffScalarWhereWithAggregatesInput[]
    OR?: InstituteStaffScalarWhereWithAggregatesInput[]
    NOT?: InstituteStaffScalarWhereWithAggregatesInput | InstituteStaffScalarWhereWithAggregatesInput[]
    instituteStaffId?: StringWithAggregatesFilter<"InstituteStaff"> | string
    created?: StringWithAggregatesFilter<"InstituteStaff"> | string
    details?: JsonWithAggregatesFilter<"InstituteStaff">
    email?: StringWithAggregatesFilter<"InstituteStaff"> | string
    oId?: StringWithAggregatesFilter<"InstituteStaff"> | string
    status?: StringWithAggregatesFilter<"InstituteStaff"> | string
    userGroup?: StringWithAggregatesFilter<"InstituteStaff"> | string
    userType?: StringWithAggregatesFilter<"InstituteStaff"> | string
  }

  export type InstituteStudentsWhereInput = {
    AND?: InstituteStudentsWhereInput | InstituteStudentsWhereInput[]
    OR?: InstituteStudentsWhereInput[]
    NOT?: InstituteStudentsWhereInput | InstituteStudentsWhereInput[]
    instituteStudentId?: StringFilter<"InstituteStudents"> | string
    activated?: StringFilter<"InstituteStudents"> | string
    created?: StringFilter<"InstituteStudents"> | string
    cohortId?: IntFilter<"InstituteStudents"> | number
    details?: JsonFilter<"InstituteStudents">
    email?: StringFilter<"InstituteStudents"> | string
    flags?: StringNullableListFilter<"InstituteStudents">
    oId?: IntFilter<"InstituteStudents"> | number
    resetExpiry?: DateTimeFilter<"InstituteStudents"> | Date | string
    status?: StringFilter<"InstituteStudents"> | string
    userGroup?: IntFilter<"InstituteStudents"> | number
    userType?: StringFilter<"InstituteStudents"> | string
  }

  export type InstituteStudentsOrderByWithRelationInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    details?: SortOrder
    email?: SortOrder
    flags?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStudentsWhereUniqueInput = Prisma.AtLeast<{
    instituteStudentId?: string
    AND?: InstituteStudentsWhereInput | InstituteStudentsWhereInput[]
    OR?: InstituteStudentsWhereInput[]
    NOT?: InstituteStudentsWhereInput | InstituteStudentsWhereInput[]
    activated?: StringFilter<"InstituteStudents"> | string
    created?: StringFilter<"InstituteStudents"> | string
    cohortId?: IntFilter<"InstituteStudents"> | number
    details?: JsonFilter<"InstituteStudents">
    email?: StringFilter<"InstituteStudents"> | string
    flags?: StringNullableListFilter<"InstituteStudents">
    oId?: IntFilter<"InstituteStudents"> | number
    resetExpiry?: DateTimeFilter<"InstituteStudents"> | Date | string
    status?: StringFilter<"InstituteStudents"> | string
    userGroup?: IntFilter<"InstituteStudents"> | number
    userType?: StringFilter<"InstituteStudents"> | string
  }, "instituteStudentId">

  export type InstituteStudentsOrderByWithAggregationInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    details?: SortOrder
    email?: SortOrder
    flags?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
    _count?: InstituteStudentsCountOrderByAggregateInput
    _avg?: InstituteStudentsAvgOrderByAggregateInput
    _max?: InstituteStudentsMaxOrderByAggregateInput
    _min?: InstituteStudentsMinOrderByAggregateInput
    _sum?: InstituteStudentsSumOrderByAggregateInput
  }

  export type InstituteStudentsScalarWhereWithAggregatesInput = {
    AND?: InstituteStudentsScalarWhereWithAggregatesInput | InstituteStudentsScalarWhereWithAggregatesInput[]
    OR?: InstituteStudentsScalarWhereWithAggregatesInput[]
    NOT?: InstituteStudentsScalarWhereWithAggregatesInput | InstituteStudentsScalarWhereWithAggregatesInput[]
    instituteStudentId?: StringWithAggregatesFilter<"InstituteStudents"> | string
    activated?: StringWithAggregatesFilter<"InstituteStudents"> | string
    created?: StringWithAggregatesFilter<"InstituteStudents"> | string
    cohortId?: IntWithAggregatesFilter<"InstituteStudents"> | number
    details?: JsonWithAggregatesFilter<"InstituteStudents">
    email?: StringWithAggregatesFilter<"InstituteStudents"> | string
    flags?: StringNullableListFilter<"InstituteStudents">
    oId?: IntWithAggregatesFilter<"InstituteStudents"> | number
    resetExpiry?: DateTimeWithAggregatesFilter<"InstituteStudents"> | Date | string
    status?: StringWithAggregatesFilter<"InstituteStudents"> | string
    userGroup?: IntWithAggregatesFilter<"InstituteStudents"> | number
    userType?: StringWithAggregatesFilter<"InstituteStudents"> | string
  }

  export type ProviderStaffWhereInput = {
    AND?: ProviderStaffWhereInput | ProviderStaffWhereInput[]
    OR?: ProviderStaffWhereInput[]
    NOT?: ProviderStaffWhereInput | ProviderStaffWhereInput[]
    providerStaffId?: StringFilter<"ProviderStaff"> | string
    created?: StringFilter<"ProviderStaff"> | string
    details?: JsonFilter<"ProviderStaff">
    cohortId?: IntFilter<"ProviderStaff"> | number
    email?: StringFilter<"ProviderStaff"> | string
    notes?: JsonFilter<"ProviderStaff">
    oId?: StringFilter<"ProviderStaff"> | string
    status?: StringFilter<"ProviderStaff"> | string
    userGroup?: StringFilter<"ProviderStaff"> | string
    userType?: StringFilter<"ProviderStaff"> | string
  }

  export type ProviderStaffOrderByWithRelationInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type ProviderStaffWhereUniqueInput = Prisma.AtLeast<{
    providerStaffId?: string
    AND?: ProviderStaffWhereInput | ProviderStaffWhereInput[]
    OR?: ProviderStaffWhereInput[]
    NOT?: ProviderStaffWhereInput | ProviderStaffWhereInput[]
    created?: StringFilter<"ProviderStaff"> | string
    details?: JsonFilter<"ProviderStaff">
    cohortId?: IntFilter<"ProviderStaff"> | number
    email?: StringFilter<"ProviderStaff"> | string
    notes?: JsonFilter<"ProviderStaff">
    oId?: StringFilter<"ProviderStaff"> | string
    status?: StringFilter<"ProviderStaff"> | string
    userGroup?: StringFilter<"ProviderStaff"> | string
    userType?: StringFilter<"ProviderStaff"> | string
  }, "providerStaffId">

  export type ProviderStaffOrderByWithAggregationInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
    _count?: ProviderStaffCountOrderByAggregateInput
    _avg?: ProviderStaffAvgOrderByAggregateInput
    _max?: ProviderStaffMaxOrderByAggregateInput
    _min?: ProviderStaffMinOrderByAggregateInput
    _sum?: ProviderStaffSumOrderByAggregateInput
  }

  export type ProviderStaffScalarWhereWithAggregatesInput = {
    AND?: ProviderStaffScalarWhereWithAggregatesInput | ProviderStaffScalarWhereWithAggregatesInput[]
    OR?: ProviderStaffScalarWhereWithAggregatesInput[]
    NOT?: ProviderStaffScalarWhereWithAggregatesInput | ProviderStaffScalarWhereWithAggregatesInput[]
    providerStaffId?: StringWithAggregatesFilter<"ProviderStaff"> | string
    created?: StringWithAggregatesFilter<"ProviderStaff"> | string
    details?: JsonWithAggregatesFilter<"ProviderStaff">
    cohortId?: IntWithAggregatesFilter<"ProviderStaff"> | number
    email?: StringWithAggregatesFilter<"ProviderStaff"> | string
    notes?: JsonWithAggregatesFilter<"ProviderStaff">
    oId?: StringWithAggregatesFilter<"ProviderStaff"> | string
    status?: StringWithAggregatesFilter<"ProviderStaff"> | string
    userGroup?: StringWithAggregatesFilter<"ProviderStaff"> | string
    userType?: StringWithAggregatesFilter<"ProviderStaff"> | string
  }

  export type AddressesCreateInput = {
    address_line1: string
    address_line2: string
    contactForename: string
    contactSurname: string
    country: string
    email: string
    geoHash: string
    locality: string
    oId: number
    product: string
    phone: string
    postal_code: string
  }

  export type AddressesUncheckedCreateInput = {
    addressId?: number
    address_line1: string
    address_line2: string
    contactForename: string
    contactSurname: string
    country: string
    email: string
    geoHash: string
    locality: string
    oId: number
    product: string
    phone: string
    postal_code: string
  }

  export type AddressesUpdateInput = {
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
  }

  export type AddressesUncheckedUpdateInput = {
    addressId?: IntFieldUpdateOperationsInput | number
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
  }

  export type AddressesCreateManyInput = {
    addressId?: number
    address_line1: string
    address_line2: string
    contactForename: string
    contactSurname: string
    country: string
    email: string
    geoHash: string
    locality: string
    oId: number
    product: string
    phone: string
    postal_code: string
  }

  export type AddressesUpdateManyMutationInput = {
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
  }

  export type AddressesUncheckedUpdateManyInput = {
    addressId?: IntFieldUpdateOperationsInput | number
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    geoHash?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
  }

  export type BlogsCreateInput = {
    author: string
    category: string
    summary: string
    tags: string
    title: string
    uploaded: string
    body: JsonNullValueInput | InputJsonValue
  }

  export type BlogsUncheckedCreateInput = {
    blogId?: number
    author: string
    category: string
    summary: string
    tags: string
    title: string
    uploaded: string
    body: JsonNullValueInput | InputJsonValue
  }

  export type BlogsUpdateInput = {
    author?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uploaded?: StringFieldUpdateOperationsInput | string
    body?: JsonNullValueInput | InputJsonValue
  }

  export type BlogsUncheckedUpdateInput = {
    blogId?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uploaded?: StringFieldUpdateOperationsInput | string
    body?: JsonNullValueInput | InputJsonValue
  }

  export type BlogsCreateManyInput = {
    blogId?: number
    author: string
    category: string
    summary: string
    tags: string
    title: string
    uploaded: string
    body: JsonNullValueInput | InputJsonValue
  }

  export type BlogsUpdateManyMutationInput = {
    author?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uploaded?: StringFieldUpdateOperationsInput | string
    body?: JsonNullValueInput | InputJsonValue
  }

  export type BlogsUncheckedUpdateManyInput = {
    blogId?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uploaded?: StringFieldUpdateOperationsInput | string
    body?: JsonNullValueInput | InputJsonValue
  }

  export type BugReportsCreateInput = {
    bug: string
    date: Date | string
    description: string
    severity: string
    status: string
    uid: string
  }

  export type BugReportsUncheckedCreateInput = {
    bugReportId?: number
    bug: string
    date: Date | string
    description: string
    severity: string
    status: string
    uid: string
  }

  export type BugReportsUpdateInput = {
    bug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type BugReportsUncheckedUpdateInput = {
    bugReportId?: IntFieldUpdateOperationsInput | number
    bug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type BugReportsCreateManyInput = {
    bugReportId?: number
    bug: string
    date: Date | string
    description: string
    severity: string
    status: string
    uid: string
  }

  export type BugReportsUpdateManyMutationInput = {
    bug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type BugReportsUncheckedUpdateManyInput = {
    bugReportId?: IntFieldUpdateOperationsInput | number
    bug?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessInterestCreateInput = {
    email: string
    forename: string
    surname: string
    sector?: string | null
    subsector?: string | null
  }

  export type BusinessInterestUncheckedCreateInput = {
    businessInterestId?: number
    email: string
    forename: string
    surname: string
    sector?: string | null
    subsector?: string | null
  }

  export type BusinessInterestUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    forename?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessInterestUncheckedUpdateInput = {
    businessInterestId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    forename?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessInterestCreateManyInput = {
    businessInterestId?: number
    email: string
    forename: string
    surname: string
    sector?: string | null
    subsector?: string | null
  }

  export type BusinessInterestUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    forename?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessInterestUncheckedUpdateManyInput = {
    businessInterestId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    forename?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CohortsCreateInput = {
    designatedStaff: string
    oId: number
    product: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
  }

  export type CohortsUncheckedCreateInput = {
    cohortId?: number
    designatedStaff: string
    oId: number
    product: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
  }

  export type CohortsUpdateInput = {
    designatedStaff?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
  }

  export type CohortsUncheckedUpdateInput = {
    cohortId?: IntFieldUpdateOperationsInput | number
    designatedStaff?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
  }

  export type CohortsCreateManyInput = {
    cohortId?: number
    designatedStaff: string
    oId: number
    product: string
    stage: string
    placementType: string
    name: string
    startPlacements: string
    endPlacements: string
    startSubmission: string
    endSubmission: string
    includedFiles?: CohortsCreateincludedFilesInput | string[]
    includedForms?: CohortsCreateincludedFormsInput | string[]
    workflow: string
  }

  export type CohortsUpdateManyMutationInput = {
    designatedStaff?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
  }

  export type CohortsUncheckedUpdateManyInput = {
    cohortId?: IntFieldUpdateOperationsInput | number
    designatedStaff?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    placementType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startPlacements?: StringFieldUpdateOperationsInput | string
    endPlacements?: StringFieldUpdateOperationsInput | string
    startSubmission?: StringFieldUpdateOperationsInput | string
    endSubmission?: StringFieldUpdateOperationsInput | string
    includedFiles?: CohortsUpdateincludedFilesInput | string[]
    includedForms?: CohortsUpdateincludedFormsInput | string[]
    workflow?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsCreateInput = {
    address_line1: string
    address_line2: string
    contactForename: string
    contactSurname: string
    country: string
    created: string
    locality: string
    name: string
    providerEmail: string
    providerPhone: string
    postal_code: string
    uid: string
  }

  export type ContactsUncheckedCreateInput = {
    contactId?: number
    address_line1: string
    address_line2: string
    contactForename: string
    contactSurname: string
    country: string
    created: string
    locality: string
    name: string
    providerEmail: string
    providerPhone: string
    postal_code: string
    uid: string
  }

  export type ContactsUpdateInput = {
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsUncheckedUpdateInput = {
    contactId?: IntFieldUpdateOperationsInput | number
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsCreateManyInput = {
    contactId?: number
    address_line1: string
    address_line2: string
    contactForename: string
    contactSurname: string
    country: string
    created: string
    locality: string
    name: string
    providerEmail: string
    providerPhone: string
    postal_code: string
    uid: string
  }

  export type ContactsUpdateManyMutationInput = {
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsUncheckedUpdateManyInput = {
    contactId?: IntFieldUpdateOperationsInput | number
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type DowntimeCreateInput = {
    active: boolean
    body: string
    products?: DowntimeCreateproductsInput | string[]
    title: string
  }

  export type DowntimeUncheckedCreateInput = {
    downtimeId?: number
    active: boolean
    body: string
    products?: DowntimeCreateproductsInput | string[]
    title: string
  }

  export type DowntimeUpdateInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    products?: DowntimeUpdateproductsInput | string[]
    title?: StringFieldUpdateOperationsInput | string
  }

  export type DowntimeUncheckedUpdateInput = {
    downtimeId?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    products?: DowntimeUpdateproductsInput | string[]
    title?: StringFieldUpdateOperationsInput | string
  }

  export type DowntimeCreateManyInput = {
    downtimeId?: number
    active: boolean
    body: string
    products?: DowntimeCreateproductsInput | string[]
    title: string
  }

  export type DowntimeUpdateManyMutationInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    products?: DowntimeUpdateproductsInput | string[]
    title?: StringFieldUpdateOperationsInput | string
  }

  export type DowntimeUncheckedUpdateManyInput = {
    downtimeId?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    products?: DowntimeUpdateproductsInput | string[]
    title?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureRequestsCreateInput = {
    date: Date | string
    description: string
    feature: string
    impact: string
    uid: string
  }

  export type FeatureRequestsUncheckedCreateInput = {
    featureRequestId?: number
    date: Date | string
    description: string
    feature: string
    impact: string
    uid: string
  }

  export type FeatureRequestsUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureRequestsUncheckedUpdateInput = {
    featureRequestId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureRequestsCreateManyInput = {
    featureRequestId?: number
    date: Date | string
    description: string
    feature: string
    impact: string
    uid: string
  }

  export type FeatureRequestsUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureRequestsUncheckedUpdateManyInput = {
    featureRequestId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackCreateInput = {
    created: Date | string
    msg: string
    title: string
    uid: string
  }

  export type FeedbackUncheckedCreateInput = {
    feedbackId?: number
    created: Date | string
    msg: string
    title: string
    uid: string
  }

  export type FeedbackUpdateInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    msg?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackUncheckedUpdateInput = {
    feedbackId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    msg?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackCreateManyInput = {
    feedbackId?: number
    created: Date | string
    msg: string
    title: string
    uid: string
  }

  export type FeedbackUpdateManyMutationInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    msg?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    feedbackId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    msg?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type FormsCreateInput = {
    form: JsonNullValueInput | InputJsonValue
    oId: number
    product: string
    updated: string
  }

  export type FormsUncheckedCreateInput = {
    formId?: number
    form: JsonNullValueInput | InputJsonValue
    oId: number
    product: string
    updated: string
  }

  export type FormsUpdateInput = {
    form?: JsonNullValueInput | InputJsonValue
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type FormsUncheckedUpdateInput = {
    formId?: IntFieldUpdateOperationsInput | number
    form?: JsonNullValueInput | InputJsonValue
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type FormsCreateManyInput = {
    formId?: number
    form: JsonNullValueInput | InputJsonValue
    oId: number
    product: string
    updated: string
  }

  export type FormsUpdateManyMutationInput = {
    form?: JsonNullValueInput | InputJsonValue
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type FormsUncheckedUpdateManyInput = {
    formId?: IntFieldUpdateOperationsInput | number
    form?: JsonNullValueInput | InputJsonValue
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type InstitutesCreateInput = {
    address_line1: string
    address_line2: string
    admin: string
    country: string
    externalProviderUploads: boolean
    geoHash: string
    locality: string
    name: string
    postal_code: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
  }

  export type InstitutesUncheckedCreateInput = {
    instituteId?: number
    address_line1: string
    address_line2: string
    admin: string
    country: string
    externalProviderUploads: boolean
    geoHash: string
    locality: string
    name: string
    postal_code: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
  }

  export type InstitutesUpdateInput = {
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    geoHash?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
  }

  export type InstitutesUncheckedUpdateInput = {
    instituteId?: IntFieldUpdateOperationsInput | number
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    geoHash?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
  }

  export type InstitutesCreateManyInput = {
    instituteId?: number
    address_line1: string
    address_line2: string
    admin: string
    country: string
    externalProviderUploads: boolean
    geoHash: string
    locality: string
    name: string
    postal_code: string
    referral?: string | null
    status: string
    studentsFields?: InstitutesCreatestudentsFieldsInput | string[]
    staff: number
    staffActive: number
    students: number
    studentsActive: number
    staffFields?: InstitutesCreatestaffFieldsInput | string[]
    staffGuidance: JsonNullValueInput | InputJsonValue
    studentsGuidance: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesCreateverifiedProvidersInput | string[]
  }

  export type InstitutesUpdateManyMutationInput = {
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    geoHash?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
  }

  export type InstitutesUncheckedUpdateManyInput = {
    instituteId?: IntFieldUpdateOperationsInput | number
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    admin?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    externalProviderUploads?: BoolFieldUpdateOperationsInput | boolean
    geoHash?: StringFieldUpdateOperationsInput | string
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studentsFields?: InstitutesUpdatestudentsFieldsInput | string[]
    staff?: IntFieldUpdateOperationsInput | number
    staffActive?: IntFieldUpdateOperationsInput | number
    students?: IntFieldUpdateOperationsInput | number
    studentsActive?: IntFieldUpdateOperationsInput | number
    staffFields?: InstitutesUpdatestaffFieldsInput | string[]
    staffGuidance?: JsonNullValueInput | InputJsonValue
    studentsGuidance?: JsonNullValueInput | InputJsonValue
    verifiedProviders?: InstitutesUpdateverifiedProvidersInput | string[]
  }

  export type JobsCreateInput = {
    started: string
    updated?: string | null
    finished?: string | null
    title: string
    description: string
    status: string
    logs: JsonNullValueInput | InputJsonValue
    outputMsg?: string | null
    viewedBy?: JobsCreateviewedByInput | string[]
    oId: number
    product: string
  }

  export type JobsUncheckedCreateInput = {
    jobId?: number
    started: string
    updated?: string | null
    finished?: string | null
    title: string
    description: string
    status: string
    logs: JsonNullValueInput | InputJsonValue
    outputMsg?: string | null
    viewedBy?: JobsCreateviewedByInput | string[]
    oId: number
    product: string
  }

  export type JobsUpdateInput = {
    started?: StringFieldUpdateOperationsInput | string
    updated?: NullableStringFieldUpdateOperationsInput | string | null
    finished?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    logs?: JsonNullValueInput | InputJsonValue
    outputMsg?: NullableStringFieldUpdateOperationsInput | string | null
    viewedBy?: JobsUpdateviewedByInput | string[]
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
  }

  export type JobsUncheckedUpdateInput = {
    jobId?: IntFieldUpdateOperationsInput | number
    started?: StringFieldUpdateOperationsInput | string
    updated?: NullableStringFieldUpdateOperationsInput | string | null
    finished?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    logs?: JsonNullValueInput | InputJsonValue
    outputMsg?: NullableStringFieldUpdateOperationsInput | string | null
    viewedBy?: JobsUpdateviewedByInput | string[]
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
  }

  export type JobsCreateManyInput = {
    jobId?: number
    started: string
    updated?: string | null
    finished?: string | null
    title: string
    description: string
    status: string
    logs: JsonNullValueInput | InputJsonValue
    outputMsg?: string | null
    viewedBy?: JobsCreateviewedByInput | string[]
    oId: number
    product: string
  }

  export type JobsUpdateManyMutationInput = {
    started?: StringFieldUpdateOperationsInput | string
    updated?: NullableStringFieldUpdateOperationsInput | string | null
    finished?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    logs?: JsonNullValueInput | InputJsonValue
    outputMsg?: NullableStringFieldUpdateOperationsInput | string | null
    viewedBy?: JobsUpdateviewedByInput | string[]
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
  }

  export type JobsUncheckedUpdateManyInput = {
    jobId?: IntFieldUpdateOperationsInput | number
    started?: StringFieldUpdateOperationsInput | string
    updated?: NullableStringFieldUpdateOperationsInput | string | null
    finished?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    logs?: JsonNullValueInput | InputJsonValue
    outputMsg?: NullableStringFieldUpdateOperationsInput | string | null
    viewedBy?: JobsUpdateviewedByInput | string[]
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
  }

  export type LogsCreateInput = {
    oId: number
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
  }

  export type LogsUncheckedCreateInput = {
    logId?: number
    oId: number
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
  }

  export type LogsUpdateInput = {
    oId?: IntFieldUpdateOperationsInput | number
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type LogsUncheckedUpdateInput = {
    logId?: IntFieldUpdateOperationsInput | number
    oId?: IntFieldUpdateOperationsInput | number
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type LogsCreateManyInput = {
    logId?: number
    oId: number
    provider: JsonNullValueInput | InputJsonValue
    students: JsonNullValueInput | InputJsonValue
    staff: JsonNullValueInput | InputJsonValue
    uid: string
  }

  export type LogsUpdateManyMutationInput = {
    oId?: IntFieldUpdateOperationsInput | number
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type LogsUncheckedUpdateManyInput = {
    logId?: IntFieldUpdateOperationsInput | number
    oId?: IntFieldUpdateOperationsInput | number
    provider?: JsonNullValueInput | InputJsonValue
    students?: JsonNullValueInput | InputJsonValue
    staff?: JsonNullValueInput | InputJsonValue
    uid?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsCreateInput = {
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementListingsUncheckedCreateInput = {
    placementListingId?: number
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementListingsUpdateInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsUncheckedUpdateInput = {
    placementListingId?: IntFieldUpdateOperationsInput | number
    addressId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsCreateManyInput = {
    placementListingId?: number
    addressId: string
    contactForename: string
    contactSurname: string
    created: Date | string
    mapConsent: boolean
    mapConsentDate: string
    providerEmail: string
    providerId: string
    providerPhone: string
    savedBy: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    title: string
    uploadedBy: string
  }

  export type PlacementListingsUpdateManyMutationInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementListingsUncheckedUpdateManyInput = {
    placementListingId?: IntFieldUpdateOperationsInput | number
    addressId?: StringFieldUpdateOperationsInput | string
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlacementsCreateInput = {
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    address_line1: string
    address_line2: string
    cohortId: number
    contactForename: string
    contactSurname: string
    country: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    locality: string
    name: string
    oId?: number | null
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    postal_code: string
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    uid: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    userGroup?: number | null
  }

  export type PlacementsUncheckedCreateInput = {
    placementId?: number
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    address_line1: string
    address_line2: string
    cohortId: number
    contactForename: string
    contactSurname: string
    country: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    locality: string
    name: string
    oId?: number | null
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    postal_code: string
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    uid: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    userGroup?: number | null
  }

  export type PlacementsUpdateInput = {
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    cohortId?: IntFieldUpdateOperationsInput | number
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    oId?: NullableIntFieldUpdateOperationsInput | number | null
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: StringFieldUpdateOperationsInput | string
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    userGroup?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlacementsUncheckedUpdateInput = {
    placementId?: IntFieldUpdateOperationsInput | number
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    cohortId?: IntFieldUpdateOperationsInput | number
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    oId?: NullableIntFieldUpdateOperationsInput | number | null
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: StringFieldUpdateOperationsInput | string
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    userGroup?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlacementsCreateManyInput = {
    placementId?: number
    activeDates?: PlacementsCreateactiveDatesInput | string[]
    address_line1: string
    address_line2: string
    cohortId: number
    contactForename: string
    contactSurname: string
    country: string
    created: string
    draft: boolean
    endDate: string
    flags?: PlacementsCreateflagsInput | string[]
    geoHash: string
    inProgress: boolean
    leadTimes?: PlacementsCreateleadTimesInput | string[]
    locality: string
    name: string
    oId?: number | null
    parentEmailed?: Date | string | null
    parentExpiry?: string | null
    parentKey?: string | null
    postal_code: string
    product?: string | null
    providerEmail?: string | null
    providerEmailed?: Date | string | null
    providerExpiry?: string | null
    providerKey?: string | null
    providerName?: string | null
    providerPhone: string
    nextStatus?: number | null
    status: number
    startDate: string
    title: string
    uid: string
    forms: JsonNullValueInput | InputJsonValue
    questions: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    userGroup?: number | null
  }

  export type PlacementsUpdateManyMutationInput = {
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    cohortId?: IntFieldUpdateOperationsInput | number
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    oId?: NullableIntFieldUpdateOperationsInput | number | null
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: StringFieldUpdateOperationsInput | string
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    userGroup?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlacementsUncheckedUpdateManyInput = {
    placementId?: IntFieldUpdateOperationsInput | number
    activeDates?: PlacementsUpdateactiveDatesInput | string[]
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    cohortId?: IntFieldUpdateOperationsInput | number
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    draft?: BoolFieldUpdateOperationsInput | boolean
    endDate?: StringFieldUpdateOperationsInput | string
    flags?: PlacementsUpdateflagsInput | string[]
    geoHash?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    leadTimes?: PlacementsUpdateleadTimesInput | string[]
    locality?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    oId?: NullableIntFieldUpdateOperationsInput | number | null
    parentEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    parentKey?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: StringFieldUpdateOperationsInput | string
    product?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    providerEmailed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerPhone?: StringFieldUpdateOperationsInput | string
    nextStatus?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    uid?: StringFieldUpdateOperationsInput | string
    forms?: JsonNullValueInput | InputJsonValue
    questions?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    userGroup?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProvidersCreateInput = {
    contactForename: string
    contactSurname: string
    defAddress: number
    email: string
    mapConsent: boolean
    insurance: boolean
    mapConsentDate: string
    name: string
    phone: string
    rememberConsent: boolean
    rememberConsentDate: string
    savedBy: JsonNullValueInput | InputJsonValue
    sector: string
    subsector: string
    uploadedBy: string
    website: string
  }

  export type ProvidersUncheckedCreateInput = {
    providerId?: number
    contactForename: string
    contactSurname: string
    defAddress: number
    email: string
    mapConsent: boolean
    insurance: boolean
    mapConsentDate: string
    name: string
    phone: string
    rememberConsent: boolean
    rememberConsentDate: string
    savedBy: JsonNullValueInput | InputJsonValue
    sector: string
    subsector: string
    uploadedBy: string
    website: string
  }

  export type ProvidersUpdateInput = {
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    defAddress?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    insurance?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: BoolFieldUpdateOperationsInput | boolean
    rememberConsentDate?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type ProvidersUncheckedUpdateInput = {
    providerId?: IntFieldUpdateOperationsInput | number
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    defAddress?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    insurance?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: BoolFieldUpdateOperationsInput | boolean
    rememberConsentDate?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type ProvidersCreateManyInput = {
    providerId?: number
    contactForename: string
    contactSurname: string
    defAddress: number
    email: string
    mapConsent: boolean
    insurance: boolean
    mapConsentDate: string
    name: string
    phone: string
    rememberConsent: boolean
    rememberConsentDate: string
    savedBy: JsonNullValueInput | InputJsonValue
    sector: string
    subsector: string
    uploadedBy: string
    website: string
  }

  export type ProvidersUpdateManyMutationInput = {
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    defAddress?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    insurance?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: BoolFieldUpdateOperationsInput | boolean
    rememberConsentDate?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type ProvidersUncheckedUpdateManyInput = {
    providerId?: IntFieldUpdateOperationsInput | number
    contactForename?: StringFieldUpdateOperationsInput | string
    contactSurname?: StringFieldUpdateOperationsInput | string
    defAddress?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    mapConsent?: BoolFieldUpdateOperationsInput | boolean
    insurance?: BoolFieldUpdateOperationsInput | boolean
    mapConsentDate?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    rememberConsent?: BoolFieldUpdateOperationsInput | boolean
    rememberConsentDate?: StringFieldUpdateOperationsInput | string
    savedBy?: JsonNullValueInput | InputJsonValue
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralsCreateInput = {
    expiry: Date | string
    name: string
    product: string
    signUps: number
    volume: number
  }

  export type ReferralsUncheckedCreateInput = {
    referralId?: number
    expiry: Date | string
    name: string
    product: string
    signUps: number
    volume: number
  }

  export type ReferralsUpdateInput = {
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    signUps?: IntFieldUpdateOperationsInput | number
    volume?: IntFieldUpdateOperationsInput | number
  }

  export type ReferralsUncheckedUpdateInput = {
    referralId?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    signUps?: IntFieldUpdateOperationsInput | number
    volume?: IntFieldUpdateOperationsInput | number
  }

  export type ReferralsCreateManyInput = {
    referralId?: number
    expiry: Date | string
    name: string
    product: string
    signUps: number
    volume: number
  }

  export type ReferralsUpdateManyMutationInput = {
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    signUps?: IntFieldUpdateOperationsInput | number
    volume?: IntFieldUpdateOperationsInput | number
  }

  export type ReferralsUncheckedUpdateManyInput = {
    referralId?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    signUps?: IntFieldUpdateOperationsInput | number
    volume?: IntFieldUpdateOperationsInput | number
  }

  export type UserGroupsCreateInput = {
    default: boolean
    name: string
    oId: number
    product: string
    template: string
    updated: string
  }

  export type UserGroupsUncheckedCreateInput = {
    userGroupId?: number
    default: boolean
    name: string
    oId: number
    product: string
    template: string
    updated: string
  }

  export type UserGroupsUpdateInput = {
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupsUncheckedUpdateInput = {
    userGroupId?: IntFieldUpdateOperationsInput | number
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupsCreateManyInput = {
    userGroupId?: number
    default: boolean
    name: string
    oId: number
    product: string
    template: string
    updated: string
  }

  export type UserGroupsUpdateManyMutationInput = {
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupsUncheckedUpdateManyInput = {
    userGroupId?: IntFieldUpdateOperationsInput | number
    default?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    oId?: IntFieldUpdateOperationsInput | number
    product?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    updated?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUsersCreateInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
  }

  export type StudentUsersUncheckedCreateInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
  }

  export type StudentUsersUpdateInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUsersUncheckedUpdateInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUsersCreateManyInput = {
    studentUserId: string
    status: string
    analytics: JsonNullValueInput | InputJsonValue
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    referral: string
    units: string
    userType: string
  }

  export type StudentUsersUpdateManyMutationInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUsersUncheckedUpdateManyInput = {
    studentUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    analytics?: JsonNullValueInput | InputJsonValue
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    units?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffCreateInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userGroup: string
    userType: string
  }

  export type InstituteStaffUncheckedCreateInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userGroup: string
    userType: string
  }

  export type InstituteStaffUpdateInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUncheckedUpdateInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffCreateManyInput = {
    instituteStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    email: string
    oId: string
    status: string
    userGroup: string
    userType: string
  }

  export type InstituteStaffUpdateManyMutationInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStaffUncheckedUpdateManyInput = {
    instituteStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsCreateInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: number
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: number
    resetExpiry: Date | string
    status: string
    userGroup: number
    userType: string
  }

  export type InstituteStudentsUncheckedCreateInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: number
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: number
    resetExpiry: Date | string
    status: string
    userGroup: number
    userType: string
  }

  export type InstituteStudentsUpdateInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: IntFieldUpdateOperationsInput | number
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: IntFieldUpdateOperationsInput | number
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: IntFieldUpdateOperationsInput | number
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsUncheckedUpdateInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: IntFieldUpdateOperationsInput | number
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: IntFieldUpdateOperationsInput | number
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: IntFieldUpdateOperationsInput | number
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsCreateManyInput = {
    instituteStudentId: string
    activated: string
    created: string
    cohortId: number
    details: JsonNullValueInput | InputJsonValue
    email: string
    flags?: InstituteStudentsCreateflagsInput | string[]
    oId: number
    resetExpiry: Date | string
    status: string
    userGroup: number
    userType: string
  }

  export type InstituteStudentsUpdateManyMutationInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: IntFieldUpdateOperationsInput | number
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: IntFieldUpdateOperationsInput | number
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: IntFieldUpdateOperationsInput | number
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type InstituteStudentsUncheckedUpdateManyInput = {
    instituteStudentId?: StringFieldUpdateOperationsInput | string
    activated?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    cohortId?: IntFieldUpdateOperationsInput | number
    details?: JsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    flags?: InstituteStudentsUpdateflagsInput | string[]
    oId?: IntFieldUpdateOperationsInput | number
    resetExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: IntFieldUpdateOperationsInput | number
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffCreateInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    cohortId: number
    email: string
    notes: JsonNullValueInput | InputJsonValue
    oId: string
    status: string
    userGroup: string
    userType: string
  }

  export type ProviderStaffUncheckedCreateInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    cohortId: number
    email: string
    notes: JsonNullValueInput | InputJsonValue
    oId: string
    status: string
    userGroup: string
    userType: string
  }

  export type ProviderStaffUpdateInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    cohortId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffUncheckedUpdateInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    cohortId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffCreateManyInput = {
    providerStaffId: string
    created: string
    details: JsonNullValueInput | InputJsonValue
    cohortId: number
    email: string
    notes: JsonNullValueInput | InputJsonValue
    oId: string
    status: string
    userGroup: string
    userType: string
  }

  export type ProviderStaffUpdateManyMutationInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    cohortId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderStaffUncheckedUpdateManyInput = {
    providerStaffId?: StringFieldUpdateOperationsInput | string
    created?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    cohortId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    oId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userGroup?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AddressesCountOrderByAggregateInput = {
    addressId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    email?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    phone?: SortOrder
    postal_code?: SortOrder
  }

  export type AddressesAvgOrderByAggregateInput = {
    addressId?: SortOrder
    oId?: SortOrder
  }

  export type AddressesMaxOrderByAggregateInput = {
    addressId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    email?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    phone?: SortOrder
    postal_code?: SortOrder
  }

  export type AddressesMinOrderByAggregateInput = {
    addressId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    email?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    phone?: SortOrder
    postal_code?: SortOrder
  }

  export type AddressesSumOrderByAggregateInput = {
    addressId?: SortOrder
    oId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BlogsCountOrderByAggregateInput = {
    blogId?: SortOrder
    author?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    tags?: SortOrder
    title?: SortOrder
    uploaded?: SortOrder
    body?: SortOrder
  }

  export type BlogsAvgOrderByAggregateInput = {
    blogId?: SortOrder
  }

  export type BlogsMaxOrderByAggregateInput = {
    blogId?: SortOrder
    author?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    tags?: SortOrder
    title?: SortOrder
    uploaded?: SortOrder
  }

  export type BlogsMinOrderByAggregateInput = {
    blogId?: SortOrder
    author?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    tags?: SortOrder
    title?: SortOrder
    uploaded?: SortOrder
  }

  export type BlogsSumOrderByAggregateInput = {
    blogId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BugReportsCountOrderByAggregateInput = {
    bugReportId?: SortOrder
    bug?: SortOrder
    date?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    uid?: SortOrder
  }

  export type BugReportsAvgOrderByAggregateInput = {
    bugReportId?: SortOrder
  }

  export type BugReportsMaxOrderByAggregateInput = {
    bugReportId?: SortOrder
    bug?: SortOrder
    date?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    uid?: SortOrder
  }

  export type BugReportsMinOrderByAggregateInput = {
    bugReportId?: SortOrder
    bug?: SortOrder
    date?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    uid?: SortOrder
  }

  export type BugReportsSumOrderByAggregateInput = {
    bugReportId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BusinessInterestCountOrderByAggregateInput = {
    businessInterestId?: SortOrder
    email?: SortOrder
    forename?: SortOrder
    surname?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
  }

  export type BusinessInterestAvgOrderByAggregateInput = {
    businessInterestId?: SortOrder
  }

  export type BusinessInterestMaxOrderByAggregateInput = {
    businessInterestId?: SortOrder
    email?: SortOrder
    forename?: SortOrder
    surname?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
  }

  export type BusinessInterestMinOrderByAggregateInput = {
    businessInterestId?: SortOrder
    email?: SortOrder
    forename?: SortOrder
    surname?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
  }

  export type BusinessInterestSumOrderByAggregateInput = {
    businessInterestId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CohortsCountOrderByAggregateInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    includedFiles?: SortOrder
    includedForms?: SortOrder
    workflow?: SortOrder
  }

  export type CohortsAvgOrderByAggregateInput = {
    cohortId?: SortOrder
    oId?: SortOrder
  }

  export type CohortsMaxOrderByAggregateInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    workflow?: SortOrder
  }

  export type CohortsMinOrderByAggregateInput = {
    cohortId?: SortOrder
    designatedStaff?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    stage?: SortOrder
    placementType?: SortOrder
    name?: SortOrder
    startPlacements?: SortOrder
    endPlacements?: SortOrder
    startSubmission?: SortOrder
    endSubmission?: SortOrder
    workflow?: SortOrder
  }

  export type CohortsSumOrderByAggregateInput = {
    cohortId?: SortOrder
    oId?: SortOrder
  }

  export type ContactsCountOrderByAggregateInput = {
    contactId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    providerEmail?: SortOrder
    providerPhone?: SortOrder
    postal_code?: SortOrder
    uid?: SortOrder
  }

  export type ContactsAvgOrderByAggregateInput = {
    contactId?: SortOrder
  }

  export type ContactsMaxOrderByAggregateInput = {
    contactId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    providerEmail?: SortOrder
    providerPhone?: SortOrder
    postal_code?: SortOrder
    uid?: SortOrder
  }

  export type ContactsMinOrderByAggregateInput = {
    contactId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    providerEmail?: SortOrder
    providerPhone?: SortOrder
    postal_code?: SortOrder
    uid?: SortOrder
  }

  export type ContactsSumOrderByAggregateInput = {
    contactId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DowntimeCountOrderByAggregateInput = {
    downtimeId?: SortOrder
    active?: SortOrder
    body?: SortOrder
    products?: SortOrder
    title?: SortOrder
  }

  export type DowntimeAvgOrderByAggregateInput = {
    downtimeId?: SortOrder
  }

  export type DowntimeMaxOrderByAggregateInput = {
    downtimeId?: SortOrder
    active?: SortOrder
    body?: SortOrder
    title?: SortOrder
  }

  export type DowntimeMinOrderByAggregateInput = {
    downtimeId?: SortOrder
    active?: SortOrder
    body?: SortOrder
    title?: SortOrder
  }

  export type DowntimeSumOrderByAggregateInput = {
    downtimeId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FeatureRequestsCountOrderByAggregateInput = {
    featureRequestId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    feature?: SortOrder
    impact?: SortOrder
    uid?: SortOrder
  }

  export type FeatureRequestsAvgOrderByAggregateInput = {
    featureRequestId?: SortOrder
  }

  export type FeatureRequestsMaxOrderByAggregateInput = {
    featureRequestId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    feature?: SortOrder
    impact?: SortOrder
    uid?: SortOrder
  }

  export type FeatureRequestsMinOrderByAggregateInput = {
    featureRequestId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    feature?: SortOrder
    impact?: SortOrder
    uid?: SortOrder
  }

  export type FeatureRequestsSumOrderByAggregateInput = {
    featureRequestId?: SortOrder
  }

  export type FeedbackCountOrderByAggregateInput = {
    feedbackId?: SortOrder
    created?: SortOrder
    msg?: SortOrder
    title?: SortOrder
    uid?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    feedbackId?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    feedbackId?: SortOrder
    created?: SortOrder
    msg?: SortOrder
    title?: SortOrder
    uid?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    feedbackId?: SortOrder
    created?: SortOrder
    msg?: SortOrder
    title?: SortOrder
    uid?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    feedbackId?: SortOrder
  }

  export type FormsCountOrderByAggregateInput = {
    formId?: SortOrder
    form?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    updated?: SortOrder
  }

  export type FormsAvgOrderByAggregateInput = {
    formId?: SortOrder
    oId?: SortOrder
  }

  export type FormsMaxOrderByAggregateInput = {
    formId?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    updated?: SortOrder
  }

  export type FormsMinOrderByAggregateInput = {
    formId?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    updated?: SortOrder
  }

  export type FormsSumOrderByAggregateInput = {
    formId?: SortOrder
    oId?: SortOrder
  }

  export type InstitutesCountOrderByAggregateInput = {
    instituteId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    admin?: SortOrder
    country?: SortOrder
    externalProviderUploads?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
    referral?: SortOrder
    status?: SortOrder
    studentsFields?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
    staffFields?: SortOrder
    staffGuidance?: SortOrder
    studentsGuidance?: SortOrder
    verifiedProviders?: SortOrder
  }

  export type InstitutesAvgOrderByAggregateInput = {
    instituteId?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
  }

  export type InstitutesMaxOrderByAggregateInput = {
    instituteId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    admin?: SortOrder
    country?: SortOrder
    externalProviderUploads?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
    referral?: SortOrder
    status?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
  }

  export type InstitutesMinOrderByAggregateInput = {
    instituteId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    admin?: SortOrder
    country?: SortOrder
    externalProviderUploads?: SortOrder
    geoHash?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
    referral?: SortOrder
    status?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
  }

  export type InstitutesSumOrderByAggregateInput = {
    instituteId?: SortOrder
    staff?: SortOrder
    staffActive?: SortOrder
    students?: SortOrder
    studentsActive?: SortOrder
  }

  export type JobsCountOrderByAggregateInput = {
    jobId?: SortOrder
    started?: SortOrder
    updated?: SortOrder
    finished?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    logs?: SortOrder
    outputMsg?: SortOrder
    viewedBy?: SortOrder
    oId?: SortOrder
    product?: SortOrder
  }

  export type JobsAvgOrderByAggregateInput = {
    jobId?: SortOrder
    oId?: SortOrder
  }

  export type JobsMaxOrderByAggregateInput = {
    jobId?: SortOrder
    started?: SortOrder
    updated?: SortOrder
    finished?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    outputMsg?: SortOrder
    oId?: SortOrder
    product?: SortOrder
  }

  export type JobsMinOrderByAggregateInput = {
    jobId?: SortOrder
    started?: SortOrder
    updated?: SortOrder
    finished?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    outputMsg?: SortOrder
    oId?: SortOrder
    product?: SortOrder
  }

  export type JobsSumOrderByAggregateInput = {
    jobId?: SortOrder
    oId?: SortOrder
  }

  export type LogsCountOrderByAggregateInput = {
    logId?: SortOrder
    oId?: SortOrder
    provider?: SortOrder
    students?: SortOrder
    staff?: SortOrder
    uid?: SortOrder
  }

  export type LogsAvgOrderByAggregateInput = {
    logId?: SortOrder
    oId?: SortOrder
  }

  export type LogsMaxOrderByAggregateInput = {
    logId?: SortOrder
    oId?: SortOrder
    uid?: SortOrder
  }

  export type LogsMinOrderByAggregateInput = {
    logId?: SortOrder
    oId?: SortOrder
    uid?: SortOrder
  }

  export type LogsSumOrderByAggregateInput = {
    logId?: SortOrder
    oId?: SortOrder
  }

  export type PlacementListingsCountOrderByAggregateInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    savedBy?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
  }

  export type PlacementListingsAvgOrderByAggregateInput = {
    placementListingId?: SortOrder
  }

  export type PlacementListingsMaxOrderByAggregateInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
  }

  export type PlacementListingsMinOrderByAggregateInput = {
    placementListingId?: SortOrder
    addressId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    created?: SortOrder
    mapConsent?: SortOrder
    mapConsentDate?: SortOrder
    providerEmail?: SortOrder
    providerId?: SortOrder
    providerPhone?: SortOrder
    title?: SortOrder
    uploadedBy?: SortOrder
  }

  export type PlacementListingsSumOrderByAggregateInput = {
    placementListingId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PlacementsCountOrderByAggregateInput = {
    placementId?: SortOrder
    activeDates?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    flags?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    leadTimes?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    oId?: SortOrder
    parentEmailed?: SortOrder
    parentExpiry?: SortOrder
    parentKey?: SortOrder
    postal_code?: SortOrder
    product?: SortOrder
    providerEmail?: SortOrder
    providerEmailed?: SortOrder
    providerExpiry?: SortOrder
    providerKey?: SortOrder
    providerName?: SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    uid?: SortOrder
    forms?: SortOrder
    questions?: SortOrder
    uploadedBy?: SortOrder
    userGroup?: SortOrder
  }

  export type PlacementsAvgOrderByAggregateInput = {
    placementId?: SortOrder
    cohortId?: SortOrder
    oId?: SortOrder
    nextStatus?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
  }

  export type PlacementsMaxOrderByAggregateInput = {
    placementId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    oId?: SortOrder
    parentEmailed?: SortOrder
    parentExpiry?: SortOrder
    parentKey?: SortOrder
    postal_code?: SortOrder
    product?: SortOrder
    providerEmail?: SortOrder
    providerEmailed?: SortOrder
    providerExpiry?: SortOrder
    providerKey?: SortOrder
    providerName?: SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    uid?: SortOrder
    uploadedBy?: SortOrder
    userGroup?: SortOrder
  }

  export type PlacementsMinOrderByAggregateInput = {
    placementId?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    cohortId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    country?: SortOrder
    created?: SortOrder
    draft?: SortOrder
    endDate?: SortOrder
    geoHash?: SortOrder
    inProgress?: SortOrder
    locality?: SortOrder
    name?: SortOrder
    oId?: SortOrder
    parentEmailed?: SortOrder
    parentExpiry?: SortOrder
    parentKey?: SortOrder
    postal_code?: SortOrder
    product?: SortOrder
    providerEmail?: SortOrder
    providerEmailed?: SortOrder
    providerExpiry?: SortOrder
    providerKey?: SortOrder
    providerName?: SortOrder
    providerPhone?: SortOrder
    nextStatus?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    title?: SortOrder
    uid?: SortOrder
    uploadedBy?: SortOrder
    userGroup?: SortOrder
  }

  export type PlacementsSumOrderByAggregateInput = {
    placementId?: SortOrder
    cohortId?: SortOrder
    oId?: SortOrder
    nextStatus?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProvidersCountOrderByAggregateInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    defAddress?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrder
    insurance?: SortOrder
    mapConsentDate?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrder
    rememberConsentDate?: SortOrder
    savedBy?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrder
  }

  export type ProvidersAvgOrderByAggregateInput = {
    providerId?: SortOrder
    defAddress?: SortOrder
  }

  export type ProvidersMaxOrderByAggregateInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    defAddress?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrder
    insurance?: SortOrder
    mapConsentDate?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrder
    rememberConsentDate?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrder
  }

  export type ProvidersMinOrderByAggregateInput = {
    providerId?: SortOrder
    contactForename?: SortOrder
    contactSurname?: SortOrder
    defAddress?: SortOrder
    email?: SortOrder
    mapConsent?: SortOrder
    insurance?: SortOrder
    mapConsentDate?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    rememberConsent?: SortOrder
    rememberConsentDate?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
    uploadedBy?: SortOrder
    website?: SortOrder
  }

  export type ProvidersSumOrderByAggregateInput = {
    providerId?: SortOrder
    defAddress?: SortOrder
  }

  export type ReferralsCountOrderByAggregateInput = {
    referralId?: SortOrder
    expiry?: SortOrder
    name?: SortOrder
    product?: SortOrder
    signUps?: SortOrder
    volume?: SortOrder
  }

  export type ReferralsAvgOrderByAggregateInput = {
    referralId?: SortOrder
    signUps?: SortOrder
    volume?: SortOrder
  }

  export type ReferralsMaxOrderByAggregateInput = {
    referralId?: SortOrder
    expiry?: SortOrder
    name?: SortOrder
    product?: SortOrder
    signUps?: SortOrder
    volume?: SortOrder
  }

  export type ReferralsMinOrderByAggregateInput = {
    referralId?: SortOrder
    expiry?: SortOrder
    name?: SortOrder
    product?: SortOrder
    signUps?: SortOrder
    volume?: SortOrder
  }

  export type ReferralsSumOrderByAggregateInput = {
    referralId?: SortOrder
    signUps?: SortOrder
    volume?: SortOrder
  }

  export type UserGroupsCountOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    template?: SortOrder
    updated?: SortOrder
  }

  export type UserGroupsAvgOrderByAggregateInput = {
    userGroupId?: SortOrder
    oId?: SortOrder
  }

  export type UserGroupsMaxOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    template?: SortOrder
    updated?: SortOrder
  }

  export type UserGroupsMinOrderByAggregateInput = {
    userGroupId?: SortOrder
    default?: SortOrder
    name?: SortOrder
    oId?: SortOrder
    product?: SortOrder
    template?: SortOrder
    updated?: SortOrder
  }

  export type UserGroupsSumOrderByAggregateInput = {
    userGroupId?: SortOrder
    oId?: SortOrder
  }

  export type StudentUsersCountOrderByAggregateInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    analytics?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
  }

  export type StudentUsersMaxOrderByAggregateInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    created?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
  }

  export type StudentUsersMinOrderByAggregateInput = {
    studentUserId?: SortOrder
    status?: SortOrder
    created?: SortOrder
    email?: SortOrder
    referral?: SortOrder
    units?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStaffCountOrderByAggregateInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStaffMaxOrderByAggregateInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStaffMinOrderByAggregateInput = {
    instituteStaffId?: SortOrder
    created?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStudentsCountOrderByAggregateInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    details?: SortOrder
    email?: SortOrder
    flags?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStudentsAvgOrderByAggregateInput = {
    cohortId?: SortOrder
    oId?: SortOrder
    userGroup?: SortOrder
  }

  export type InstituteStudentsMaxOrderByAggregateInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStudentsMinOrderByAggregateInput = {
    instituteStudentId?: SortOrder
    activated?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    resetExpiry?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type InstituteStudentsSumOrderByAggregateInput = {
    cohortId?: SortOrder
    oId?: SortOrder
    userGroup?: SortOrder
  }

  export type ProviderStaffCountOrderByAggregateInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    details?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type ProviderStaffAvgOrderByAggregateInput = {
    cohortId?: SortOrder
  }

  export type ProviderStaffMaxOrderByAggregateInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type ProviderStaffMinOrderByAggregateInput = {
    providerStaffId?: SortOrder
    created?: SortOrder
    cohortId?: SortOrder
    email?: SortOrder
    oId?: SortOrder
    status?: SortOrder
    userGroup?: SortOrder
    userType?: SortOrder
  }

  export type ProviderStaffSumOrderByAggregateInput = {
    cohortId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CohortsCreateincludedFilesInput = {
    set: string[]
  }

  export type CohortsCreateincludedFormsInput = {
    set: string[]
  }

  export type CohortsUpdateincludedFilesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CohortsUpdateincludedFormsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DowntimeCreateproductsInput = {
    set: string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DowntimeUpdateproductsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutesCreatestudentsFieldsInput = {
    set: string[]
  }

  export type InstitutesCreatestaffFieldsInput = {
    set: string[]
  }

  export type InstitutesCreateverifiedProvidersInput = {
    set: string[]
  }

  export type InstitutesUpdatestudentsFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutesUpdatestaffFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutesUpdateverifiedProvidersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobsCreateviewedByInput = {
    set: string[]
  }

  export type JobsUpdateviewedByInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlacementsCreateactiveDatesInput = {
    set: string[]
  }

  export type PlacementsCreateflagsInput = {
    set: string[]
  }

  export type PlacementsCreateleadTimesInput = {
    set: string[]
  }

  export type PlacementsUpdateactiveDatesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlacementsUpdateflagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlacementsUpdateleadTimesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type InstituteStudentsCreateflagsInput = {
    set: string[]
  }

  export type InstituteStudentsUpdateflagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AddressesDefaultArgs instead
     */
    export type AddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogsDefaultArgs instead
     */
    export type BlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BugReportsDefaultArgs instead
     */
    export type BugReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BugReportsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessInterestDefaultArgs instead
     */
    export type BusinessInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessInterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CohortsDefaultArgs instead
     */
    export type CohortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CohortsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactsDefaultArgs instead
     */
    export type ContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DowntimeDefaultArgs instead
     */
    export type DowntimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DowntimeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeatureRequestsDefaultArgs instead
     */
    export type FeatureRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeatureRequestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackDefaultArgs instead
     */
    export type FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormsDefaultArgs instead
     */
    export type FormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstitutesDefaultArgs instead
     */
    export type InstitutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstitutesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobsDefaultArgs instead
     */
    export type JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogsDefaultArgs instead
     */
    export type LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlacementListingsDefaultArgs instead
     */
    export type PlacementListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlacementListingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlacementsDefaultArgs instead
     */
    export type PlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlacementsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProvidersDefaultArgs instead
     */
    export type ProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProvidersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralsDefaultArgs instead
     */
    export type ReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserGroupsDefaultArgs instead
     */
    export type UserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserGroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentUsersDefaultArgs instead
     */
    export type StudentUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentUsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStaffDefaultArgs instead
     */
    export type InstituteStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstituteStudentsDefaultArgs instead
     */
    export type InstituteStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstituteStudentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderStaffDefaultArgs instead
     */
    export type ProviderStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderStaffDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}